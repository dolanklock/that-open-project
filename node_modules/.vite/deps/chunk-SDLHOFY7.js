import {
  AmbientLight,
  BackSide,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  Clock,
  Color,
  ColorManagement,
  CylinderGeometry,
  DirectionalLight,
  DoubleSide,
  EdgesGeometry,
  Euler,
  FILE_DESCRIPTION,
  FILE_NAME,
  Float32BufferAttribute,
  FrontSide,
  Gi,
  Handle,
  Hi,
  IFCBUILDING,
  IFCBUILDINGSTOREY,
  IFCELEMENTQUANTITY,
  IFCOPENINGELEMENT,
  IFCOWNERHISTORY,
  IFCPROJECT,
  IFCPROPERTYSET,
  IFCRELAGGREGATES,
  IFCRELASSIGNSTOGROUP,
  IFCRELASSOCIATESCLASSIFICATION,
  IFCRELASSOCIATESMATERIAL,
  IFCRELCONTAINEDINSPATIALSTRUCTURE,
  IFCRELDEFINESBYPROPERTIES,
  IFCRELDEFINESBYTEMPLATE,
  IFCRELDEFINESBYTYPE,
  IFCSITE,
  IFCSPACE,
  IFCUNITASSIGNMENT,
  IfcAPI2,
  InstancedMesh,
  Js,
  Line,
  Line3,
  LineBasicMaterial,
  LogLevel,
  MOUSE,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshLambertMaterial,
  Ni,
  Object3D,
  OctahedronGeometry,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  Quaternion,
  Ray,
  Raycaster,
  Scene,
  ShaderMaterial,
  Sphere,
  SphereGeometry,
  Spherical,
  TorusGeometry,
  Triangle,
  Vector2,
  Vector3,
  Vector4,
  WebGLRenderTarget,
  WebGLRenderer,
  Xi,
  ji,
  ki,
  web_ifc_api_exports
} from "./chunk-OGNR6M4R.js";

// ../node_modules/@thatopen/components/dist/index.mjs
var Wn = Object.defineProperty;
var Xn = (l, s, t) => s in l ? Wn(l, s, { enumerable: true, configurable: true, writable: true, value: t }) : l[s] = t;
var I = (l, s, t) => (Xn(l, typeof s != "symbol" ? s + "" : s, t), t);
var Mn = 0;
var so = 1;
var io = 2;
var bi = 2;
var Ys = 1.25;
var vi = 1;
var Ts = 6 * 4 + 4 + 4;
var Us = 65535;
var no = Math.pow(2, -24);
var Vs = Symbol("SKIP_GENERATION");
function oo(l) {
  return l.index ? l.index.count : l.attributes.position.count;
}
function Ce(l) {
  return oo(l) / 3;
}
function ro(l, s = ArrayBuffer) {
  return l > 65535 ? new Uint32Array(new s(4 * l)) : new Uint16Array(new s(2 * l));
}
function ao(l, s) {
  if (!l.index) {
    const t = l.attributes.position.count, e = s.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, i = ro(t, e);
    l.setIndex(new BufferAttribute(i, 1));
    for (let o = 0; o < t; o++)
      i[o] = o;
  }
}
function Dn(l) {
  const s = Ce(l), t = l.drawRange, e = t.start / 3, i = (t.start + t.count) / 3, o = Math.max(0, e), n = Math.min(s, i) - o;
  return [{
    offset: Math.floor(o),
    count: Math.floor(n)
  }];
}
function Un(l) {
  if (!l.groups || !l.groups.length)
    return Dn(l);
  const s = [], t = /* @__PURE__ */ new Set(), e = l.drawRange, i = e.start / 3, o = (e.start + e.count) / 3;
  for (const r of l.groups) {
    const a = r.start / 3, c = (r.start + r.count) / 3;
    t.add(Math.max(i, a)), t.add(Math.min(o, c));
  }
  const n = Array.from(t.values()).sort((r, a) => r - a);
  for (let r = 0; r < n.length - 1; r++) {
    const a = n[r], c = n[r + 1];
    s.push({
      offset: Math.floor(a),
      count: Math.floor(c - a)
    });
  }
  return s;
}
function co(l) {
  if (l.groups.length === 0)
    return false;
  const s = Ce(l), t = Un(l).sort((o, n) => o.offset - n.offset), e = t[t.length - 1];
  e.count = Math.min(s - e.offset, e.count);
  let i = 0;
  return t.forEach(({ count: o }) => i += o), s !== i;
}
function $(l, s, t) {
  return t.min.x = s[l], t.min.y = s[l + 1], t.min.z = s[l + 2], t.max.x = s[l + 3], t.max.y = s[l + 4], t.max.z = s[l + 5], t;
}
function lo(l) {
  l[0] = l[1] = l[2] = 1 / 0, l[3] = l[4] = l[5] = -1 / 0;
}
function Bi(l) {
  let s = -1, t = -1 / 0;
  for (let e = 0; e < 3; e++) {
    const i = l[e + 3] - l[e];
    i > t && (t = i, s = e);
  }
  return s;
}
function Yi(l, s) {
  s.set(l);
}
function Vi(l, s, t) {
  let e, i;
  for (let o = 0; o < 3; o++) {
    const n = o + 3;
    e = l[o], i = s[o], t[o] = e < i ? e : i, e = l[n], i = s[n], t[n] = e > i ? e : i;
  }
}
function je(l, s, t) {
  for (let e = 0; e < 3; e++) {
    const i = s[l + 2 * e], o = s[l + 2 * e + 1], n = i - o, r = i + o;
    n < t[e] && (t[e] = n), r > t[e + 3] && (t[e + 3] = r);
  }
}
function Ae(l) {
  const s = l[3] - l[0], t = l[4] - l[1], e = l[5] - l[2];
  return 2 * (s * t + t * e + e * s);
}
function Gs(l, s, t, e, i = null) {
  let o = 1 / 0, n = 1 / 0, r = 1 / 0, a = -1 / 0, c = -1 / 0, h = -1 / 0, d = 1 / 0, E = 1 / 0, u = 1 / 0, p = -1 / 0, A = -1 / 0, m = -1 / 0;
  const C = i !== null;
  for (let R = s * 6, F = (s + t) * 6; R < F; R += 6) {
    const f = l[R + 0], T = l[R + 1], O = f - T, S = f + T;
    O < o && (o = O), S > a && (a = S), C && f < d && (d = f), C && f > p && (p = f);
    const _ = l[R + 2], N = l[R + 3], L = _ - N, M = _ + N;
    L < n && (n = L), M > c && (c = M), C && _ < E && (E = _), C && _ > A && (A = _);
    const y = l[R + 4], x = l[R + 5], b = y - x, B = y + x;
    b < r && (r = b), B > h && (h = B), C && y < u && (u = y), C && y > m && (m = y);
  }
  e[0] = o, e[1] = n, e[2] = r, e[3] = a, e[4] = c, e[5] = h, C && (i[0] = d, i[1] = E, i[2] = u, i[3] = p, i[4] = A, i[5] = m);
}
function ho(l, s, t, e) {
  let i = 1 / 0, o = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, c = -1 / 0;
  for (let h = s * 6, d = (s + t) * 6; h < d; h += 6) {
    const E = l[h + 0];
    E < i && (i = E), E > r && (r = E);
    const u = l[h + 2];
    u < o && (o = u), u > a && (a = u);
    const p = l[h + 4];
    p < n && (n = p), p > c && (c = p);
  }
  e[0] = i, e[1] = o, e[2] = n, e[3] = r, e[4] = a, e[5] = c;
}
function Eo(l, s) {
  lo(s);
  const t = l.attributes.position, e = l.index ? l.index.array : null, i = Ce(l), o = new Float32Array(i * 6), n = t.normalized, r = t.array, a = t.offset || 0;
  let c = 3;
  t.isInterleavedBufferAttribute && (c = t.data.stride);
  const h = ["getX", "getY", "getZ"];
  for (let d = 0; d < i; d++) {
    const E = d * 3, u = d * 6;
    let p = E + 0, A = E + 1, m = E + 2;
    e && (p = e[p], A = e[A], m = e[m]), n || (p = p * c + a, A = A * c + a, m = m * c + a);
    for (let C = 0; C < 3; C++) {
      let R, F, f;
      n ? (R = t[h[C]](p), F = t[h[C]](A), f = t[h[C]](m)) : (R = r[p + C], F = r[A + C], f = r[m + C]);
      let T = R;
      F < T && (T = F), f < T && (T = f);
      let O = R;
      F > O && (O = F), f > O && (O = f);
      const S = (O - T) / 2, _ = C * 2;
      o[u + _ + 0] = T + S, o[u + _ + 1] = S + (Math.abs(T) + S) * no, T < s[C] && (s[C] = T), O > s[C + 3] && (s[C + 3] = O);
    }
  }
  return o;
}
var wt = 32;
var uo = (l, s) => l.candidate - s.candidate;
var Ut = new Array(wt).fill().map(() => ({
  count: 0,
  bounds: new Float32Array(6),
  rightCacheBounds: new Float32Array(6),
  leftCacheBounds: new Float32Array(6),
  candidate: 0
}));
var qe = new Float32Array(6);
function Io(l, s, t, e, i, o) {
  let n = -1, r = 0;
  if (o === Mn)
    n = Bi(s), n !== -1 && (r = (s[n] + s[n + 3]) / 2);
  else if (o === so)
    n = Bi(l), n !== -1 && (r = fo(t, e, i, n));
  else if (o === io) {
    const a = Ae(l);
    let c = Ys * i;
    const h = e * 6, d = (e + i) * 6;
    for (let E = 0; E < 3; E++) {
      const u = s[E], m = (s[E + 3] - u) / wt;
      if (i < wt / 4) {
        const C = [...Ut];
        C.length = i;
        let R = 0;
        for (let f = h; f < d; f += 6, R++) {
          const T = C[R];
          T.candidate = t[f + 2 * E], T.count = 0;
          const {
            bounds: O,
            leftCacheBounds: S,
            rightCacheBounds: _
          } = T;
          for (let N = 0; N < 3; N++)
            _[N] = 1 / 0, _[N + 3] = -1 / 0, S[N] = 1 / 0, S[N + 3] = -1 / 0, O[N] = 1 / 0, O[N + 3] = -1 / 0;
          je(f, t, O);
        }
        C.sort(uo);
        let F = i;
        for (let f = 0; f < F; f++) {
          const T = C[f];
          for (; f + 1 < F && C[f + 1].candidate === T.candidate; )
            C.splice(f + 1, 1), F--;
        }
        for (let f = h; f < d; f += 6) {
          const T = t[f + 2 * E];
          for (let O = 0; O < F; O++) {
            const S = C[O];
            T >= S.candidate ? je(f, t, S.rightCacheBounds) : (je(f, t, S.leftCacheBounds), S.count++);
          }
        }
        for (let f = 0; f < F; f++) {
          const T = C[f], O = T.count, S = i - T.count, _ = T.leftCacheBounds, N = T.rightCacheBounds;
          let L = 0;
          O !== 0 && (L = Ae(_) / a);
          let M = 0;
          S !== 0 && (M = Ae(N) / a);
          const y = vi + Ys * (L * O + M * S);
          y < c && (n = E, c = y, r = T.candidate);
        }
      } else {
        for (let F = 0; F < wt; F++) {
          const f = Ut[F];
          f.count = 0, f.candidate = u + m + F * m;
          const T = f.bounds;
          for (let O = 0; O < 3; O++)
            T[O] = 1 / 0, T[O + 3] = -1 / 0;
        }
        for (let F = h; F < d; F += 6) {
          let O = ~~((t[F + 2 * E] - u) / m);
          O >= wt && (O = wt - 1);
          const S = Ut[O];
          S.count++, je(F, t, S.bounds);
        }
        const C = Ut[wt - 1];
        Yi(C.bounds, C.rightCacheBounds);
        for (let F = wt - 2; F >= 0; F--) {
          const f = Ut[F], T = Ut[F + 1];
          Vi(f.bounds, T.rightCacheBounds, f.rightCacheBounds);
        }
        let R = 0;
        for (let F = 0; F < wt - 1; F++) {
          const f = Ut[F], T = f.count, O = f.bounds, _ = Ut[F + 1].rightCacheBounds;
          T !== 0 && (R === 0 ? Yi(O, qe) : Vi(O, qe, qe)), R += T;
          let N = 0, L = 0;
          R !== 0 && (N = Ae(qe) / a);
          const M = i - R;
          M !== 0 && (L = Ae(_) / a);
          const y = vi + Ys * (N * R + L * M);
          y < c && (n = E, c = y, r = f.candidate);
        }
      }
    }
  } else
    console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);
  return { axis: n, pos: r };
}
function fo(l, s, t, e) {
  let i = 0;
  for (let o = s, n = s + t; o < n; o++)
    i += l[o * 6 + e * 2];
  return i / t;
}
var $e = class {
  constructor() {
  }
};
function po(l, s, t, e, i, o) {
  let n = e, r = e + i - 1;
  const a = o.pos, c = o.axis * 2;
  for (; ; ) {
    for (; n <= r && t[n * 6 + c] < a; )
      n++;
    for (; n <= r && t[r * 6 + c] >= a; )
      r--;
    if (n < r) {
      for (let h = 0; h < 3; h++) {
        let d = s[n * 3 + h];
        s[n * 3 + h] = s[r * 3 + h], s[r * 3 + h] = d;
      }
      for (let h = 0; h < 6; h++) {
        let d = t[n * 6 + h];
        t[n * 6 + h] = t[r * 6 + h], t[r * 6 + h] = d;
      }
      n++, r--;
    } else
      return n;
  }
}
function Co(l, s, t, e, i, o) {
  let n = e, r = e + i - 1;
  const a = o.pos, c = o.axis * 2;
  for (; ; ) {
    for (; n <= r && t[n * 6 + c] < a; )
      n++;
    for (; n <= r && t[r * 6 + c] >= a; )
      r--;
    if (n < r) {
      let h = l[n];
      l[n] = l[r], l[r] = h;
      for (let d = 0; d < 6; d++) {
        let E = t[n * 6 + d];
        t[n * 6 + d] = t[r * 6 + d], t[r * 6 + d] = E;
      }
      n++, r--;
    } else
      return n;
  }
}
function To(l, s) {
  const t = (l.index ? l.index.count : l.attributes.position.count) / 3, e = t > 2 ** 16, i = e ? 4 : 2, o = s ? new SharedArrayBuffer(t * i) : new ArrayBuffer(t * i), n = e ? new Uint32Array(o) : new Uint16Array(o);
  for (let r = 0, a = n.length; r < a; r++)
    n[r] = r;
  return n;
}
function mo(l, s) {
  const t = l.geometry, e = t.index ? t.index.array : null, i = s.maxDepth, o = s.verbose, n = s.maxLeafTris, r = s.strategy, a = s.onProgress, c = Ce(t), h = l._indirectBuffer;
  let d = false;
  const E = new Float32Array(6), u = new Float32Array(6), p = Eo(t, E), A = s.indirect ? Co : po, m = [], C = s.indirect ? Dn(t) : Un(t);
  if (C.length === 1) {
    const f = C[0], T = new $e();
    T.boundingData = E, ho(p, f.offset, f.count, u), F(T, f.offset, f.count, u), m.push(T);
  } else
    for (let f of C) {
      const T = new $e();
      T.boundingData = new Float32Array(6), Gs(p, f.offset, f.count, T.boundingData, u), F(T, f.offset, f.count, u), m.push(T);
    }
  return m;
  function R(f) {
    a && a(f / c);
  }
  function F(f, T, O, S = null, _ = 0) {
    if (!d && _ >= i && (d = true, o && (console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`), console.warn(t))), O <= n || _ >= i)
      return R(T + O), f.offset = T, f.count = O, f;
    const N = Io(f.boundingData, S, p, T, O, r);
    if (N.axis === -1)
      return R(T + O), f.offset = T, f.count = O, f;
    const L = A(h, e, p, T, O, N);
    if (L === T || L === T + O)
      R(T + O), f.offset = T, f.count = O;
    else {
      f.splitAxis = N.axis;
      const M = new $e(), y = T, x = L - T;
      f.left = M, M.boundingData = new Float32Array(6), Gs(p, y, x, M.boundingData, u), F(M, y, x, u, _ + 1);
      const b = new $e(), B = L, H = O - x;
      f.right = b, b.boundingData = new Float32Array(6), Gs(p, B, H, b.boundingData, u), F(b, B, H, u, _ + 1);
    }
    return f;
  }
}
function Ro(l, s) {
  const t = l.geometry;
  s.indirect && (l._indirectBuffer = To(t, s.useSharedArrayBuffer), co(t) && !s.verbose && console.warn(
    'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
  )), l._indirectBuffer || ao(t, s);
  const e = mo(l, s);
  let i, o, n;
  const r = [], a = s.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  for (let d = 0; d < e.length; d++) {
    const E = e[d];
    let u = c(E);
    const p = new a(Ts * u);
    i = new Float32Array(p), o = new Uint32Array(p), n = new Uint16Array(p), h(0, E), r.push(p);
  }
  l._roots = r;
  return;
  function c(d) {
    return d.count ? 1 : 1 + c(d.left) + c(d.right);
  }
  function h(d, E) {
    const u = d / 4, p = d / 2, A = !!E.count, m = E.boundingData;
    for (let C = 0; C < 6; C++)
      i[u + C] = m[C];
    if (A) {
      const C = E.offset, R = E.count;
      return o[u + 6] = C, n[p + 14] = R, n[p + 15] = Us, d + Ts;
    } else {
      const C = E.left, R = E.right, F = E.splitAxis;
      let f;
      if (f = h(d + Ts, C), f / 4 > Math.pow(2, 32))
        throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
      return o[u + 6] = f / 4, f = h(f, R), o[u + 7] = F, f;
    }
  }
}
var Mt = class {
  constructor() {
    this.min = 1 / 0, this.max = -1 / 0;
  }
  setFromPointsField(s, t) {
    let e = 1 / 0, i = -1 / 0;
    for (let o = 0, n = s.length; o < n; o++) {
      const a = s[o][t];
      e = a < e ? a : e, i = a > i ? a : i;
    }
    this.min = e, this.max = i;
  }
  setFromPoints(s, t) {
    let e = 1 / 0, i = -1 / 0;
    for (let o = 0, n = t.length; o < n; o++) {
      const r = t[o], a = s.dot(r);
      e = a < e ? a : e, i = a > i ? a : i;
    }
    this.min = e, this.max = i;
  }
  isSeparated(s) {
    return this.min > s.max || s.min > this.max;
  }
};
Mt.prototype.setFromBox = function() {
  const l = new Vector3();
  return function(t, e) {
    const i = e.min, o = e.max;
    let n = 1 / 0, r = -1 / 0;
    for (let a = 0; a <= 1; a++)
      for (let c = 0; c <= 1; c++)
        for (let h = 0; h <= 1; h++) {
          l.x = i.x * a + o.x * (1 - a), l.y = i.y * c + o.y * (1 - c), l.z = i.z * h + o.z * (1 - h);
          const d = t.dot(l);
          n = Math.min(d, n), r = Math.max(d, r);
        }
    this.min = n, this.max = r;
  };
}();
var Ao = function() {
  const l = new Vector3(), s = new Vector3(), t = new Vector3();
  return function(i, o, n) {
    const r = i.start, a = l, c = o.start, h = s;
    t.subVectors(r, c), l.subVectors(i.end, i.start), s.subVectors(o.end, o.start);
    const d = t.dot(h), E = h.dot(a), u = h.dot(h), p = t.dot(a), m = a.dot(a) * u - E * E;
    let C, R;
    m !== 0 ? C = (d * E - p * u) / m : C = 0, R = (d + C * E) / u, n.x = C, n.y = R;
  };
}();
var Oi = function() {
  const l = new Vector2(), s = new Vector3(), t = new Vector3();
  return function(i, o, n, r) {
    Ao(i, o, l);
    let a = l.x, c = l.y;
    if (a >= 0 && a <= 1 && c >= 0 && c <= 1) {
      i.at(a, n), o.at(c, r);
      return;
    } else if (a >= 0 && a <= 1) {
      c < 0 ? o.at(0, r) : o.at(1, r), i.closestPointToPoint(r, true, n);
      return;
    } else if (c >= 0 && c <= 1) {
      a < 0 ? i.at(0, n) : i.at(1, n), o.closestPointToPoint(n, true, r);
      return;
    } else {
      let h;
      a < 0 ? h = i.start : h = i.end;
      let d;
      c < 0 ? d = o.start : d = o.end;
      const E = s, u = t;
      if (i.closestPointToPoint(d, true, s), o.closestPointToPoint(h, true, t), E.distanceToSquared(d) <= u.distanceToSquared(h)) {
        n.copy(E), r.copy(d);
        return;
      } else {
        n.copy(h), r.copy(u);
        return;
      }
    }
  };
}();
var Fo = function() {
  const l = new Vector3(), s = new Vector3(), t = new Plane(), e = new Line3();
  return function(o, n) {
    const { radius: r, center: a } = o, { a: c, b: h, c: d } = n;
    if (e.start = c, e.end = h, e.closestPointToPoint(a, true, l).distanceTo(a) <= r || (e.start = c, e.end = d, e.closestPointToPoint(a, true, l).distanceTo(a) <= r) || (e.start = h, e.end = d, e.closestPointToPoint(a, true, l).distanceTo(a) <= r))
      return true;
    const A = n.getPlane(t);
    if (Math.abs(A.distanceToPoint(a)) <= r) {
      const C = A.projectPoint(a, s);
      if (n.containsPoint(C))
        return true;
    }
    return false;
  };
}();
var Oo = 1e-15;
function zs(l) {
  return Math.abs(l) < Oo;
}
var Ft = class extends Triangle {
  constructor(...s) {
    super(...s), this.isExtendedTriangle = true, this.satAxes = new Array(4).fill().map(() => new Vector3()), this.satBounds = new Array(4).fill().map(() => new Mt()), this.points = [this.a, this.b, this.c], this.sphere = new Sphere(), this.plane = new Plane(), this.needsUpdate = true;
  }
  intersectsSphere(s) {
    return Fo(s, this);
  }
  update() {
    const s = this.a, t = this.b, e = this.c, i = this.points, o = this.satAxes, n = this.satBounds, r = o[0], a = n[0];
    this.getNormal(r), a.setFromPoints(r, i);
    const c = o[1], h = n[1];
    c.subVectors(s, t), h.setFromPoints(c, i);
    const d = o[2], E = n[2];
    d.subVectors(t, e), E.setFromPoints(d, i);
    const u = o[3], p = n[3];
    u.subVectors(e, s), p.setFromPoints(u, i), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(r, s), this.needsUpdate = false;
  }
};
Ft.prototype.closestPointToSegment = function() {
  const l = new Vector3(), s = new Vector3(), t = new Line3();
  return function(i, o = null, n = null) {
    const { start: r, end: a } = i, c = this.points;
    let h, d = 1 / 0;
    for (let E = 0; E < 3; E++) {
      const u = (E + 1) % 3;
      t.start.copy(c[E]), t.end.copy(c[u]), Oi(t, i, l, s), h = l.distanceToSquared(s), h < d && (d = h, o && o.copy(l), n && n.copy(s));
    }
    return this.closestPointToPoint(r, l), h = r.distanceToSquared(l), h < d && (d = h, o && o.copy(l), n && n.copy(r)), this.closestPointToPoint(a, l), h = a.distanceToSquared(l), h < d && (d = h, o && o.copy(l), n && n.copy(a)), Math.sqrt(d);
  };
}();
Ft.prototype.intersectsTriangle = function() {
  const l = new Ft(), s = new Array(3), t = new Array(3), e = new Mt(), i = new Mt(), o = new Vector3(), n = new Vector3(), r = new Vector3(), a = new Vector3(), c = new Vector3(), h = new Line3(), d = new Line3(), E = new Line3(), u = new Vector3();
  function p(A, m, C) {
    const R = A.points;
    let F = 0, f = -1;
    for (let T = 0; T < 3; T++) {
      const { start: O, end: S } = h;
      O.copy(R[T]), S.copy(R[(T + 1) % 3]), h.delta(n);
      const _ = zs(m.distanceToPoint(O));
      if (zs(m.normal.dot(n)) && _) {
        C.copy(h), F = 2;
        break;
      }
      const N = m.intersectLine(h, u);
      if (!N && _ && u.copy(O), (N || _) && !zs(u.distanceTo(S))) {
        if (F <= 1)
          (F === 1 ? C.start : C.end).copy(u), _ && (f = F);
        else if (F >= 2) {
          (f === 1 ? C.start : C.end).copy(u), F = 2;
          break;
        }
        if (F++, F === 2 && f === -1)
          break;
      }
    }
    return F;
  }
  return function(m, C = null, R = false) {
    this.needsUpdate && this.update(), m.isExtendedTriangle ? m.needsUpdate && m.update() : (l.copy(m), l.update(), m = l);
    const F = this.plane, f = m.plane;
    if (Math.abs(F.normal.dot(f.normal)) > 1 - 1e-10) {
      const T = this.satBounds, O = this.satAxes;
      t[0] = m.a, t[1] = m.b, t[2] = m.c;
      for (let N = 0; N < 4; N++) {
        const L = T[N], M = O[N];
        if (e.setFromPoints(M, t), L.isSeparated(e))
          return false;
      }
      const S = m.satBounds, _ = m.satAxes;
      s[0] = this.a, s[1] = this.b, s[2] = this.c;
      for (let N = 0; N < 4; N++) {
        const L = S[N], M = _[N];
        if (e.setFromPoints(M, s), L.isSeparated(e))
          return false;
      }
      for (let N = 0; N < 4; N++) {
        const L = O[N];
        for (let M = 0; M < 4; M++) {
          const y = _[M];
          if (o.crossVectors(L, y), e.setFromPoints(o, s), i.setFromPoints(o, t), e.isSeparated(i))
            return false;
        }
      }
      return C && (R || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), C.start.set(0, 0, 0), C.end.set(0, 0, 0)), true;
    } else {
      const T = p(this, f, d);
      if (T === 1 && m.containsPoint(d.end))
        return C && (C.start.copy(d.end), C.end.copy(d.end)), true;
      if (T !== 2)
        return false;
      const O = p(m, F, E);
      if (O === 1 && this.containsPoint(E.end))
        return C && (C.start.copy(E.end), C.end.copy(E.end)), true;
      if (O !== 2)
        return false;
      if (d.delta(r), E.delta(a), r.dot(a) < 0) {
        let x = E.start;
        E.start = E.end, E.end = x;
      }
      const S = d.start.dot(r), _ = d.end.dot(r), N = E.start.dot(r), L = E.end.dot(r), M = _ < N, y = S < L;
      return S !== L && N !== _ && M === y ? false : (C && (c.subVectors(d.start, E.start), c.dot(r) > 0 ? C.start.copy(d.start) : C.start.copy(E.start), c.subVectors(d.end, E.end), c.dot(r) < 0 ? C.end.copy(d.end) : C.end.copy(E.end)), true);
    }
  };
}();
Ft.prototype.distanceToPoint = function() {
  const l = new Vector3();
  return function(t) {
    return this.closestPointToPoint(t, l), t.distanceTo(l);
  };
}();
Ft.prototype.distanceToTriangle = function() {
  const l = new Vector3(), s = new Vector3(), t = ["a", "b", "c"], e = new Line3(), i = new Line3();
  return function(n, r = null, a = null) {
    const c = r || a ? e : null;
    if (this.intersectsTriangle(n, c))
      return (r || a) && (r && c.getCenter(r), a && c.getCenter(a)), 0;
    let h = 1 / 0;
    for (let d = 0; d < 3; d++) {
      let E;
      const u = t[d], p = n[u];
      this.closestPointToPoint(p, l), E = p.distanceToSquared(l), E < h && (h = E, r && r.copy(l), a && a.copy(p));
      const A = this[u];
      n.closestPointToPoint(A, l), E = A.distanceToSquared(l), E < h && (h = E, r && r.copy(A), a && a.copy(l));
    }
    for (let d = 0; d < 3; d++) {
      const E = t[d], u = t[(d + 1) % 3];
      e.set(this[E], this[u]);
      for (let p = 0; p < 3; p++) {
        const A = t[p], m = t[(p + 1) % 3];
        i.set(n[A], n[m]), Oi(e, i, l, s);
        const C = l.distanceToSquared(s);
        C < h && (h = C, r && r.copy(l), a && a.copy(s));
      }
    }
    return Math.sqrt(h);
  };
}();
var at = class {
  constructor(s, t, e) {
    this.isOrientedBox = true, this.min = new Vector3(), this.max = new Vector3(), this.matrix = new Matrix4(), this.invMatrix = new Matrix4(), this.points = new Array(8).fill().map(() => new Vector3()), this.satAxes = new Array(3).fill().map(() => new Vector3()), this.satBounds = new Array(3).fill().map(() => new Mt()), this.alignedSatBounds = new Array(3).fill().map(() => new Mt()), this.needsUpdate = false, s && this.min.copy(s), t && this.max.copy(t), e && this.matrix.copy(e);
  }
  set(s, t, e) {
    this.min.copy(s), this.max.copy(t), this.matrix.copy(e), this.needsUpdate = true;
  }
  copy(s) {
    this.min.copy(s.min), this.max.copy(s.max), this.matrix.copy(s.matrix), this.needsUpdate = true;
  }
};
at.prototype.update = /* @__PURE__ */ function() {
  return function() {
    const s = this.matrix, t = this.min, e = this.max, i = this.points;
    for (let c = 0; c <= 1; c++)
      for (let h = 0; h <= 1; h++)
        for (let d = 0; d <= 1; d++) {
          const E = 1 * c | 2 * h | 4 * d, u = i[E];
          u.x = c ? e.x : t.x, u.y = h ? e.y : t.y, u.z = d ? e.z : t.z, u.applyMatrix4(s);
        }
    const o = this.satBounds, n = this.satAxes, r = i[0];
    for (let c = 0; c < 3; c++) {
      const h = n[c], d = o[c], E = 1 << c, u = i[E];
      h.subVectors(r, u), d.setFromPoints(h, i);
    }
    const a = this.alignedSatBounds;
    a[0].setFromPointsField(i, "x"), a[1].setFromPointsField(i, "y"), a[2].setFromPointsField(i, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = false;
  };
}();
at.prototype.intersectsBox = function() {
  const l = new Mt();
  return function(t) {
    this.needsUpdate && this.update();
    const e = t.min, i = t.max, o = this.satBounds, n = this.satAxes, r = this.alignedSatBounds;
    if (l.min = e.x, l.max = i.x, r[0].isSeparated(l) || (l.min = e.y, l.max = i.y, r[1].isSeparated(l)) || (l.min = e.z, l.max = i.z, r[2].isSeparated(l)))
      return false;
    for (let a = 0; a < 3; a++) {
      const c = n[a], h = o[a];
      if (l.setFromBox(c, t), h.isSeparated(l))
        return false;
    }
    return true;
  };
}();
at.prototype.intersectsTriangle = function() {
  const l = new Ft(), s = new Array(3), t = new Mt(), e = new Mt(), i = new Vector3();
  return function(n) {
    this.needsUpdate && this.update(), n.isExtendedTriangle ? n.needsUpdate && n.update() : (l.copy(n), l.update(), n = l);
    const r = this.satBounds, a = this.satAxes;
    s[0] = n.a, s[1] = n.b, s[2] = n.c;
    for (let E = 0; E < 3; E++) {
      const u = r[E], p = a[E];
      if (t.setFromPoints(p, s), u.isSeparated(t))
        return false;
    }
    const c = n.satBounds, h = n.satAxes, d = this.points;
    for (let E = 0; E < 3; E++) {
      const u = c[E], p = h[E];
      if (t.setFromPoints(p, d), u.isSeparated(t))
        return false;
    }
    for (let E = 0; E < 3; E++) {
      const u = a[E];
      for (let p = 0; p < 4; p++) {
        const A = h[p];
        if (i.crossVectors(u, A), t.setFromPoints(i, s), e.setFromPoints(i, d), t.isSeparated(e))
          return false;
      }
    }
    return true;
  };
}();
at.prototype.closestPointToPoint = /* @__PURE__ */ function() {
  return function(s, t) {
    return this.needsUpdate && this.update(), t.copy(s).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), t;
  };
}();
at.prototype.distanceToPoint = function() {
  const l = new Vector3();
  return function(t) {
    return this.closestPointToPoint(t, l), t.distanceTo(l);
  };
}();
at.prototype.distanceToBox = function() {
  const l = ["x", "y", "z"], s = new Array(12).fill().map(() => new Line3()), t = new Array(12).fill().map(() => new Line3()), e = new Vector3(), i = new Vector3();
  return function(n, r = 0, a = null, c = null) {
    if (this.needsUpdate && this.update(), this.intersectsBox(n))
      return (a || c) && (n.getCenter(i), this.closestPointToPoint(i, e), n.closestPointToPoint(e, i), a && a.copy(e), c && c.copy(i)), 0;
    const h = r * r, d = n.min, E = n.max, u = this.points;
    let p = 1 / 0;
    for (let m = 0; m < 8; m++) {
      const C = u[m];
      i.copy(C).clamp(d, E);
      const R = C.distanceToSquared(i);
      if (R < p && (p = R, a && a.copy(C), c && c.copy(i), R < h))
        return Math.sqrt(R);
    }
    let A = 0;
    for (let m = 0; m < 3; m++)
      for (let C = 0; C <= 1; C++)
        for (let R = 0; R <= 1; R++) {
          const F = (m + 1) % 3, f = (m + 2) % 3, T = C << F | R << f, O = 1 << m | C << F | R << f, S = u[T], _ = u[O];
          s[A].set(S, _);
          const L = l[m], M = l[F], y = l[f], x = t[A], b = x.start, B = x.end;
          b[L] = d[L], b[M] = C ? d[M] : E[M], b[y] = R ? d[y] : E[M], B[L] = E[L], B[M] = C ? d[M] : E[M], B[y] = R ? d[y] : E[M], A++;
        }
    for (let m = 0; m <= 1; m++)
      for (let C = 0; C <= 1; C++)
        for (let R = 0; R <= 1; R++) {
          i.x = m ? E.x : d.x, i.y = C ? E.y : d.y, i.z = R ? E.z : d.z, this.closestPointToPoint(i, e);
          const F = i.distanceToSquared(e);
          if (F < p && (p = F, a && a.copy(e), c && c.copy(i), F < h))
            return Math.sqrt(F);
        }
    for (let m = 0; m < 12; m++) {
      const C = s[m];
      for (let R = 0; R < 12; R++) {
        const F = t[R];
        Oi(C, F, e, i);
        const f = e.distanceToSquared(i);
        if (f < p && (p = f, a && a.copy(e), c && c.copy(i), f < h))
          return Math.sqrt(f);
      }
    }
    return Math.sqrt(p);
  };
}();
var gi = class {
  constructor(s) {
    this._getNewPrimitive = s, this._primitives = [];
  }
  getPrimitive() {
    const s = this._primitives;
    return s.length === 0 ? this._getNewPrimitive() : s.pop();
  }
  releasePrimitive(s) {
    this._primitives.push(s);
  }
};
var go = class extends gi {
  constructor() {
    super(() => new Ft());
  }
};
var It = new go();
function ht(l, s) {
  return s[l + 15] === 65535;
}
function Et(l, s) {
  return s[l + 6];
}
function ft(l, s) {
  return s[l + 14];
}
function pt(l) {
  return l + 8;
}
function Ct(l, s) {
  return s[l + 6];
}
function xn(l, s) {
  return s[l + 7];
}
var So = class {
  constructor() {
    this.float32Array = null, this.uint16Array = null, this.uint32Array = null;
    const s = [];
    let t = null;
    this.setBuffer = (e) => {
      t && s.push(t), t = e, this.float32Array = new Float32Array(e), this.uint16Array = new Uint16Array(e), this.uint32Array = new Uint32Array(e);
    }, this.clearBuffer = () => {
      t = null, this.float32Array = null, this.uint16Array = null, this.uint32Array = null, s.length !== 0 && this.setBuffer(s.pop());
    };
  }
};
var Z = new So();
var Yt;
var fe;
var te = [];
var Ke = new gi(() => new Box3());
function _o(l, s, t, e, i, o) {
  Yt = Ke.getPrimitive(), fe = Ke.getPrimitive(), te.push(Yt, fe), Z.setBuffer(l._roots[s]);
  const n = ai(0, l.geometry, t, e, i, o);
  Z.clearBuffer(), Ke.releasePrimitive(Yt), Ke.releasePrimitive(fe), te.pop(), te.pop();
  const r = te.length;
  return r > 0 && (fe = te[r - 1], Yt = te[r - 2]), n;
}
function ai(l, s, t, e, i = null, o = 0, n = 0) {
  const { float32Array: r, uint16Array: a, uint32Array: c } = Z;
  let h = l * 2;
  if (ht(h, a)) {
    const E = Et(l, c), u = ft(h, a);
    return $(l, r, Yt), e(E, u, false, n, o + l, Yt);
  } else {
    let L = function(y) {
      const { uint16Array: x, uint32Array: b } = Z;
      let B = y * 2;
      for (; !ht(B, x); )
        y = pt(y), B = y * 2;
      return Et(y, b);
    }, M = function(y) {
      const { uint16Array: x, uint32Array: b } = Z;
      let B = y * 2;
      for (; !ht(B, x); )
        y = Ct(y, b), B = y * 2;
      return Et(y, b) + ft(B, x);
    };
    const E = pt(l), u = Ct(l, c);
    let p = E, A = u, m, C, R, F;
    if (i && (R = Yt, F = fe, $(p, r, R), $(A, r, F), m = i(R), C = i(F), C < m)) {
      p = u, A = E;
      const y = m;
      m = C, C = y, R = F;
    }
    R || (R = Yt, $(p, r, R));
    const f = ht(p * 2, a), T = t(R, f, m, n + 1, o + p);
    let O;
    if (T === bi) {
      const y = L(p), b = M(p) - y;
      O = e(y, b, true, n + 1, o + p, R);
    } else
      O = T && ai(
        p,
        s,
        t,
        e,
        i,
        o,
        n + 1
      );
    if (O)
      return true;
    F = fe, $(A, r, F);
    const S = ht(A * 2, a), _ = t(F, S, C, n + 1, o + A);
    let N;
    if (_ === bi) {
      const y = L(A), b = M(A) - y;
      N = e(y, b, true, n + 1, o + A, F);
    } else
      N = _ && ai(
        A,
        s,
        t,
        e,
        i,
        o,
        n + 1
      );
    return !!N;
  }
}
var Fe = new Vector3();
var Hs = new Vector3();
function No(l, s, t = {}, e = 0, i = 1 / 0) {
  const o = e * e, n = i * i;
  let r = 1 / 0, a = null;
  if (l.shapecast(
    {
      boundsTraverseOrder: (h) => (Fe.copy(s).clamp(h.min, h.max), Fe.distanceToSquared(s)),
      intersectsBounds: (h, d, E) => E < r && E < n,
      intersectsTriangle: (h, d) => {
        h.closestPointToPoint(s, Fe);
        const E = s.distanceToSquared(Fe);
        return E < r && (Hs.copy(Fe), r = E, a = d), E < o;
      }
    }
  ), r === 1 / 0)
    return null;
  const c = Math.sqrt(r);
  return t.point ? t.point.copy(Hs) : t.point = Hs.clone(), t.distance = c, t.faceIndex = a, t;
}
var ee = new Vector3();
var se = new Vector3();
var ie = new Vector3();
var Je = new Vector2();
var ts = new Vector2();
var es = new Vector2();
var Gi2 = new Vector3();
var zi = new Vector3();
var Hi2 = new Vector3();
var ss = new Vector3();
function Po(l, s, t, e, i, o) {
  let n;
  return o === BackSide ? n = l.intersectTriangle(e, t, s, true, i) : n = l.intersectTriangle(s, t, e, o !== DoubleSide, i), n === null ? null : {
    distance: l.origin.distanceTo(i),
    point: i.clone()
  };
}
function Lo(l, s, t, e, i, o, n, r, a) {
  ee.fromBufferAttribute(s, o), se.fromBufferAttribute(s, n), ie.fromBufferAttribute(s, r);
  const c = Po(l, ee, se, ie, ss, a);
  if (c) {
    e && (Je.fromBufferAttribute(e, o), ts.fromBufferAttribute(e, n), es.fromBufferAttribute(e, r), c.uv = Triangle.getInterpolation(ss, ee, se, ie, Je, ts, es, new Vector2())), i && (Je.fromBufferAttribute(i, o), ts.fromBufferAttribute(i, n), es.fromBufferAttribute(i, r), c.uv1 = Triangle.getInterpolation(ss, ee, se, ie, Je, ts, es, new Vector2())), t && (Gi2.fromBufferAttribute(t, o), zi.fromBufferAttribute(t, n), Hi2.fromBufferAttribute(t, r), c.normal = Triangle.getInterpolation(ss, ee, se, ie, Gi2, zi, Hi2, new Vector3()), c.normal.dot(l.direction) > 0 && c.normal.multiplyScalar(-1));
    const h = {
      a: o,
      b: n,
      c: r,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(ee, se, ie, h.normal), c.face = h, c.faceIndex = o;
  }
  return c;
}
function xs(l, s, t, e, i) {
  const o = e * 3;
  let n = o + 0, r = o + 1, a = o + 2;
  const c = l.index;
  l.index && (n = c.getX(n), r = c.getX(r), a = c.getX(a));
  const { position: h, normal: d, uv: E, uv1: u } = l.attributes, p = Lo(t, h, d, E, u, n, r, a, s);
  return p ? (p.faceIndex = e, i && i.push(p), p) : null;
}
function et(l, s, t, e) {
  const i = l.a, o = l.b, n = l.c;
  let r = s, a = s + 1, c = s + 2;
  t && (r = t.getX(r), a = t.getX(a), c = t.getX(c)), i.x = e.getX(r), i.y = e.getY(r), i.z = e.getZ(r), o.x = e.getX(a), o.y = e.getY(a), o.z = e.getZ(a), n.x = e.getX(c), n.y = e.getY(c), n.z = e.getZ(c);
}
function yo(l, s, t, e, i, o) {
  const { geometry: n, _indirectBuffer: r } = l;
  for (let a = e, c = e + i; a < c; a++)
    xs(n, s, t, a, o);
}
function wo(l, s, t, e, i) {
  const { geometry: o, _indirectBuffer: n } = l;
  let r = 1 / 0, a = null;
  for (let c = e, h = e + i; c < h; c++) {
    let d;
    d = xs(o, s, t, c), d && d.distance < r && (a = d, r = d.distance);
  }
  return a;
}
function Mo(l, s, t, e, i, o, n) {
  const { geometry: r } = t, { index: a } = r, c = r.attributes.position;
  for (let h = l, d = s + l; h < d; h++) {
    let E;
    if (E = h, et(n, E * 3, a, c), n.needsUpdate = true, e(n, E, i, o))
      return true;
  }
  return false;
}
function Do(l, s = null) {
  s && Array.isArray(s) && (s = new Set(s));
  const t = l.geometry, e = t.index ? t.index.array : null, i = t.attributes.position;
  let o, n, r, a, c = 0;
  const h = l._roots;
  for (let E = 0, u = h.length; E < u; E++)
    o = h[E], n = new Uint32Array(o), r = new Uint16Array(o), a = new Float32Array(o), d(0, c), c += o.byteLength;
  function d(E, u, p = false) {
    const A = E * 2;
    if (r[A + 15] === Us) {
      const C = n[E + 6], R = r[A + 14];
      let F = 1 / 0, f = 1 / 0, T = 1 / 0, O = -1 / 0, S = -1 / 0, _ = -1 / 0;
      for (let N = 3 * C, L = 3 * (C + R); N < L; N++) {
        let M = e[N];
        const y = i.getX(M), x = i.getY(M), b = i.getZ(M);
        y < F && (F = y), y > O && (O = y), x < f && (f = x), x > S && (S = x), b < T && (T = b), b > _ && (_ = b);
      }
      return a[E + 0] !== F || a[E + 1] !== f || a[E + 2] !== T || a[E + 3] !== O || a[E + 4] !== S || a[E + 5] !== _ ? (a[E + 0] = F, a[E + 1] = f, a[E + 2] = T, a[E + 3] = O, a[E + 4] = S, a[E + 5] = _, true) : false;
    } else {
      const C = E + 8, R = n[E + 6], F = C + u, f = R + u;
      let T = p, O = false, S = false;
      s ? T || (O = s.has(F), S = s.has(f), T = !O && !S) : (O = true, S = true);
      const _ = T || O, N = T || S;
      let L = false;
      _ && (L = d(C, u, T));
      let M = false;
      N && (M = d(R, u, T));
      const y = L || M;
      if (y)
        for (let x = 0; x < 3; x++) {
          const b = C + x, B = R + x, H = a[b], q = a[b + 3], st = a[B], Q = a[B + 3];
          a[E + x] = H < st ? H : st, a[E + x + 3] = q > Q ? q : Q;
        }
      return y;
    }
  }
}
var ki2 = new Box3();
function Gt(l, s, t, e) {
  return $(l, s, ki2), t.intersectBox(ki2, e);
}
function Uo(l, s, t, e, i, o) {
  const { geometry: n, _indirectBuffer: r } = l;
  for (let a = e, c = e + i; a < c; a++) {
    let h = r ? r[a] : a;
    xs(n, s, t, h, o);
  }
}
function xo(l, s, t, e, i) {
  const { geometry: o, _indirectBuffer: n } = l;
  let r = 1 / 0, a = null;
  for (let c = e, h = e + i; c < h; c++) {
    let d;
    d = xs(o, s, t, n ? n[c] : c), d && d.distance < r && (a = d, r = d.distance);
  }
  return a;
}
function bo(l, s, t, e, i, o, n) {
  const { geometry: r } = t, { index: a } = r, c = r.attributes.position;
  for (let h = l, d = s + l; h < d; h++) {
    let E;
    if (E = t.resolveTriangleIndex(h), et(n, E * 3, a, c), n.needsUpdate = true, e(n, E, i, o))
      return true;
  }
  return false;
}
var Wi = new Vector3();
function vo(l, s, t, e, i) {
  Z.setBuffer(l._roots[s]), ci(0, l, t, e, i), Z.clearBuffer();
}
function ci(l, s, t, e, i) {
  const { float32Array: o, uint16Array: n, uint32Array: r } = Z, a = l * 2;
  if (ht(a, n)) {
    const h = Et(l, r), d = ft(a, n);
    yo(s, t, e, h, d, i);
  } else {
    const h = pt(l);
    Gt(h, o, e, Wi) && ci(h, s, t, e, i);
    const d = Ct(l, r);
    Gt(d, o, e, Wi) && ci(d, s, t, e, i);
  }
}
var Xi2 = new Vector3();
var Bo = ["x", "y", "z"];
function Yo(l, s, t, e) {
  Z.setBuffer(l._roots[s]);
  const i = li(0, l, t, e);
  return Z.clearBuffer(), i;
}
function li(l, s, t, e) {
  const { float32Array: i, uint16Array: o, uint32Array: n } = Z;
  let r = l * 2;
  if (ht(r, o)) {
    const c = Et(l, n), h = ft(r, o);
    return wo(s, t, e, c, h);
  } else {
    const c = xn(l, n), h = Bo[c], E = e.direction[h] >= 0;
    let u, p;
    E ? (u = pt(l), p = Ct(l, n)) : (u = Ct(l, n), p = pt(l));
    const m = Gt(u, i, e, Xi2) ? li(u, s, t, e) : null;
    if (m) {
      const F = m.point[h];
      if (E ? F <= i[p + c] : (
        // min bounding data
        F >= i[p + c + 3]
      ))
        return m;
    }
    const R = Gt(p, i, e, Xi2) ? li(p, s, t, e) : null;
    return m && R ? m.distance <= R.distance ? m : R : m || R || null;
  }
}
var is = new Box3();
var ne = new Ft();
var oe = new Ft();
var Oe = new Matrix4();
var Zi = new at();
var ns = new at();
function Vo(l, s, t, e) {
  Z.setBuffer(l._roots[s]);
  const i = hi(0, l, t, e);
  return Z.clearBuffer(), i;
}
function hi(l, s, t, e, i = null) {
  const { float32Array: o, uint16Array: n, uint32Array: r } = Z;
  let a = l * 2;
  if (i === null && (t.boundingBox || t.computeBoundingBox(), Zi.set(t.boundingBox.min, t.boundingBox.max, e), i = Zi), ht(a, n)) {
    const h = s.geometry, d = h.index, E = h.attributes.position, u = t.index, p = t.attributes.position, A = Et(l, r), m = ft(a, n);
    if (Oe.copy(e).invert(), t.boundsTree)
      return $(l, o, ns), ns.matrix.copy(Oe), ns.needsUpdate = true, t.boundsTree.shapecast({
        intersectsBounds: (R) => ns.intersectsBox(R),
        intersectsTriangle: (R) => {
          R.a.applyMatrix4(e), R.b.applyMatrix4(e), R.c.applyMatrix4(e), R.needsUpdate = true;
          for (let F = A * 3, f = (m + A) * 3; F < f; F += 3)
            if (et(oe, F, d, E), oe.needsUpdate = true, R.intersectsTriangle(oe))
              return true;
          return false;
        }
      });
    for (let C = A * 3, R = (m + A) * 3; C < R; C += 3) {
      et(ne, C, d, E), ne.a.applyMatrix4(Oe), ne.b.applyMatrix4(Oe), ne.c.applyMatrix4(Oe), ne.needsUpdate = true;
      for (let F = 0, f = u.count; F < f; F += 3)
        if (et(oe, F, u, p), oe.needsUpdate = true, ne.intersectsTriangle(oe))
          return true;
    }
  } else {
    const h = l + 8, d = r[l + 6];
    return $(h, o, is), !!(i.intersectsBox(is) && hi(h, s, t, e, i) || ($(d, o, is), i.intersectsBox(is) && hi(d, s, t, e, i)));
  }
}
var os = new Matrix4();
var ks = new at();
var ge = new at();
var Go = new Vector3();
var zo = new Vector3();
var Ho = new Vector3();
var ko = new Vector3();
function Wo(l, s, t, e = {}, i = {}, o = 0, n = 1 / 0) {
  s.boundingBox || s.computeBoundingBox(), ks.set(s.boundingBox.min, s.boundingBox.max, t), ks.needsUpdate = true;
  const r = l.geometry, a = r.attributes.position, c = r.index, h = s.attributes.position, d = s.index, E = It.getPrimitive(), u = It.getPrimitive();
  let p = Go, A = zo, m = null, C = null;
  i && (m = Ho, C = ko);
  let R = 1 / 0, F = null, f = null;
  return os.copy(t).invert(), ge.matrix.copy(os), l.shapecast(
    {
      boundsTraverseOrder: (T) => ks.distanceToBox(T),
      intersectsBounds: (T, O, S) => S < R && S < n ? (O && (ge.min.copy(T.min), ge.max.copy(T.max), ge.needsUpdate = true), true) : false,
      intersectsRange: (T, O) => {
        if (s.boundsTree)
          return s.boundsTree.shapecast({
            boundsTraverseOrder: (_) => ge.distanceToBox(_),
            intersectsBounds: (_, N, L) => L < R && L < n,
            intersectsRange: (_, N) => {
              for (let L = _, M = _ + N; L < M; L++) {
                et(u, 3 * L, d, h), u.a.applyMatrix4(t), u.b.applyMatrix4(t), u.c.applyMatrix4(t), u.needsUpdate = true;
                for (let y = T, x = T + O; y < x; y++) {
                  et(E, 3 * y, c, a), E.needsUpdate = true;
                  const b = E.distanceToTriangle(u, p, m);
                  if (b < R && (A.copy(p), C && C.copy(m), R = b, F = y, f = L), b < o)
                    return true;
                }
              }
            }
          });
        {
          const S = Ce(s);
          for (let _ = 0, N = S; _ < N; _++) {
            et(u, 3 * _, d, h), u.a.applyMatrix4(t), u.b.applyMatrix4(t), u.c.applyMatrix4(t), u.needsUpdate = true;
            for (let L = T, M = T + O; L < M; L++) {
              et(E, 3 * L, c, a), E.needsUpdate = true;
              const y = E.distanceToTriangle(u, p, m);
              if (y < R && (A.copy(p), C && C.copy(m), R = y, F = L, f = _), y < o)
                return true;
            }
          }
        }
      }
    }
  ), It.releasePrimitive(E), It.releasePrimitive(u), R === 1 / 0 ? null : (e.point ? e.point.copy(A) : e.point = A.clone(), e.distance = R, e.faceIndex = F, i && (i.point ? i.point.copy(C) : i.point = C.clone(), i.point.applyMatrix4(os), A.applyMatrix4(os), i.distance = A.sub(i.point).length(), i.faceIndex = f), e);
}
function Xo(l, s = null) {
  s && Array.isArray(s) && (s = new Set(s));
  const t = l.geometry, e = t.index ? t.index.array : null, i = t.attributes.position;
  let o, n, r, a, c = 0;
  const h = l._roots;
  for (let E = 0, u = h.length; E < u; E++)
    o = h[E], n = new Uint32Array(o), r = new Uint16Array(o), a = new Float32Array(o), d(0, c), c += o.byteLength;
  function d(E, u, p = false) {
    const A = E * 2;
    if (r[A + 15] === Us) {
      const C = n[E + 6], R = r[A + 14];
      let F = 1 / 0, f = 1 / 0, T = 1 / 0, O = -1 / 0, S = -1 / 0, _ = -1 / 0;
      for (let N = C, L = C + R; N < L; N++) {
        const M = 3 * l.resolveTriangleIndex(N);
        for (let y = 0; y < 3; y++) {
          let x = M + y;
          x = e ? e[x] : x;
          const b = i.getX(x), B = i.getY(x), H = i.getZ(x);
          b < F && (F = b), b > O && (O = b), B < f && (f = B), B > S && (S = B), H < T && (T = H), H > _ && (_ = H);
        }
      }
      return a[E + 0] !== F || a[E + 1] !== f || a[E + 2] !== T || a[E + 3] !== O || a[E + 4] !== S || a[E + 5] !== _ ? (a[E + 0] = F, a[E + 1] = f, a[E + 2] = T, a[E + 3] = O, a[E + 4] = S, a[E + 5] = _, true) : false;
    } else {
      const C = E + 8, R = n[E + 6], F = C + u, f = R + u;
      let T = p, O = false, S = false;
      s ? T || (O = s.has(F), S = s.has(f), T = !O && !S) : (O = true, S = true);
      const _ = T || O, N = T || S;
      let L = false;
      _ && (L = d(C, u, T));
      let M = false;
      N && (M = d(R, u, T));
      const y = L || M;
      if (y)
        for (let x = 0; x < 3; x++) {
          const b = C + x, B = R + x, H = a[b], q = a[b + 3], st = a[B], Q = a[B + 3];
          a[E + x] = H < st ? H : st, a[E + x + 3] = q > Q ? q : Q;
        }
      return y;
    }
  }
}
var Qi = new Vector3();
function Zo(l, s, t, e, i) {
  Z.setBuffer(l._roots[s]), Ei(0, l, t, e, i), Z.clearBuffer();
}
function Ei(l, s, t, e, i) {
  const { float32Array: o, uint16Array: n, uint32Array: r } = Z, a = l * 2;
  if (ht(a, n)) {
    const h = Et(l, r), d = ft(a, n);
    Uo(s, t, e, h, d, i);
  } else {
    const h = pt(l);
    Gt(h, o, e, Qi) && Ei(h, s, t, e, i);
    const d = Ct(l, r);
    Gt(d, o, e, Qi) && Ei(d, s, t, e, i);
  }
}
var ji2 = new Vector3();
var Qo = ["x", "y", "z"];
function jo(l, s, t, e) {
  Z.setBuffer(l._roots[s]);
  const i = di(0, l, t, e);
  return Z.clearBuffer(), i;
}
function di(l, s, t, e) {
  const { float32Array: i, uint16Array: o, uint32Array: n } = Z;
  let r = l * 2;
  if (ht(r, o)) {
    const c = Et(l, n), h = ft(r, o);
    return xo(s, t, e, c, h);
  } else {
    const c = xn(l, n), h = Qo[c], E = e.direction[h] >= 0;
    let u, p;
    E ? (u = pt(l), p = Ct(l, n)) : (u = Ct(l, n), p = pt(l));
    const m = Gt(u, i, e, ji2) ? di(u, s, t, e) : null;
    if (m) {
      const F = m.point[h];
      if (E ? F <= i[p + c] : (
        // min bounding data
        F >= i[p + c + 3]
      ))
        return m;
    }
    const R = Gt(p, i, e, ji2) ? di(p, s, t, e) : null;
    return m && R ? m.distance <= R.distance ? m : R : m || R || null;
  }
}
var rs = new Box3();
var re = new Ft();
var ae = new Ft();
var Se = new Matrix4();
var qi = new at();
var as = new at();
function qo(l, s, t, e) {
  Z.setBuffer(l._roots[s]);
  const i = ui(0, l, t, e);
  return Z.clearBuffer(), i;
}
function ui(l, s, t, e, i = null) {
  const { float32Array: o, uint16Array: n, uint32Array: r } = Z;
  let a = l * 2;
  if (i === null && (t.boundingBox || t.computeBoundingBox(), qi.set(t.boundingBox.min, t.boundingBox.max, e), i = qi), ht(a, n)) {
    const h = s.geometry, d = h.index, E = h.attributes.position, u = t.index, p = t.attributes.position, A = Et(l, r), m = ft(a, n);
    if (Se.copy(e).invert(), t.boundsTree)
      return $(l, o, as), as.matrix.copy(Se), as.needsUpdate = true, t.boundsTree.shapecast({
        intersectsBounds: (R) => as.intersectsBox(R),
        intersectsTriangle: (R) => {
          R.a.applyMatrix4(e), R.b.applyMatrix4(e), R.c.applyMatrix4(e), R.needsUpdate = true;
          for (let F = A, f = m + A; F < f; F++)
            if (et(ae, 3 * s.resolveTriangleIndex(F), d, E), ae.needsUpdate = true, R.intersectsTriangle(ae))
              return true;
          return false;
        }
      });
    for (let C = A, R = m + A; C < R; C++) {
      const F = s.resolveTriangleIndex(C);
      et(re, 3 * F, d, E), re.a.applyMatrix4(Se), re.b.applyMatrix4(Se), re.c.applyMatrix4(Se), re.needsUpdate = true;
      for (let f = 0, T = u.count; f < T; f += 3)
        if (et(ae, f, u, p), ae.needsUpdate = true, re.intersectsTriangle(ae))
          return true;
    }
  } else {
    const h = l + 8, d = r[l + 6];
    return $(h, o, rs), !!(i.intersectsBox(rs) && ui(h, s, t, e, i) || ($(d, o, rs), i.intersectsBox(rs) && ui(d, s, t, e, i)));
  }
}
var cs = new Matrix4();
var Ws = new at();
var _e = new at();
var $o = new Vector3();
var Ko = new Vector3();
var Jo = new Vector3();
var tr = new Vector3();
function er(l, s, t, e = {}, i = {}, o = 0, n = 1 / 0) {
  s.boundingBox || s.computeBoundingBox(), Ws.set(s.boundingBox.min, s.boundingBox.max, t), Ws.needsUpdate = true;
  const r = l.geometry, a = r.attributes.position, c = r.index, h = s.attributes.position, d = s.index, E = It.getPrimitive(), u = It.getPrimitive();
  let p = $o, A = Ko, m = null, C = null;
  i && (m = Jo, C = tr);
  let R = 1 / 0, F = null, f = null;
  return cs.copy(t).invert(), _e.matrix.copy(cs), l.shapecast(
    {
      boundsTraverseOrder: (T) => Ws.distanceToBox(T),
      intersectsBounds: (T, O, S) => S < R && S < n ? (O && (_e.min.copy(T.min), _e.max.copy(T.max), _e.needsUpdate = true), true) : false,
      intersectsRange: (T, O) => {
        if (s.boundsTree) {
          const S = s.boundsTree;
          return S.shapecast({
            boundsTraverseOrder: (_) => _e.distanceToBox(_),
            intersectsBounds: (_, N, L) => L < R && L < n,
            intersectsRange: (_, N) => {
              for (let L = _, M = _ + N; L < M; L++) {
                const y = S.resolveTriangleIndex(L);
                et(u, 3 * y, d, h), u.a.applyMatrix4(t), u.b.applyMatrix4(t), u.c.applyMatrix4(t), u.needsUpdate = true;
                for (let x = T, b = T + O; x < b; x++) {
                  const B = l.resolveTriangleIndex(x);
                  et(E, 3 * B, c, a), E.needsUpdate = true;
                  const H = E.distanceToTriangle(u, p, m);
                  if (H < R && (A.copy(p), C && C.copy(m), R = H, F = x, f = L), H < o)
                    return true;
                }
              }
            }
          });
        } else {
          const S = Ce(s);
          for (let _ = 0, N = S; _ < N; _++) {
            et(u, 3 * _, d, h), u.a.applyMatrix4(t), u.b.applyMatrix4(t), u.c.applyMatrix4(t), u.needsUpdate = true;
            for (let L = T, M = T + O; L < M; L++) {
              const y = l.resolveTriangleIndex(L);
              et(E, 3 * y, c, a), E.needsUpdate = true;
              const x = E.distanceToTriangle(u, p, m);
              if (x < R && (A.copy(p), C && C.copy(m), R = x, F = L, f = _), x < o)
                return true;
            }
          }
        }
      }
    }
  ), It.releasePrimitive(E), It.releasePrimitive(u), R === 1 / 0 ? null : (e.point ? e.point.copy(A) : e.point = A.clone(), e.distance = R, e.faceIndex = F, i && (i.point ? i.point.copy(C) : i.point = C.clone(), i.point.applyMatrix4(cs), A.applyMatrix4(cs), i.distance = A.sub(i.point).length(), i.faceIndex = f), e);
}
function sr() {
  return typeof SharedArrayBuffer < "u";
}
var be = new Z.constructor();
var As = new Z.constructor();
var vt = new gi(() => new Box3());
var ce = new Box3();
var le = new Box3();
var Xs = new Box3();
var Zs = new Box3();
var Qs = false;
function ir(l, s, t, e) {
  if (Qs)
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  Qs = true;
  const i = l._roots, o = s._roots;
  let n, r = 0, a = 0;
  const c = new Matrix4().copy(t).invert();
  for (let h = 0, d = i.length; h < d; h++) {
    be.setBuffer(i[h]), a = 0;
    const E = vt.getPrimitive();
    $(0, be.float32Array, E), E.applyMatrix4(c);
    for (let u = 0, p = o.length; u < p && (As.setBuffer(o[h]), n = Tt(
      0,
      0,
      t,
      c,
      e,
      r,
      a,
      0,
      0,
      E
    ), As.clearBuffer(), a += o[u].length, !n); u++)
      ;
    if (vt.releasePrimitive(E), be.clearBuffer(), r += i[h].length, n)
      break;
  }
  return Qs = false, n;
}
function Tt(l, s, t, e, i, o = 0, n = 0, r = 0, a = 0, c = null, h = false) {
  let d, E;
  h ? (d = As, E = be) : (d = be, E = As);
  const u = d.float32Array, p = d.uint32Array, A = d.uint16Array, m = E.float32Array, C = E.uint32Array, R = E.uint16Array, F = l * 2, f = s * 2, T = ht(F, A), O = ht(f, R);
  let S = false;
  if (O && T)
    h ? S = i(
      Et(s, C),
      ft(s * 2, R),
      Et(l, p),
      ft(l * 2, A),
      a,
      n + s,
      r,
      o + l
    ) : S = i(
      Et(l, p),
      ft(l * 2, A),
      Et(s, C),
      ft(s * 2, R),
      r,
      o + l,
      a,
      n + s
    );
  else if (O) {
    const _ = vt.getPrimitive();
    $(s, m, _), _.applyMatrix4(t);
    const N = pt(l), L = Ct(l, p);
    $(N, u, ce), $(L, u, le);
    const M = _.intersectsBox(ce), y = _.intersectsBox(le);
    S = M && Tt(
      s,
      N,
      e,
      t,
      i,
      n,
      o,
      a,
      r + 1,
      _,
      !h
    ) || y && Tt(
      s,
      L,
      e,
      t,
      i,
      n,
      o,
      a,
      r + 1,
      _,
      !h
    ), vt.releasePrimitive(_);
  } else {
    const _ = pt(s), N = Ct(s, C);
    $(_, m, Xs), $(N, m, Zs);
    const L = c.intersectsBox(Xs), M = c.intersectsBox(Zs);
    if (L && M)
      S = Tt(
        l,
        _,
        t,
        e,
        i,
        o,
        n,
        r,
        a + 1,
        c,
        h
      ) || Tt(
        l,
        N,
        t,
        e,
        i,
        o,
        n,
        r,
        a + 1,
        c,
        h
      );
    else if (L)
      if (T)
        S = Tt(
          l,
          _,
          t,
          e,
          i,
          o,
          n,
          r,
          a + 1,
          c,
          h
        );
      else {
        const y = vt.getPrimitive();
        y.copy(Xs).applyMatrix4(t);
        const x = pt(l), b = Ct(l, p);
        $(x, u, ce), $(b, u, le);
        const B = y.intersectsBox(ce), H = y.intersectsBox(le);
        S = B && Tt(
          _,
          x,
          e,
          t,
          i,
          n,
          o,
          a,
          r + 1,
          y,
          !h
        ) || H && Tt(
          _,
          b,
          e,
          t,
          i,
          n,
          o,
          a,
          r + 1,
          y,
          !h
        ), vt.releasePrimitive(y);
      }
    else if (M)
      if (T)
        S = Tt(
          l,
          N,
          t,
          e,
          i,
          o,
          n,
          r,
          a + 1,
          c,
          h
        );
      else {
        const y = vt.getPrimitive();
        y.copy(Zs).applyMatrix4(t);
        const x = pt(l), b = Ct(l, p);
        $(x, u, ce), $(b, u, le);
        const B = y.intersectsBox(ce), H = y.intersectsBox(le);
        S = B && Tt(
          N,
          x,
          e,
          t,
          i,
          n,
          o,
          a,
          r + 1,
          y,
          !h
        ) || H && Tt(
          N,
          b,
          e,
          t,
          i,
          n,
          o,
          a,
          r + 1,
          y,
          !h
        ), vt.releasePrimitive(y);
      }
  }
  return S;
}
var ls = new at();
var $i = new Box3();
var Si = class _Si {
  static serialize(s, t = {}) {
    t = {
      cloneBuffers: true,
      ...t
    };
    const e = s.geometry, i = s._roots, o = s._indirectBuffer, n = e.getIndex();
    let r;
    return t.cloneBuffers ? r = {
      roots: i.map((a) => a.slice()),
      index: n.array.slice(),
      indirectBuffer: o ? o.slice() : null
    } : r = {
      roots: i,
      index: n.array,
      indirectBuffer: o
    }, r;
  }
  static deserialize(s, t, e = {}) {
    e = {
      setIndex: true,
      indirect: !!s.indirectBuffer,
      ...e
    };
    const { index: i, roots: o, indirectBuffer: n } = s, r = new _Si(t, { ...e, [Vs]: true });
    if (r._roots = o, r._indirectBuffer = n || null, e.setIndex) {
      const a = t.getIndex();
      if (a === null) {
        const c = new BufferAttribute(s.index, 1, false);
        t.setIndex(c);
      } else
        a.array !== i && (a.array.set(i), a.needsUpdate = true);
    }
    return r;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(s, t = {}) {
    if (s.isBufferGeometry) {
      if (s.index && s.index.isInterleavedBufferAttribute)
        throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    } else
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    if (t = Object.assign({
      strategy: Mn,
      maxDepth: 40,
      maxLeafTris: 10,
      verbose: true,
      useSharedArrayBuffer: false,
      setBoundingBox: true,
      onProgress: null,
      indirect: false,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [Vs]: false
    }, t), t.useSharedArrayBuffer && !sr())
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    this.geometry = s, this._roots = null, this._indirectBuffer = null, t[Vs] || (Ro(this, t), !s.boundingBox && t.setBoundingBox && (s.boundingBox = this.getBoundingBox(new Box3())));
    const { _indirectBuffer: e } = this;
    this.resolveTriangleIndex = t.indirect ? (i) => e[i] : (i) => i;
  }
  refit(s = null) {
    return (this.indirect ? Xo : Do)(this, s);
  }
  traverse(s, t = 0) {
    const e = this._roots[t], i = new Uint32Array(e), o = new Uint16Array(e);
    n(0);
    function n(r, a = 0) {
      const c = r * 2, h = o[c + 15] === Us;
      if (h) {
        const d = i[r + 6], E = o[c + 14];
        s(a, h, new Float32Array(e, r * 4, 6), d, E);
      } else {
        const d = r + Ts / 4, E = i[r + 6], u = i[r + 7];
        s(a, h, new Float32Array(e, r * 4, 6), u) || (n(d, a + 1), n(E, a + 1));
      }
    }
  }
  /* Core Cast Functions */
  raycast(s, t = FrontSide) {
    const e = this._roots, i = this.geometry, o = [], n = t.isMaterial, r = Array.isArray(t), a = i.groups, c = n ? t.side : t, h = this.indirect ? Zo : vo;
    for (let d = 0, E = e.length; d < E; d++) {
      const u = r ? t[a[d].materialIndex].side : c, p = o.length;
      if (h(this, d, u, s, o), r) {
        const A = a[d].materialIndex;
        for (let m = p, C = o.length; m < C; m++)
          o[m].face.materialIndex = A;
      }
    }
    return o;
  }
  raycastFirst(s, t = FrontSide) {
    const e = this._roots, i = this.geometry, o = t.isMaterial, n = Array.isArray(t);
    let r = null;
    const a = i.groups, c = o ? t.side : t, h = this.indirect ? jo : Yo;
    for (let d = 0, E = e.length; d < E; d++) {
      const u = n ? t[a[d].materialIndex].side : c, p = h(this, d, u, s);
      p != null && (r == null || p.distance < r.distance) && (r = p, n && (p.face.materialIndex = a[d].materialIndex));
    }
    return r;
  }
  intersectsGeometry(s, t) {
    let e = false;
    const i = this._roots, o = this.indirect ? qo : Vo;
    for (let n = 0, r = i.length; n < r && (e = o(this, n, s, t), !e); n++)
      ;
    return e;
  }
  shapecast(s) {
    const t = It.getPrimitive(), e = this.indirect ? bo : Mo;
    let {
      boundsTraverseOrder: i,
      intersectsBounds: o,
      intersectsRange: n,
      intersectsTriangle: r
    } = s;
    if (n && r) {
      const d = n;
      n = (E, u, p, A, m) => d(E, u, p, A, m) ? true : e(E, u, this, r, p, A, t);
    } else
      n || (r ? n = (d, E, u, p) => e(d, E, this, r, u, p, t) : n = (d, E, u) => u);
    let a = false, c = 0;
    const h = this._roots;
    for (let d = 0, E = h.length; d < E; d++) {
      const u = h[d];
      if (a = _o(this, d, o, n, i, c), a)
        break;
      c += u.byteLength;
    }
    return It.releasePrimitive(t), a;
  }
  bvhcast(s, t, e) {
    let {
      intersectsRanges: i,
      intersectsTriangles: o
    } = e;
    const n = It.getPrimitive(), r = this.geometry.index, a = this.geometry.attributes.position, c = this.indirect ? (p) => {
      const A = this.resolveTriangleIndex(p);
      et(n, A * 3, r, a);
    } : (p) => {
      et(n, p * 3, r, a);
    }, h = It.getPrimitive(), d = s.geometry.index, E = s.geometry.attributes.position, u = s.indirect ? (p) => {
      const A = s.resolveTriangleIndex(p);
      et(h, A * 3, d, E);
    } : (p) => {
      et(h, p * 3, d, E);
    };
    if (o) {
      const p = (A, m, C, R, F, f, T, O) => {
        for (let S = C, _ = C + R; S < _; S++) {
          u(S), h.a.applyMatrix4(t), h.b.applyMatrix4(t), h.c.applyMatrix4(t), h.needsUpdate = true;
          for (let N = A, L = A + m; N < L; N++)
            if (c(N), n.needsUpdate = true, o(n, h, N, S, F, f, T, O))
              return true;
        }
        return false;
      };
      if (i) {
        const A = i;
        i = function(m, C, R, F, f, T, O, S) {
          return A(m, C, R, F, f, T, O, S) ? true : p(m, C, R, F, f, T, O, S);
        };
      } else
        i = p;
    }
    return ir(this, s, t, i);
  }
  /* Derived Cast Functions */
  intersectsBox(s, t) {
    return ls.set(s.min, s.max, t), ls.needsUpdate = true, this.shapecast(
      {
        intersectsBounds: (e) => ls.intersectsBox(e),
        intersectsTriangle: (e) => ls.intersectsTriangle(e)
      }
    );
  }
  intersectsSphere(s) {
    return this.shapecast(
      {
        intersectsBounds: (t) => s.intersectsBox(t),
        intersectsTriangle: (t) => t.intersectsSphere(s)
      }
    );
  }
  closestPointToGeometry(s, t, e = {}, i = {}, o = 0, n = 1 / 0) {
    return (this.indirect ? er : Wo)(
      this,
      s,
      t,
      e,
      i,
      o,
      n
    );
  }
  closestPointToPoint(s, t = {}, e = 0, i = 1 / 0) {
    return No(
      this,
      s,
      t,
      e,
      i
    );
  }
  getBoundingBox(s) {
    return s.makeEmpty(), this._roots.forEach((e) => {
      $(0, new Float32Array(e), $i), s.union($i);
    }), s;
  }
};
function Ki(l, s, t) {
  return l === null || (l.point.applyMatrix4(s.matrixWorld), l.distance = l.point.distanceTo(t.ray.origin), l.object = s, l.distance < t.near || l.distance > t.far) ? null : l;
}
var js = new Ray();
var Ji = new Matrix4();
var nr = Mesh.prototype.raycast;
function or(l, s) {
  if (this.geometry.boundsTree) {
    if (this.material === void 0)
      return;
    Ji.copy(this.matrixWorld).invert(), js.copy(l.ray).applyMatrix4(Ji);
    const t = this.geometry.boundsTree;
    if (l.firstHitOnly === true) {
      const e = Ki(t.raycastFirst(js, this.material), this, l);
      e && s.push(e);
    } else {
      const e = t.raycast(js, this.material);
      for (let i = 0, o = e.length; i < o; i++) {
        const n = Ki(e[i], this, l);
        n && s.push(n);
      }
    }
  } else
    nr.call(this, l, s);
}
function rr(l) {
  return this.boundsTree = new Si(this, l), this.boundsTree;
}
function ar() {
  this.boundsTree = null;
}
var D = class {
  constructor() {
    I(this, "trigger", (s) => {
      const t = this.handlers.slice(0);
      for (const e of t)
        e(s);
    });
    I(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(s) {
    this.handlers.push(s);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(s) {
    this.handlers = this.handlers.filter((t) => t !== s);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
};
var $t = class {
  constructor() {
    I(this, "trigger", async (s) => {
      const t = this.handlers.slice(0);
      for (const e of t)
        await e(s);
    });
    I(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(s) {
    this.handlers.push(s);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(s) {
    this.handlers = this.handlers.filter((t) => t !== s);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
};
var _i = class {
  constructor(s) {
    I(this, "isDisposeable", () => "dispose" in this && "onDisposed" in this);
    I(this, "isResizeable", () => "resize" in this && "getSize" in this);
    I(this, "isUpdateable", () => "onAfterUpdate" in this && "onBeforeUpdate" in this && "update" in this);
    I(this, "isHideable", () => "visible" in this);
    I(this, "isConfigurable", () => "setup" in this && "config" in this && "onSetup" in this);
    this.components = s;
  }
};
var J = class extends _i {
};
var Ni2 = class extends _i {
  constructor(t) {
    super(t);
    I(this, "worlds", /* @__PURE__ */ new Map());
    I(this, "onWorldChanged", new D());
    I(this, "currentWorld", null);
    this.onWorldChanged.add(({ world: e, action: i }) => {
      i === "removed" && this.worlds.delete(e.uuid);
    });
  }
};
var cr = class extends Ni2 {
  constructor() {
    super(...arguments);
    I(this, "hasCameraControls", () => "controls" in this);
  }
};
var lr = class extends Ni2 {
  constructor() {
    super(...arguments);
    I(this, "onAfterUpdate", new D());
    I(this, "onBeforeUpdate", new D());
    I(this, "onDisposed", new D());
    I(this, "onResize", new D());
    I(this, "onClippingPlanesUpdated", new D());
    I(this, "clippingPlanes", []);
  }
  /**
   * Forces the update of the clipping planes and all components that depend
   * on them that are subscribed to `onClippingPlanesUpdated`.
   */
  updateClippingPlanes() {
    this.onClippingPlanesUpdated.trigger();
  }
  /**
   * Adds or removes a
   * [clipping plane](https://threejs.org/docs/#api/en/renderers/WebGLRenderer.clippingPlanes)
   * to the renderer.
   */
  setPlane(t, e, i) {
    e.isLocal = i;
    const o = this.clippingPlanes.indexOf(e);
    t && o === -1 ? this.clippingPlanes.push(e) : !t && o > -1 && this.clippingPlanes.splice(o, 1), this.three.clippingPlanes = this.clippingPlanes.filter(
      (n) => !n.isLocal
    );
  }
};
var ve = class ve2 extends J {
  constructor(t) {
    super(t);
    I(this, "_disposedComponents", /* @__PURE__ */ new Set());
    I(this, "enabled", true);
    t.add(ve2.uuid, this);
  }
  /**
   * {@link Component.uuid}.
   * @return the list of UUIDs of deleted components.
   */
  get() {
    return this._disposedComponents;
  }
  /**
   * Removes a mesh, its geometry and its materials from memory. If you are
   * using any of these in other parts of the application, make sure that you
   * remove them from the mesh before disposing it.
   *
   * @param object - the [object](https://threejs.org/docs/#api/en/core/Object3D)
   * to remove.
   *
   * @param materials - whether to dispose the materials of the mesh.
   *
   * @param recursive - whether to recursively dispose the children of the mesh.
   */
  destroy(t, e = true, i = true) {
    t.removeFromParent();
    const o = t;
    o.dispose && o.dispose(), this.disposeGeometryAndMaterials(t, e), i && o.children && o.children.length && this.disposeChildren(o), t.children.length = 0;
  }
  /**
   * Disposes a geometry from memory.
   *
   * @param geometry - the
   * [geometry](https://threejs.org/docs/#api/en/core/BufferGeometry)
   * to remove.
   */
  disposeGeometry(t) {
    const e = t;
    e.boundsTree && e.disposeBoundsTree(), t.dispose();
  }
  disposeGeometryAndMaterials(t, e) {
    const i = t;
    i.geometry && this.disposeGeometry(i.geometry), e && i.material && ve2.disposeMaterial(i), i.material = [], i.geometry = null;
  }
  disposeChildren(t) {
    for (const e of t.children)
      this.destroy(e);
  }
  static disposeMaterial(t) {
    if (t.material)
      if (Array.isArray(t.material))
        for (const e of t.material)
          e.dispose();
      else
        t.material.dispose();
  }
};
I(ve, "uuid", "76e9cd8e-ad8f-4753-9ef6-cbc60f7247fe");
var zt = ve;
var hr = class extends Ni2 {
  constructor(t) {
    super(t);
    I(this, "onDisposed", new D());
  }
  /** {@link Disposable.dispose} */
  dispose() {
    const t = this.components.get(zt);
    for (const e of this.three.children) {
      const i = e;
      i.geometry && t.destroy(i);
    }
    this.three.children = [], this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
var ms = 0;
var Er = 1;
var dr = new Vector3();
var tn = new Line3();
var qs = new Plane();
var en = new Vector3();
var hs = new Triangle();
var ur = class {
  constructor() {
    this.tolerance = -1, this.faces = [], this.newFaces = [], this.assigned = new sn(), this.unassigned = new sn(), this.vertices = [];
  }
  setFromPoints(s) {
    if (s.length >= 4) {
      this.makeEmpty();
      for (let t = 0, e = s.length; t < e; t++)
        this.vertices.push(new Ir(s[t]));
      this.compute();
    }
    return this;
  }
  setFromObject(s) {
    const t = [];
    return s.updateMatrixWorld(true), s.traverse(function(e) {
      const i = e.geometry;
      if (i !== void 0) {
        const o = i.attributes.position;
        if (o !== void 0)
          for (let n = 0, r = o.count; n < r; n++) {
            const a = new Vector3();
            a.fromBufferAttribute(o, n).applyMatrix4(e.matrixWorld), t.push(a);
          }
      }
    }), this.setFromPoints(t);
  }
  containsPoint(s) {
    const t = this.faces;
    for (let e = 0, i = t.length; e < i; e++)
      if (t[e].distanceToPoint(s) > this.tolerance)
        return false;
    return true;
  }
  intersectRay(s, t) {
    const e = this.faces;
    let i = -1 / 0, o = 1 / 0;
    for (let n = 0, r = e.length; n < r; n++) {
      const a = e[n], c = a.distanceToPoint(s.origin), h = a.normal.dot(s.direction);
      if (c > 0 && h >= 0)
        return null;
      const d = h !== 0 ? -c / h : 0;
      if (!(d <= 0) && (h > 0 ? o = Math.min(d, o) : i = Math.max(d, i), i > o))
        return null;
    }
    return i !== -1 / 0 ? s.at(i, t) : s.at(o, t), t;
  }
  intersectsRay(s) {
    return this.intersectRay(s, dr) !== null;
  }
  makeEmpty() {
    return this.faces = [], this.vertices = [], this;
  }
  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face
  addVertexToFace(s, t) {
    return s.face = t, t.outside === null ? this.assigned.append(s) : this.assigned.insertBefore(t.outside, s), t.outside = s, this;
  }
  // Removes a vertex from the 'assigned' list of vertices and from the given face
  removeVertexFromFace(s, t) {
    return s === t.outside && (s.next !== null && s.next.face === t ? t.outside = s.next : t.outside = null), this.assigned.remove(s), this;
  }
  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list
  removeAllVerticesFromFace(s) {
    if (s.outside !== null) {
      const t = s.outside;
      let e = s.outside;
      for (; e.next !== null && e.next.face === s; )
        e = e.next;
      return this.assigned.removeSubList(t, e), t.prev = e.next = null, s.outside = null, t;
    }
  }
  // Removes all the visible vertices that 'face' is able to see
  deleteFaceVertices(s, t) {
    const e = this.removeAllVerticesFromFace(s);
    if (e !== void 0)
      if (t === void 0)
        this.unassigned.appendChain(e);
      else {
        let i = e;
        do {
          const o = i.next;
          t.distanceToPoint(i.point) > this.tolerance ? this.addVertexToFace(i, t) : this.unassigned.append(i), i = o;
        } while (i !== null);
      }
    return this;
  }
  // Reassigns as many vertices as possible from the unassigned list to the new faces
  resolveUnassignedPoints(s) {
    if (this.unassigned.isEmpty() === false) {
      let t = this.unassigned.first();
      do {
        const e = t.next;
        let i = this.tolerance, o = null;
        for (let n = 0; n < s.length; n++) {
          const r = s[n];
          if (r.mark === ms) {
            const a = r.distanceToPoint(t.point);
            if (a > i && (i = a, o = r), i > 1e3 * this.tolerance)
              break;
          }
        }
        o !== null && this.addVertexToFace(t, o), t = e;
      } while (t !== null);
    }
    return this;
  }
  // Computes the extremes of a simplex which will be the initial hull
  computeExtremes() {
    const s = new Vector3(), t = new Vector3(), e = [], i = [];
    for (let o = 0; o < 3; o++)
      e[o] = i[o] = this.vertices[0];
    s.copy(this.vertices[0].point), t.copy(this.vertices[0].point);
    for (let o = 0, n = this.vertices.length; o < n; o++) {
      const r = this.vertices[o], a = r.point;
      for (let c = 0; c < 3; c++)
        a.getComponent(c) < s.getComponent(c) && (s.setComponent(c, a.getComponent(c)), e[c] = r);
      for (let c = 0; c < 3; c++)
        a.getComponent(c) > t.getComponent(c) && (t.setComponent(c, a.getComponent(c)), i[c] = r);
    }
    return this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(s.x), Math.abs(t.x)) + Math.max(Math.abs(s.y), Math.abs(t.y)) + Math.max(Math.abs(s.z), Math.abs(t.z))), { min: e, max: i };
  }
  // Computes the initial simplex assigning to its faces all the points
  // that are candidates to form part of the hull
  computeInitialHull() {
    const s = this.vertices, t = this.computeExtremes(), e = t.min, i = t.max;
    let o = 0, n = 0;
    for (let E = 0; E < 3; E++) {
      const u = i[E].point.getComponent(E) - e[E].point.getComponent(E);
      u > o && (o = u, n = E);
    }
    const r = e[n], a = i[n];
    let c, h;
    o = 0, tn.set(r.point, a.point);
    for (let E = 0, u = this.vertices.length; E < u; E++) {
      const p = s[E];
      if (p !== r && p !== a) {
        tn.closestPointToPoint(p.point, true, en);
        const A = en.distanceToSquared(p.point);
        A > o && (o = A, c = p);
      }
    }
    o = -1, qs.setFromCoplanarPoints(r.point, a.point, c.point);
    for (let E = 0, u = this.vertices.length; E < u; E++) {
      const p = s[E];
      if (p !== r && p !== a && p !== c) {
        const A = Math.abs(qs.distanceToPoint(p.point));
        A > o && (o = A, h = p);
      }
    }
    const d = [];
    if (qs.distanceToPoint(h.point) < 0) {
      d.push(
        Rt.create(r, a, c),
        Rt.create(h, a, r),
        Rt.create(h, c, a),
        Rt.create(h, r, c)
      );
      for (let E = 0; E < 3; E++) {
        const u = (E + 1) % 3;
        d[E + 1].getEdge(2).setTwin(d[0].getEdge(u)), d[E + 1].getEdge(1).setTwin(d[u + 1].getEdge(0));
      }
    } else {
      d.push(
        Rt.create(r, c, a),
        Rt.create(h, r, a),
        Rt.create(h, a, c),
        Rt.create(h, c, r)
      );
      for (let E = 0; E < 3; E++) {
        const u = (E + 1) % 3;
        d[E + 1].getEdge(2).setTwin(d[0].getEdge((3 - E) % 3)), d[E + 1].getEdge(0).setTwin(d[u + 1].getEdge(1));
      }
    }
    for (let E = 0; E < 4; E++)
      this.faces.push(d[E]);
    for (let E = 0, u = s.length; E < u; E++) {
      const p = s[E];
      if (p !== r && p !== a && p !== c && p !== h) {
        o = this.tolerance;
        let A = null;
        for (let m = 0; m < 4; m++) {
          const C = this.faces[m].distanceToPoint(p.point);
          C > o && (o = C, A = this.faces[m]);
        }
        A !== null && this.addVertexToFace(p, A);
      }
    }
    return this;
  }
  // Removes inactive faces
  reindexFaces() {
    const s = [];
    for (let t = 0; t < this.faces.length; t++) {
      const e = this.faces[t];
      e.mark === ms && s.push(e);
    }
    return this.faces = s, this;
  }
  // Finds the next vertex to create faces with the current hull
  nextVertexToAdd() {
    if (this.assigned.isEmpty() === false) {
      let s, t = 0;
      const e = this.assigned.first().face;
      let i = e.outside;
      do {
        const o = e.distanceToPoint(i.point);
        o > t && (t = o, s = i), i = i.next;
      } while (i !== null && i.face === e);
      return s;
    }
  }
  // Computes a chain of half edges in CCW order called the 'horizon'.
  // For an edge to be part of the horizon it must join a face that can see
  // 'eyePoint' and a face that cannot see 'eyePoint'.
  computeHorizon(s, t, e, i) {
    this.deleteFaceVertices(e), e.mark = Er;
    let o;
    t === null ? o = t = e.getEdge(0) : o = t.next;
    do {
      const n = o.twin, r = n.face;
      r.mark === ms && (r.distanceToPoint(s) > this.tolerance ? this.computeHorizon(s, n, r, i) : i.push(o)), o = o.next;
    } while (o !== t);
    return this;
  }
  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order
  addAdjoiningFace(s, t) {
    const e = Rt.create(s, t.tail(), t.head());
    return this.faces.push(e), e.getEdge(-1).setTwin(t.twin), e.getEdge(0);
  }
  //  Adds 'horizon.length' faces to the hull, each face will be linked with the
  //  horizon opposite face and the face on the left/right
  addNewFaces(s, t) {
    this.newFaces = [];
    let e = null, i = null;
    for (let o = 0; o < t.length; o++) {
      const n = t[o], r = this.addAdjoiningFace(s, n);
      e === null ? e = r : r.next.setTwin(i), this.newFaces.push(r.face), i = r;
    }
    return e.next.setTwin(i), this;
  }
  // Adds a vertex to the hull
  addVertexToHull(s) {
    const t = [];
    return this.unassigned.clear(), this.removeVertexFromFace(s, s.face), this.computeHorizon(s.point, null, s.face, t), this.addNewFaces(s, t), this.resolveUnassignedPoints(this.newFaces), this;
  }
  cleanup() {
    return this.assigned.clear(), this.unassigned.clear(), this.newFaces = [], this;
  }
  compute() {
    let s;
    for (this.computeInitialHull(); (s = this.nextVertexToAdd()) !== void 0; )
      this.addVertexToHull(s);
    return this.reindexFaces(), this.cleanup(), this;
  }
};
var Rt = class _Rt {
  constructor() {
    this.normal = new Vector3(), this.midpoint = new Vector3(), this.area = 0, this.constant = 0, this.outside = null, this.mark = ms, this.edge = null;
  }
  static create(s, t, e) {
    const i = new _Rt(), o = new $s(s, i), n = new $s(t, i), r = new $s(e, i);
    return o.next = r.prev = n, n.next = o.prev = r, r.next = n.prev = o, i.edge = o, i.compute();
  }
  getEdge(s) {
    let t = this.edge;
    for (; s > 0; )
      t = t.next, s--;
    for (; s < 0; )
      t = t.prev, s++;
    return t;
  }
  compute() {
    const s = this.edge.tail(), t = this.edge.head(), e = this.edge.next.head();
    return hs.set(s.point, t.point, e.point), hs.getNormal(this.normal), hs.getMidpoint(this.midpoint), this.area = hs.getArea(), this.constant = this.normal.dot(this.midpoint), this;
  }
  distanceToPoint(s) {
    return this.normal.dot(s) - this.constant;
  }
};
var $s = class {
  constructor(s, t) {
    this.vertex = s, this.prev = null, this.next = null, this.twin = null, this.face = t;
  }
  head() {
    return this.vertex;
  }
  tail() {
    return this.prev ? this.prev.vertex : null;
  }
  length() {
    const s = this.head(), t = this.tail();
    return t !== null ? t.point.distanceTo(s.point) : -1;
  }
  lengthSquared() {
    const s = this.head(), t = this.tail();
    return t !== null ? t.point.distanceToSquared(s.point) : -1;
  }
  setTwin(s) {
    return this.twin = s, s.twin = this, this;
  }
};
var Ir = class {
  constructor(s) {
    this.point = s, this.prev = null, this.next = null, this.face = null;
  }
};
var sn = class {
  constructor() {
    this.head = null, this.tail = null;
  }
  first() {
    return this.head;
  }
  last() {
    return this.tail;
  }
  clear() {
    return this.head = this.tail = null, this;
  }
  // Inserts a vertex before the target vertex
  insertBefore(s, t) {
    return t.prev = s.prev, t.next = s, t.prev === null ? this.head = t : t.prev.next = t, s.prev = t, this;
  }
  // Inserts a vertex after the target vertex
  insertAfter(s, t) {
    return t.prev = s, t.next = s.next, t.next === null ? this.tail = t : t.next.prev = t, s.next = t, this;
  }
  // Appends a vertex to the end of the linked list
  append(s) {
    return this.head === null ? this.head = s : this.tail.next = s, s.prev = this.tail, s.next = null, this.tail = s, this;
  }
  // Appends a chain of vertices where 'vertex' is the head.
  appendChain(s) {
    for (this.head === null ? this.head = s : this.tail.next = s, s.prev = this.tail; s.next !== null; )
      s = s.next;
    return this.tail = s, this;
  }
  // Removes a vertex from the linked list
  remove(s) {
    return s.prev === null ? this.head = s.next : s.prev.next = s.next, s.next === null ? this.tail = s.prev : s.next.prev = s.prev, this;
  }
  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b
  removeSubList(s, t) {
    return s.prev === null ? this.head = t.next : s.prev.next = t.next, t.next === null ? this.tail = s.prev : t.next.prev = s.prev, this;
  }
  isEmpty() {
    return this.head === null;
  }
};
var Ii = [2, 2, 1];
var fi = [1, 0, 0];
function Nt(l, s) {
  return l * 3 + s;
}
function fr(l) {
  const s = l.elements;
  let t = 0;
  for (let e = 0; e < 9; e++)
    t += s[e] * s[e];
  return Math.sqrt(t);
}
function pr(l) {
  const s = l.elements;
  let t = 0;
  for (let e = 0; e < 3; e++) {
    const i = s[Nt(Ii[e], fi[e])];
    t += 2 * i * i;
  }
  return Math.sqrt(t);
}
function Cr(l, s) {
  let t = 0, e = 1;
  const i = l.elements;
  for (let c = 0; c < 3; c++) {
    const h = Math.abs(i[Nt(Ii[c], fi[c])]);
    h > t && (t = h, e = c);
  }
  let o = 1, n = 0;
  const r = fi[e], a = Ii[e];
  if (Math.abs(i[Nt(a, r)]) > Number.EPSILON) {
    const c = i[Nt(a, a)], h = i[Nt(r, r)], d = i[Nt(a, r)], E = (c - h) / 2 / d;
    let u;
    E < 0 ? u = -1 / (-E + Math.sqrt(1 + E * E)) : u = 1 / (E + Math.sqrt(1 + E * E)), o = 1 / Math.sqrt(1 + u * u), n = u * o;
  }
  return s.identity(), s.elements[Nt(r, r)] = o, s.elements[Nt(a, a)] = o, s.elements[Nt(a, r)] = n, s.elements[Nt(r, a)] = -n, s;
}
function Tr(l, s) {
  let t = 0, e = 0;
  const i = 10;
  s.unitary.identity(), s.diagonal.copy(l);
  const o = s.unitary, n = s.diagonal, r = new Matrix3(), a = new Matrix3(), c = Number.EPSILON * fr(n);
  for (; e < i && pr(n) > c; )
    Cr(n, r), a.copy(r).transpose(), n.multiply(r), n.premultiply(a), o.multiply(r), ++t > 2 && (e++, t = 0);
  return s;
}
function mr(l) {
  const s = [];
  for (let it = 0; it < l.length - 2; it += 3) {
    const Xt = l[it], tt = l[it + 1], Jt = l[it + 2];
    s.push(new Vector3(Xt, tt, Jt));
  }
  const t = new ur();
  t.setFromPoints(s);
  const e = {
    unitary: new Matrix3(),
    diagonal: new Matrix3()
  }, i = t.faces, o = [], n = [];
  for (let it = 0, Xt = i.length; it < Xt; it++) {
    const tt = i[it];
    let Jt = tt.edge;
    o.length = 0;
    do
      o.push(Jt), Jt = Jt.next;
    while (Jt !== tt.edge);
    const Hn = o.length - 2;
    for (let Ze = 1, kn = Hn; Ze <= kn; Ze++) {
      const bs = o[0].vertex, vs = o[Ze + 0].vertex, Bs = o[Ze + 1].vertex;
      n.push(bs.point.x, bs.point.y, bs.point.z), n.push(vs.point.x, vs.point.y, vs.point.z), n.push(Bs.point.x, Bs.point.y, Bs.point.z);
    }
  }
  const r = new Vector3(), a = new Vector3(), c = new Vector3(), h = new Vector3(), d = new Vector3(), E = new Vector3(), u = new Vector3(), p = new Vector3();
  let A = 0, m = 0, C = 0, R = 0, F = 0, f = 0, T = 0;
  for (let it = 0, Xt = n.length; it < Xt; it += 9) {
    r.fromArray(n, it), a.fromArray(n, it + 3), c.fromArray(n, it + 6), u.set(0, 0, 0), u.add(r).add(a).add(c).divideScalar(3), h.subVectors(a, r), d.subVectors(c, r);
    const tt = E.crossVectors(h, d).length() / 2;
    p.add(E.copy(u).multiplyScalar(tt)), A += tt, m += (9 * u.x * u.x + r.x * r.x + a.x * a.x + c.x * c.x) * (tt / 12), C += (9 * u.x * u.y + r.x * r.y + a.x * a.y + c.x * c.y) * (tt / 12), R += (9 * u.x * u.z + r.x * r.z + a.x * a.z + c.x * c.z) * (tt / 12), F += (9 * u.y * u.y + r.y * r.y + a.y * a.y + c.y * c.y) * (tt / 12), f += (9 * u.y * u.z + r.y * r.z + a.y * a.z + c.y * c.z) * (tt / 12), T += (9 * u.z * u.z + r.z * r.z + a.z * a.z + c.z * c.z) * (tt / 12);
  }
  p.divideScalar(A), m /= A, C /= A, R /= A, F /= A, f /= A, T /= A, m -= p.x * p.x, C -= p.x * p.y, R -= p.x * p.z, F -= p.y * p.y, f -= p.y * p.z, T -= p.z * p.z;
  const O = new Matrix3();
  O.elements[0] = m, O.elements[1] = C, O.elements[2] = R, O.elements[3] = C, O.elements[4] = F, O.elements[5] = f, O.elements[6] = R, O.elements[7] = f, O.elements[8] = T, Tr(O, e);
  const S = e.unitary, _ = new Vector3(), N = new Vector3(), L = new Vector3();
  S.extractBasis(_, N, L);
  let M = -1 / 0, y = -1 / 0, x = -1 / 0, b = 1 / 0, B = 1 / 0, H = 1 / 0;
  for (let it = 0, Xt = s.length; it < Xt; it++) {
    const tt = s[it];
    M = Math.max(_.dot(tt), M), y = Math.max(N.dot(tt), y), x = Math.max(L.dot(tt), x), b = Math.min(_.dot(tt), b), B = Math.min(N.dot(tt), B), H = Math.min(L.dot(tt), H);
  }
  _.multiplyScalar(0.5 * (b + M)), N.multiplyScalar(0.5 * (B + y)), L.multiplyScalar(0.5 * (H + x));
  const q = new Vector3(), st = new Vector3(), Q = new Matrix3();
  q.add(_).add(N).add(L), st.x = M - b, st.y = y - B, st.z = x - H, st.multiplyScalar(0.5), Q.copy(S);
  const { x: Ht, y: kt, z: Wt } = st, Xe = new Matrix4();
  Xe.makeScale(Ht * 2, kt * 2, Wt * 2);
  const Te = new Matrix4();
  Te.makeTranslation(-Ht, -kt, -Wt);
  const wi = new Matrix4();
  wi.makeTranslation(q.x, q.y, q.z);
  const Mi = new Matrix4();
  Mi.setFromMatrix3(Q);
  const me = new Matrix4();
  return me.multiply(wi), me.multiply(Mi), me.multiply(Te), me.multiply(Xe), { center: q, halfSizes: st, rotation: Q, transformation: me };
}
function Rr(l, s, t) {
  const e = [
    l[0] - s[0],
    l[1] - s[1],
    l[2] - s[2]
  ];
  return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] > 0;
}
var nn = class {
  static isTransparent(s) {
    return s.transparent && s.opacity < 1;
  }
};
var K = class K2 {
  // Copied from three.js source
  // Original source: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
  static create() {
    const s = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
    return `${K2._lut[s & 255] + K2._lut[s >> 8 & 255] + K2._lut[s >> 16 & 255] + K2._lut[s >> 24 & 255]}-${K2._lut[t & 255]}${K2._lut[t >> 8 & 255]}-${K2._lut[t >> 16 & 15 | 64]}${K2._lut[t >> 24 & 255]}-${K2._lut[e & 63 | 128]}${K2._lut[e >> 8 & 255]}-${K2._lut[e >> 16 & 255]}${K2._lut[e >> 24 & 255]}${K2._lut[i & 255]}${K2._lut[i >> 8 & 255]}${K2._lut[i >> 16 & 255]}${K2._lut[i >> 24 & 255]}`.toLowerCase();
  }
  static validate(s) {
    if (!K2._pattern.test(s))
      throw new Error(
        `${s} is not a valid UUID v4.

- If you're the tool creator, you can take one from https://www.uuidgenerator.net/.

- If you're using a platform tool, verify the uuid isn't misspelled or contact the tool creator.`
      );
  }
};
I(K, "_pattern", /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/), // prettier-ignore
I(K, "_lut", [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff"
]);
var ze = K;
var sa = class extends J {
  constructor(t, e) {
    super(t);
    I(this, "onVertexFound", new D());
    I(this, "onVertexLost", new D());
    I(this, "components");
    I(this, "_pickedPoint", null);
    I(this, "_config");
    I(this, "_enabled", false);
    I(this, "_workingPlane", null);
    this.components = t, this.config = {
      snapDistance: 0.25,
      showOnlyVertex: false,
      ...e
    }, this.enabled = false;
  }
  set enabled(t) {
    this._enabled = t, t || (this._pickedPoint = null);
  }
  get enabled() {
    return this._enabled;
  }
  set workingPlane(t) {
    this._workingPlane = t;
  }
  get workingPlane() {
    return this._workingPlane;
  }
  set config(t) {
    this._config = { ...this._config, ...t };
  }
  get config() {
    return this._config;
  }
  dispose() {
    this.onVertexFound.reset(), this.onVertexLost.reset(), this.components = null;
  }
  get(t) {
    if (!this.enabled)
      return this._pickedPoint;
    const o = this.components.get(He).get(t).castRay();
    if (!o)
      return this._pickedPoint !== null && (this.onVertexLost.trigger(), this._pickedPoint = null), this._pickedPoint;
    const n = this.getClosestVertex(o);
    return n ? (this.workingPlane ? Math.abs(this.workingPlane.distanceToPoint(n)) < 1e-3 : true) ? ((this._pickedPoint === null || !this._pickedPoint.equals(n)) && (this._pickedPoint = n.clone(), this.onVertexFound.trigger(this._pickedPoint)), this._pickedPoint) : (this._pickedPoint = null, this._pickedPoint) : (this._pickedPoint !== null && (this.onVertexLost.trigger(), this._pickedPoint = null), this._pickedPoint);
  }
  getClosestVertex(t) {
    let e = new Vector3(), i = false, o = Number.MAX_SAFE_INTEGER;
    const n = this.getVertices(t);
    if (n === null)
      return null;
    for (const r of n) {
      if (!r)
        continue;
      const a = t.point.distanceTo(r);
      a > o || a > this._config.snapDistance || (i = true, e = r, o = t.point.distanceTo(r));
    }
    return i ? e : this.config.showOnlyVertex ? null : t.point;
  }
  getVertices(t) {
    const e = t.object;
    if (!t.face || !e)
      return null;
    const i = e.geometry, o = new Matrix4(), { instanceId: n } = t, r = n !== void 0, a = e instanceof InstancedMesh;
    return a && r && e.getMatrixAt(n, o), [
      this.getVertex(t.face.a, i),
      this.getVertex(t.face.b, i),
      this.getVertex(t.face.c, i)
    ].map((c) => (c && (a && r && c.applyMatrix4(o), c.applyMatrix4(e.matrixWorld)), c));
  }
  getVertex(t, e) {
    if (t === void 0)
      return null;
    const i = e.attributes.position;
    return new Vector3(
      i.getX(t),
      i.getY(t),
      i.getZ(t)
    );
  }
};
var Fs = class Fs2 {
  constructor() {
    I(this, "onDisposed", new D());
    I(this, "list", /* @__PURE__ */ new Map());
    I(this, "enabled", false);
    I(this, "_clock");
    I(this, "update", () => {
      if (!this.enabled)
        return;
      const s = this._clock.getDelta();
      for (const [t, e] of this.list)
        e.enabled && e.isUpdateable() && e.update(s);
      requestAnimationFrame(this.update);
    });
    this._clock = new Clock(), Fs2.setupBVH();
  }
  add(s, t) {
    if (this.list.has(s))
      throw new Error(
        "You're trying to add a component that already exists in the components intance. Use Components.get() instead."
      );
    ze.validate(s), this.list.set(s, t);
  }
  /**
   * Retrieves a component. If it already exists in this app, it returns the instance of the component. If it
   * doesn't exist, it will instance it automatically.
   *
   * @param Component - The component to get or create.
   */
  get(s) {
    const t = s.uuid;
    if (!this.list.has(t)) {
      const e = new s(this);
      return this.list.has(t) || this.add(t, e), e;
    }
    return this.list.get(t);
  }
  /**
   * Initializes the library. It should be called at the start of the app after
   * initializing the scene, the renderer and the
   * camera. Additionally, if any component that need a raycaster is
   * used, the {@link raycaster} will need to be initialized.
   */
  init() {
    this.enabled = true, this._clock.start(), this.update();
  }
  /**
   * Disposes the memory of all the components and tools of this instance of
   * the library. A memory leak will be created if:
   *
   * - An instance of the library ends up out of scope and this function isn't
   * called. This is especially relevant in Single Page Applications (React,
   * Angular, Vue, etc).
   *
   * - Any of the objects of this instance (meshes, geometries, etc) is
   * referenced by a reference type (object or array).
   *
   * You can learn more about how Three.js handles memory leaks
   * [here](https://threejs.org/docs/#manual/en/introduction/How-to-dispose-of-objects).
   *
   */
  dispose() {
    this.enabled = false;
    for (const [s, t] of this.list)
      t.enabled = false, t.isDisposeable() && t.dispose();
    this._clock.stop(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  static setupBVH() {
    BufferGeometry.prototype.computeBoundsTree = rr, BufferGeometry.prototype.disposeBoundsTree = ar, Mesh.prototype.raycast = or;
  }
};
I(Fs, "release", "1.4.21");
var pi = Fs;
var Ar = class {
  constructor(s) {
    I(this, "_event");
    I(this, "_position", new Vector2());
    I(this, "onDisposed", new D());
    I(this, "updateMouseInfo", (s2) => {
      this._event = s2;
    });
    this.dom = s, this.setupEvents(true);
  }
  /**
   * The real position of the mouse of the Three.js canvas.
   */
  get position() {
    if (this._event) {
      const s = this.dom.getBoundingClientRect();
      this._position.x = this.getPositionX(s, this._event), this._position.y = this.getPositionY(s, this._event);
    }
    return this._position;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  getPositionY(s, t) {
    return -((t.clientY - s.top) / (s.bottom - s.top)) * 2 + 1;
  }
  getPositionX(s, t) {
    return (t.clientX - s.left) / (s.right - s.left) * 2 - 1;
  }
  setupEvents(s) {
    s ? this.dom.addEventListener("mousemove", this.updateMouseInfo) : this.dom.removeEventListener("mousemove", this.updateMouseInfo);
  }
};
var Fr = class {
  constructor(s, t) {
    I(this, "enabled", true);
    I(this, "components");
    I(this, "onDisposed", new D());
    I(this, "mouse");
    I(this, "three", new Raycaster());
    I(this, "world");
    const e = t.renderer;
    if (!e)
      throw new Error("A renderer is needed for the raycaster to work!");
    this.world = t, this.mouse = new Ar(e.three.domElement), this.components = s;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.mouse.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Throws a ray from the camera to the mouse or touch event point and returns
   * the first item found. This also takes into account the clipping planes
   * used by the renderer.
   *
   * @param items - the [meshes](https://threejs.org/docs/#api/en/objects/Mesh)
   * to query. If not provided, it will query all the meshes stored in
   * {@link Components.meshes}.
   */
  castRay(s = Array.from(this.world.meshes)) {
    if (!this.world)
      throw new Error("A world is needed to cast rays!");
    const t = this.world.camera.three;
    return this.three.setFromCamera(this.mouse.position, t), this.intersect(s);
  }
  castRayFromVector(s, t, e = Array.from(this.world.meshes)) {
    return this.three.set(s, t), this.intersect(e);
  }
  intersect(s = Array.from(this.world.meshes)) {
    const t = this.three.intersectObjects(s), e = this.filterClippingPlanes(t);
    return e.length > 0 ? e[0] : null;
  }
  filterClippingPlanes(s) {
    if (!this.world.renderer)
      throw new Error("Renderer not found!");
    const t = this.world.renderer.three;
    if (!t.clippingPlanes)
      return s;
    const e = t.clippingPlanes;
    return s.length <= 0 || !e || (e == null ? void 0 : e.length) <= 0 ? s : s.filter(
      (i) => e.every((o) => o.distanceToPoint(i.point) > 0)
    );
  }
};
var Os = class Os2 extends J {
  constructor(t) {
    super(t);
    I(this, "enabled", true);
    I(this, "list", /* @__PURE__ */ new Map());
    I(this, "onDisposed", new D());
    t.add(Os2.uuid, this);
  }
  get(t) {
    if (this.list.has(t.uuid))
      return this.list.get(t.uuid);
    const e = new Fr(this.components, t);
    return this.list.set(t.uuid, e), t.onDisposed.add(() => {
      this.delete(t);
    }), e;
  }
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
};
I(Os, "uuid", "d5d8bdf0-db25-4952-b951-b643af207ace");
var He = Os;
var Or = class extends _i {
  constructor(t) {
    super(t);
    I(this, "meshes", /* @__PURE__ */ new Set());
    I(this, "onAfterUpdate", new D());
    I(this, "onBeforeUpdate", new D());
    I(this, "isDisposing", false);
    I(this, "enabled", true);
    I(this, "uuid", ze.create());
    I(this, "name");
    I(this, "onDisposed", new D());
    I(this, "_scene");
    I(this, "_camera");
    I(this, "_renderer", null);
  }
  get scene() {
    if (!this._scene)
      throw new Error("No scene initialized!");
    return this._scene;
  }
  set scene(t) {
    this._scene = t, t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" });
  }
  get camera() {
    if (!this._camera)
      throw new Error("No camera initialized!");
    return this._camera;
  }
  set camera(t) {
    this._camera = t, t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" });
  }
  get renderer() {
    return this._renderer;
  }
  set renderer(t) {
    this._renderer = t, t && (t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" }));
  }
  update(t) {
    this.enabled && (!this._scene || !this._camera || (this.scene.currentWorld = this, this.camera.currentWorld = this, this.renderer && (this.renderer.currentWorld = this), this.onBeforeUpdate.trigger(), this.scene.isUpdateable() && this.scene.update(t), this.camera.isUpdateable() && this.camera.update(t), this.renderer && this.renderer.update(t), this.onAfterUpdate.trigger()));
  }
  dispose(t = true) {
    if (this.enabled = false, this.isDisposing = true, this.scene.onWorldChanged.trigger({ world: this, action: "removed" }), this.camera.onWorldChanged.trigger({ world: this, action: "removed" }), this.renderer && this.renderer.onWorldChanged.trigger({ world: this, action: "removed" }), t) {
      const e = this.components.get(zt);
      this.scene.dispose(), this.camera.isDisposeable() && this.camera.dispose(), this.renderer && this.renderer.dispose();
      for (const i of this.meshes)
        e.destroy(i);
      this.meshes.clear();
    }
    this._scene = null, this._camera = null, this._renderer = null, this.onDisposed.trigger();
  }
};
var ia = class extends hr {
  constructor(t) {
    super(t);
    I(this, "isSetup", false);
    I(this, "three");
    I(this, "onSetup", new D());
    I(this, "config", {
      directionalLight: {
        color: new Color("white"),
        intensity: 1.5,
        position: new Vector3(5, 10, 3)
      },
      ambientLight: {
        color: new Color("white"),
        intensity: 1
      }
    });
    this.three = new Scene(), this.three.background = new Color(2107698);
  }
  /** Creates a simple and nice default set up for the scene (e.g. lighting). */
  setup(t) {
    this.config = { ...this.config, ...t };
    const e = new DirectionalLight(
      this.config.directionalLight.color,
      this.config.directionalLight.intensity
    );
    e.position.copy(this.config.directionalLight.position);
    const i = new AmbientLight(
      this.config.ambientLight.color,
      this.config.ambientLight.intensity
    );
    this.three.add(e, i), this.isSetup = true, this.onSetup.trigger(this);
  }
};
var na = class extends lr {
  constructor(t, e, i) {
    super(t);
    I(this, "enabled", true);
    I(this, "container");
    I(this, "three");
    I(this, "_canvas");
    I(this, "_parameters");
    I(this, "_resizeObserver", null);
    I(this, "onContainerUpdated", new D());
    I(this, "_resizing", false);
    I(this, "resize", (t2) => {
      if (this._resizing)
        return;
      this._resizing = true, this.onContainerUpdated.trigger();
      const e2 = t2 ? t2.x : this.container.clientWidth, i2 = t2 ? t2.y : this.container.clientHeight;
      this.three.setSize(e2, i2), this.onResize.trigger(new Vector2(e2, i2)), this._resizing = false;
    });
    I(this, "resizeEvent", () => {
      this.resize();
    });
    I(this, "onContextLost", (t2) => {
      t2.preventDefault(), this.enabled = false;
    });
    I(this, "onContextBack", () => {
      this.three.setRenderTarget(null), this.three.dispose(), this.three = new WebGLRenderer({
        canvas: this._canvas,
        antialias: true,
        alpha: true,
        ...this._parameters
      }), this.enabled = true;
    });
    this.container = e, this._parameters = i, this.three = new WebGLRenderer({
      antialias: true,
      alpha: true,
      ...i
    }), this.three.setPixelRatio(Math.min(window.devicePixelRatio, 2)), this.setupRenderer(), this.setupEvents(true), this.resize(), this._canvas = this.three.domElement;
    const o = this.three.getContext(), { canvas: n } = o;
    n.addEventListener("webglcontextlost", this.onContextLost, false), n.addEventListener("webglcontextrestored", this.onContextBack, false);
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled || !this.currentWorld)
      return;
    this.onBeforeUpdate.trigger(this);
    const t = this.currentWorld.scene.three, e = this.currentWorld.camera.three;
    this.three.render(t, e), this.onAfterUpdate.trigger(this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false, this.setupEvents(false), this.three.domElement.remove(), this.three.dispose(), this.onResize.reset(), this.onAfterUpdate.reset(), this.onBeforeUpdate.reset(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /** {@link Resizeable.getSize}. */
  getSize() {
    return new Vector2(
      this.three.domElement.clientWidth,
      this.three.domElement.clientHeight
    );
  }
  setupEvents(t) {
    const e = this.three.domElement.parentElement;
    if (!e)
      throw new Error("This renderer needs to have an HTML container!");
    this._resizeObserver && (this._resizeObserver.disconnect(), this._resizeObserver = null), window.removeEventListener("resize", this.resizeEvent), t && (this._resizeObserver = new ResizeObserver(this.resizeEvent), this._resizeObserver.observe(e), window.addEventListener("resize", this.resizeEvent));
  }
  setupRenderer() {
    this.three.localClippingEnabled = true, this.container && this.container.appendChild(this.three.domElement), this.onContainerUpdated.trigger();
  }
};
var V = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
};
var P = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  OFFSET: 4,
  DOLLY: 8,
  ZOOM: 16,
  TOUCH_ROTATE: 32,
  TOUCH_TRUCK: 64,
  TOUCH_OFFSET: 128,
  TOUCH_DOLLY: 256,
  TOUCH_ZOOM: 512,
  TOUCH_DOLLY_TRUCK: 1024,
  TOUCH_DOLLY_OFFSET: 2048,
  TOUCH_DOLLY_ROTATE: 4096,
  TOUCH_ZOOM_TRUCK: 8192,
  TOUCH_ZOOM_OFFSET: 16384,
  TOUCH_ZOOM_ROTATE: 32768
});
var he = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function Zt(l) {
  return l.isPerspectiveCamera;
}
function bt(l) {
  return l.isOrthographicCamera;
}
var Ee = Math.PI * 2;
var on = Math.PI / 2;
var bn = 1e-5;
var Ne = Math.PI / 180;
function mt(l, s, t) {
  return Math.max(s, Math.min(t, l));
}
function X(l, s = bn) {
  return Math.abs(l) < s;
}
function k(l, s, t = bn) {
  return X(l - s, t);
}
function rn(l, s) {
  return Math.round(l / s) * s;
}
function Pe(l) {
  return isFinite(l) ? l : l < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function Le(l) {
  return Math.abs(l) < Number.MAX_VALUE ? l : l * (1 / 0);
}
function Es(l, s, t, e, i = 1 / 0, o) {
  e = Math.max(1e-4, e);
  const n = 2 / e, r = n * o, a = 1 / (1 + r + 0.48 * r * r + 0.235 * r * r * r);
  let c = l - s;
  const h = s, d = i * e;
  c = mt(c, -d, d), s = l - c;
  const E = (t.value + n * c) * o;
  t.value = (t.value - n * E) * a;
  let u = s + (c + E) * a;
  return h - l > 0 == u > h && (u = h, t.value = (u - h) / o), u;
}
function an(l, s, t, e, i = 1 / 0, o, n) {
  e = Math.max(1e-4, e);
  const r = 2 / e, a = r * o, c = 1 / (1 + a + 0.48 * a * a + 0.235 * a * a * a);
  let h = s.x, d = s.y, E = s.z, u = l.x - h, p = l.y - d, A = l.z - E;
  const m = h, C = d, R = E, F = i * e, f = F * F, T = u * u + p * p + A * A;
  if (T > f) {
    const B = Math.sqrt(T);
    u = u / B * F, p = p / B * F, A = A / B * F;
  }
  h = l.x - u, d = l.y - p, E = l.z - A;
  const O = (t.x + r * u) * o, S = (t.y + r * p) * o, _ = (t.z + r * A) * o;
  t.x = (t.x - r * O) * c, t.y = (t.y - r * S) * c, t.z = (t.z - r * _) * c, n.x = h + (u + O) * c, n.y = d + (p + S) * c, n.z = E + (A + _) * c;
  const N = m - l.x, L = C - l.y, M = R - l.z, y = n.x - m, x = n.y - C, b = n.z - R;
  return N * y + L * x + M * b > 0 && (n.x = m, n.y = C, n.z = R, t.x = (n.x - m) / o, t.y = (n.y - C) / o, t.z = (n.z - R) / o), n;
}
function Ks(l, s) {
  s.set(0, 0), l.forEach((t) => {
    s.x += t.clientX, s.y += t.clientY;
  }), s.x /= l.length, s.y /= l.length;
}
function Js2(l, s) {
  return bt(l) ? (console.warn(`${s} is not supported in OrthographicCamera`), true) : false;
}
var gr = class {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(s, t) {
    const e = this._listeners;
    e[s] === void 0 && (e[s] = []), e[s].indexOf(t) === -1 && e[s].push(t);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(s, t) {
    const e = this._listeners;
    return e[s] !== void 0 && e[s].indexOf(t) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(s, t) {
    const i = this._listeners[s];
    if (i !== void 0) {
      const o = i.indexOf(t);
      o !== -1 && i.splice(o, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(s) {
    if (!s) {
      this._listeners = {};
      return;
    }
    Array.isArray(this._listeners[s]) && (this._listeners[s].length = 0);
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(s) {
    const e = this._listeners[s.type];
    if (e !== void 0) {
      s.target = this;
      const i = e.slice(0);
      for (let o = 0, n = i.length; o < n; o++)
        i[o].call(this, s);
    }
  }
};
var Sr = "2.7.3";
var ds = 1 / 8;
var vn = typeof window < "u";
var _r = vn && /Mac/.test(navigator.platform);
var Nr = !(vn && "PointerEvent" in window);
var Y;
var cn;
var us;
var ti;
var lt;
var G;
var z;
var de;
var ye;
var gt;
var St;
var Qt;
var ln;
var hn;
var dt;
var we;
var ue;
var En;
var ei;
var dn;
var si;
var ii;
var Is;
var ot = class _ot extends gr {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(s) {
    Y = s.THREE, cn = Object.freeze(new Y.Vector3(0, 0, 0)), us = Object.freeze(new Y.Vector3(0, 1, 0)), ti = Object.freeze(new Y.Vector3(0, 0, 1)), lt = new Y.Vector2(), G = new Y.Vector3(), z = new Y.Vector3(), de = new Y.Vector3(), ye = new Y.Vector3(), gt = new Y.Vector3(), St = new Y.Vector3(), Qt = new Y.Vector3(), ln = new Y.Vector3(), hn = new Y.Vector3(), dt = new Y.Spherical(), we = new Y.Spherical(), ue = new Y.Box3(), En = new Y.Box3(), ei = new Y.Sphere(), dn = new Y.Quaternion(), si = new Y.Quaternion(), ii = new Y.Matrix4(), Is = new Y.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return P;
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(s, t) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = false, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = false, this.truckSpeed = 2, this.dollyToCursor = false, this.dragToOffset = false, this.verticalDragToForward = false, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = true, this._state = P.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = true, this._boundaryEnclosesCamera = false, this._needsUpdate = true, this._updatedLastTime = false, this._elementRect = new DOMRect(), this._isDragging = false, this._dragNeedsUpdate = true, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._isUserControllingOffset = false, this._isUserControllingZoom = false, this._lastDollyDirection = he.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new Y.Vector3(), this._focalOffsetVelocity = new Y.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (f, T, O) => {
      let S, _;
      if (Zt(this._camera)) {
        const N = G.copy(this._camera.position).sub(this._target), L = this._camera.getEffectiveFOV() * Ne, M = N.length() * Math.tan(L * 0.5);
        S = this.truckSpeed * f * M / this._elementRect.height, _ = this.truckSpeed * T * M / this._elementRect.height;
      } else if (bt(this._camera)) {
        const N = this._camera;
        S = f * (N.right - N.left) / N.zoom / this._elementRect.width, _ = T * (N.top - N.bottom) / N.zoom / this._elementRect.height;
      } else
        return;
      this.verticalDragToForward ? (O ? this.setFocalOffset(this._focalOffsetEnd.x + S, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) : this.truck(S, 0, true), this.forward(-_, true)) : O ? this.setFocalOffset(this._focalOffsetEnd.x + S, this._focalOffsetEnd.y + _, this._focalOffsetEnd.z, true) : this.truck(S, _, true);
    }, this._rotateInternal = (f, T) => {
      const O = Ee * this.azimuthRotateSpeed * f / this._elementRect.height, S = Ee * this.polarRotateSpeed * T / this._elementRect.height;
      this.rotate(O, S, true);
    }, this._dollyInternal = (f, T, O) => {
      const S = Math.pow(0.95, -f * this.dollySpeed), _ = this._sphericalEnd.radius, N = this._sphericalEnd.radius * S, L = mt(N, this.minDistance, this.maxDistance), M = L - N;
      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(N, true) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(M, true), this._dollyToNoClamp(L, true)) : this._dollyToNoClamp(L, true), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? N : L) - _, this._dollyControlCoord.set(T, O)), this._lastDollyDirection = Math.sign(-f);
    }, this._zoomInternal = (f, T, O) => {
      const S = Math.pow(0.95, f * this.dollySpeed), _ = this._zoom, N = this._zoom * S;
      this.zoomTo(N, true), this.dollyToCursor && (this._changedZoom += N - _, this._dollyControlCoord.set(T, O));
    }, typeof Y > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = s, this._yAxisUpSpace = new Y.Quaternion().setFromUnitVectors(this._camera.up, us), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = P.NONE, this._target = new Y.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new Y.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new Y.Spherical().setFromVector3(G.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [
      new Y.Vector3(),
      new Y.Vector3(),
      new Y.Vector3(),
      new Y.Vector3()
    ], this._updateNearPlaneCorners(), this._boundary = new Y.Box3(new Y.Vector3(-1 / 0, -1 / 0, -1 / 0), new Y.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new Y.Vector2(), this.mouseButtons = {
      left: P.ROTATE,
      middle: P.DOLLY,
      right: P.TRUCK,
      wheel: Zt(this._camera) ? P.DOLLY : bt(this._camera) ? P.ZOOM : P.NONE
    }, this.touches = {
      one: P.TOUCH_ROTATE,
      two: Zt(this._camera) ? P.TOUCH_DOLLY_TRUCK : bt(this._camera) ? P.TOUCH_ZOOM_TRUCK : P.NONE,
      three: P.TOUCH_TRUCK
    };
    const e = new Y.Vector2(), i = new Y.Vector2(), o = new Y.Vector2(), n = (f) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const S = this._domElement.getBoundingClientRect(), _ = f.clientX / S.width, N = f.clientY / S.height;
        if (_ < this._interactiveArea.left || _ > this._interactiveArea.right || N < this._interactiveArea.top || N > this._interactiveArea.bottom)
          return;
      }
      const T = f.pointerType !== "mouse" ? null : (f.buttons & V.LEFT) === V.LEFT ? V.LEFT : (f.buttons & V.MIDDLE) === V.MIDDLE ? V.MIDDLE : (f.buttons & V.RIGHT) === V.RIGHT ? V.RIGHT : null;
      if (T !== null) {
        const S = this._findPointerByMouseButton(T);
        S && this._disposePointer(S);
      }
      if ((f.buttons & V.LEFT) === V.LEFT && this._lockedPointer)
        return;
      const O = {
        pointerId: f.pointerId,
        clientX: f.clientX,
        clientY: f.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: T
      };
      this._activePointers.push(O), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", h), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.addEventListener("pointerup", h), this._isDragging = true, A(f);
    }, r = (f) => {
      if (!this._enabled || !this._domElement || this._lockedPointer)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const S = this._domElement.getBoundingClientRect(), _ = f.clientX / S.width, N = f.clientY / S.height;
        if (_ < this._interactiveArea.left || _ > this._interactiveArea.right || N < this._interactiveArea.top || N > this._interactiveArea.bottom)
          return;
      }
      const T = (f.buttons & V.LEFT) === V.LEFT ? V.LEFT : (f.buttons & V.MIDDLE) === V.MIDDLE ? V.MIDDLE : (f.buttons & V.RIGHT) === V.RIGHT ? V.RIGHT : null;
      if (T !== null) {
        const S = this._findPointerByMouseButton(T);
        S && this._disposePointer(S);
      }
      const O = {
        pointerId: 1,
        clientX: f.clientX,
        clientY: f.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: (f.buttons & V.LEFT) === V.LEFT ? V.LEFT : (f.buttons & V.MIDDLE) === V.LEFT ? V.MIDDLE : (f.buttons & V.RIGHT) === V.LEFT ? V.RIGHT : null
      };
      this._activePointers.push(O), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("mouseup", d), this._domElement.ownerDocument.addEventListener("mousemove", c), this._domElement.ownerDocument.addEventListener("mouseup", d), this._isDragging = true, A(f);
    }, a = (f) => {
      f.cancelable && f.preventDefault();
      const T = f.pointerId, O = this._lockedPointer || this._findPointerById(T);
      if (O) {
        if (O.clientX = f.clientX, O.clientY = f.clientY, O.deltaX = f.movementX, O.deltaY = f.movementY, this._state = 0, f.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          (!this._isDragging && this._lockedPointer || this._isDragging && (f.buttons & V.LEFT) === V.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (f.buttons & V.MIDDLE) === V.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (f.buttons & V.RIGHT) === V.RIGHT && (this._state = this._state | this.mouseButtons.right);
        m();
      }
    }, c = (f) => {
      const T = this._lockedPointer || this._findPointerById(1);
      T && (T.clientX = f.clientX, T.clientY = f.clientY, T.deltaX = f.movementX, T.deltaY = f.movementY, this._state = 0, (this._lockedPointer || (f.buttons & V.LEFT) === V.LEFT) && (this._state = this._state | this.mouseButtons.left), (f.buttons & V.MIDDLE) === V.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (f.buttons & V.RIGHT) === V.RIGHT && (this._state = this._state | this.mouseButtons.right), m());
    }, h = (f) => {
      const T = this._findPointerById(f.pointerId);
      if (!(T && T === this._lockedPointer)) {
        if (T && this._disposePointer(T), f.pointerType === "touch")
          switch (this._activePointers.length) {
            case 0:
              this._state = P.NONE;
              break;
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          this._state = P.NONE;
        C();
      }
    }, d = () => {
      const f = this._findPointerById(1);
      f && f === this._lockedPointer || (f && this._disposePointer(f), this._state = P.NONE, C());
    };
    let E = -1;
    const u = (f) => {
      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === P.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const N = this._domElement.getBoundingClientRect(), L = f.clientX / N.width, M = f.clientY / N.height;
        if (L < this._interactiveArea.left || L > this._interactiveArea.right || M < this._interactiveArea.top || M > this._interactiveArea.bottom)
          return;
      }
      if (f.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === P.ROTATE || this.mouseButtons.wheel === P.TRUCK) {
        const N = performance.now();
        E - N < 1e3 && this._getClientRect(this._elementRect), E = N;
      }
      const T = _r ? -1 : -3, O = f.deltaMode === 1 ? f.deltaY / T : f.deltaY / (T * 10), S = this.dollyToCursor ? (f.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, _ = this.dollyToCursor ? (f.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case P.ROTATE: {
          this._rotateInternal(f.deltaX, f.deltaY), this._isUserControllingRotate = true;
          break;
        }
        case P.TRUCK: {
          this._truckInternal(f.deltaX, f.deltaY, false), this._isUserControllingTruck = true;
          break;
        }
        case P.OFFSET: {
          this._truckInternal(f.deltaX, f.deltaY, true), this._isUserControllingOffset = true;
          break;
        }
        case P.DOLLY: {
          this._dollyInternal(-O, S, _), this._isUserControllingDolly = true;
          break;
        }
        case P.ZOOM: {
          this._zoomInternal(-O, S, _), this._isUserControllingZoom = true;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    }, p = (f) => {
      if (!(!this._domElement || !this._enabled)) {
        if (this.mouseButtons.right === _ot.ACTION.NONE) {
          const T = f instanceof PointerEvent ? f.pointerId : (f instanceof MouseEvent, 0), O = this._findPointerById(T);
          O && this._disposePointer(O), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", h), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("mouseup", d);
          return;
        }
        f.preventDefault();
      }
    }, A = (f) => {
      if (!this._enabled)
        return;
      if (Ks(this._activePointers, lt), this._getClientRect(this._elementRect), e.copy(lt), i.copy(lt), this._activePointers.length >= 2) {
        const O = lt.x - this._activePointers[1].clientX, S = lt.y - this._activePointers[1].clientY, _ = Math.sqrt(O * O + S * S);
        o.set(0, _);
        const N = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, L = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        i.set(N, L);
      }
      if (this._state = 0, !f)
        this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
      else if ("pointerType" in f && f.pointerType === "touch")
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      else
        !this._lockedPointer && (f.buttons & V.LEFT) === V.LEFT && (this._state = this._state | this.mouseButtons.left), (f.buttons & V.MIDDLE) === V.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (f.buttons & V.RIGHT) === V.RIGHT && (this._state = this._state | this.mouseButtons.right);
      ((this._state & P.ROTATE) === P.ROTATE || (this._state & P.TOUCH_ROTATE) === P.TOUCH_ROTATE || (this._state & P.TOUCH_DOLLY_ROTATE) === P.TOUCH_DOLLY_ROTATE || (this._state & P.TOUCH_ZOOM_ROTATE) === P.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & P.TRUCK) === P.TRUCK || (this._state & P.TOUCH_TRUCK) === P.TOUCH_TRUCK || (this._state & P.TOUCH_DOLLY_TRUCK) === P.TOUCH_DOLLY_TRUCK || (this._state & P.TOUCH_ZOOM_TRUCK) === P.TOUCH_ZOOM_TRUCK) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & P.DOLLY) === P.DOLLY || (this._state & P.TOUCH_DOLLY) === P.TOUCH_DOLLY || (this._state & P.TOUCH_DOLLY_TRUCK) === P.TOUCH_DOLLY_TRUCK || (this._state & P.TOUCH_DOLLY_OFFSET) === P.TOUCH_DOLLY_OFFSET || (this._state & P.TOUCH_DOLLY_ROTATE) === P.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & P.ZOOM) === P.ZOOM || (this._state & P.TOUCH_ZOOM) === P.TOUCH_ZOOM || (this._state & P.TOUCH_ZOOM_TRUCK) === P.TOUCH_ZOOM_TRUCK || (this._state & P.TOUCH_ZOOM_OFFSET) === P.TOUCH_ZOOM_OFFSET || (this._state & P.TOUCH_ZOOM_ROTATE) === P.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & P.OFFSET) === P.OFFSET || (this._state & P.TOUCH_OFFSET) === P.TOUCH_OFFSET || (this._state & P.TOUCH_DOLLY_OFFSET) === P.TOUCH_DOLLY_OFFSET || (this._state & P.TOUCH_ZOOM_OFFSET) === P.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
    }, m = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = false, Ks(this._activePointers, lt);
      const T = this._domElement && document.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, O = T ? -T.deltaX : i.x - lt.x, S = T ? -T.deltaY : i.y - lt.y;
      if (i.copy(lt), ((this._state & P.ROTATE) === P.ROTATE || (this._state & P.TOUCH_ROTATE) === P.TOUCH_ROTATE || (this._state & P.TOUCH_DOLLY_ROTATE) === P.TOUCH_DOLLY_ROTATE || (this._state & P.TOUCH_ZOOM_ROTATE) === P.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(O, S), this._isUserControllingRotate = true), (this._state & P.DOLLY) === P.DOLLY || (this._state & P.ZOOM) === P.ZOOM) {
        const _ = this.dollyToCursor ? (e.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, N = this.dollyToCursor ? (e.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, L = this.dollyDragInverted ? -1 : 1;
        (this._state & P.DOLLY) === P.DOLLY ? (this._dollyInternal(L * S * ds, _, N), this._isUserControllingDolly = true) : (this._zoomInternal(L * S * ds, _, N), this._isUserControllingZoom = true);
      }
      if ((this._state & P.TOUCH_DOLLY) === P.TOUCH_DOLLY || (this._state & P.TOUCH_ZOOM) === P.TOUCH_ZOOM || (this._state & P.TOUCH_DOLLY_TRUCK) === P.TOUCH_DOLLY_TRUCK || (this._state & P.TOUCH_ZOOM_TRUCK) === P.TOUCH_ZOOM_TRUCK || (this._state & P.TOUCH_DOLLY_OFFSET) === P.TOUCH_DOLLY_OFFSET || (this._state & P.TOUCH_ZOOM_OFFSET) === P.TOUCH_ZOOM_OFFSET || (this._state & P.TOUCH_DOLLY_ROTATE) === P.TOUCH_DOLLY_ROTATE || (this._state & P.TOUCH_ZOOM_ROTATE) === P.TOUCH_ZOOM_ROTATE) {
        const _ = lt.x - this._activePointers[1].clientX, N = lt.y - this._activePointers[1].clientY, L = Math.sqrt(_ * _ + N * N), M = o.y - L;
        o.set(0, L);
        const y = this.dollyToCursor ? (i.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, x = this.dollyToCursor ? (i.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & P.TOUCH_DOLLY) === P.TOUCH_DOLLY || (this._state & P.TOUCH_DOLLY_ROTATE) === P.TOUCH_DOLLY_ROTATE || (this._state & P.TOUCH_DOLLY_TRUCK) === P.TOUCH_DOLLY_TRUCK || (this._state & P.TOUCH_DOLLY_OFFSET) === P.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(M * ds, y, x), this._isUserControllingDolly = true) : (this._zoomInternal(M * ds, y, x), this._isUserControllingZoom = true);
      }
      ((this._state & P.TRUCK) === P.TRUCK || (this._state & P.TOUCH_TRUCK) === P.TOUCH_TRUCK || (this._state & P.TOUCH_DOLLY_TRUCK) === P.TOUCH_DOLLY_TRUCK || (this._state & P.TOUCH_ZOOM_TRUCK) === P.TOUCH_ZOOM_TRUCK) && (this._truckInternal(O, S, false), this._isUserControllingTruck = true), ((this._state & P.OFFSET) === P.OFFSET || (this._state & P.TOUCH_OFFSET) === P.TOUCH_OFFSET || (this._state & P.TOUCH_DOLLY_OFFSET) === P.TOUCH_DOLLY_OFFSET || (this._state & P.TOUCH_ZOOM_OFFSET) === P.TOUCH_ZOOM_OFFSET) && (this._truckInternal(O, S, true), this._isUserControllingOffset = true), this.dispatchEvent({ type: "control" });
    }, C = () => {
      Ks(this._activePointers, lt), i.copy(lt), this._dragNeedsUpdate = false, (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = false), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("pointerup", h), this._domElement.ownerDocument.removeEventListener("mouseup", d), this.dispatchEvent({ type: "controlend" }));
    };
    this.lockPointer = () => {
      !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", h), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", R), this._domElement.ownerDocument.addEventListener("pointerlockerror", F), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.addEventListener("pointerup", h), A());
    }, this.unlockPointer = () => {
      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), document.exitPointerLock(), this.cancel(), this._domElement && (this._domElement.ownerDocument.removeEventListener("pointerlockchange", R), this._domElement.ownerDocument.removeEventListener("pointerlockerror", F));
    };
    const R = () => {
      this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer();
    }, F = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (f) => {
      this._domElement = f, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", n), Nr && this._domElement.addEventListener("mousedown", r), this._domElement.addEventListener("pointercancel", h), this._domElement.addEventListener("wheel", u, { passive: false }), this._domElement.addEventListener("contextmenu", p);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", n), this._domElement.removeEventListener("mousedown", r), this._domElement.removeEventListener("pointercancel", h), this._domElement.removeEventListener("wheel", u, { passive: false }), this._domElement.removeEventListener("contextmenu", p), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("pointerup", h), this._domElement.ownerDocument.removeEventListener("mouseup", d), this._domElement.ownerDocument.removeEventListener("pointerlockchange", R), this._domElement.ownerDocument.removeEventListener("pointerlockerror", F));
    }, this.cancel = () => {
      this._state !== P.NONE && (this._state = P.NONE, this._activePointers.length = 0, C());
    }, t && this.connect(t), this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(s) {
    this._camera = s, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(s) {
    this._enabled = s, this._domElement && (s ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(s) {
    this._spherical.radius === s && this._sphericalEnd.radius === s || (this._spherical.radius = s, this._sphericalEnd.radius = s, this._needsUpdate = true);
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(s) {
    this._spherical.theta === s && this._sphericalEnd.theta === s || (this._spherical.theta = s, this._sphericalEnd.theta = s, this._needsUpdate = true);
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(s) {
    this._spherical.phi === s && this._sphericalEnd.phi === s || (this._spherical.phi = s, this._sphericalEnd.phi = s, this._needsUpdate = true);
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(s) {
    this._boundaryEnclosesCamera = s, this._needsUpdate = true;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(s) {
    this._interactiveArea.width = mt(s.width, 0, 1), this._interactiveArea.height = mt(s.height, 0, 1), this._interactiveArea.x = mt(s.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = mt(s.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches.  |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera.  |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` . |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(s, t) {
    super.addEventListener(s, t);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(s, t) {
    super.removeEventListener(s, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(s, t, e = false) {
    return this.rotateTo(this._sphericalEnd.theta + s, this._sphericalEnd.phi + t, e);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(s, t = false) {
    return this.rotateTo(s, this._sphericalEnd.phi, t);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(s, t = false) {
    return this.rotateTo(this._sphericalEnd.theta, s, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0
   *         \
   * 90 -----+----- -90
   *           \
   *           180
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0                     |
   * | left      | 90 (`Math.PI / 2`)    |
   * | right     | -90 (`- Math.PI / 2`) |
   * | back      | 180 (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180
   *      |
   *      90
   *      |
   *      0
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180 (`Math.PI`)       |
   * | horizontal from view | 90 (`Math.PI / 2`)    |
   * | bottom/floor         | 0                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(s, t, e = false) {
    this._isUserControllingRotate = false;
    const i = mt(s, this.minAzimuthAngle, this.maxAzimuthAngle), o = mt(t, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = i, this._sphericalEnd.phi = o, this._sphericalEnd.makeSafe(), this._needsUpdate = true, e || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    const n = !e || k(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && k(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(s, t = false) {
    return this.dollyTo(this._sphericalEnd.radius - s, t);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(s, t = false) {
    return this._isUserControllingDolly = false, this._lastDollyDirection = he.NONE, this._changedDolly = 0, this._dollyToNoClamp(mt(s, this.minDistance, this.maxDistance), t);
  }
  _dollyToNoClamp(s, t = false) {
    const e = this._sphericalEnd.radius;
    if (this.colliderMeshes.length >= 1) {
      const n = this._collisionTest(), r = k(n, this._spherical.radius);
      if (!(e > s) && r)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(s, n);
    } else
      this._sphericalEnd.radius = s;
    this._needsUpdate = true, t || (this._spherical.radius = this._sphericalEnd.radius);
    const o = !t || k(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(o);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(s, t = false) {
    this._targetEnd.add(this._getCameraDirection(ye).multiplyScalar(s)), t || this._target.copy(this._targetEnd);
    const e = !t || k(this._target.x, this._targetEnd.x, this.restThreshold) && k(this._target.y, this._targetEnd.y, this.restThreshold) && k(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(e);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(s, t = false) {
    return this.zoomTo(this._zoomEnd + s, t);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(s, t = false) {
    this._isUserControllingZoom = false, this._zoomEnd = mt(s, this.minZoom, this.maxZoom), this._needsUpdate = true, t || (this._zoom = this._zoomEnd);
    const e = !t || k(this._zoom, this._zoomEnd, this.restThreshold);
    return this._changedZoom = 0, this._createOnRestPromise(e);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(s, t, e = false) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(s, t, e);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(s, t, e = false) {
    this._camera.updateMatrix(), gt.setFromMatrixColumn(this._camera.matrix, 0), St.setFromMatrixColumn(this._camera.matrix, 1), gt.multiplyScalar(s), St.multiplyScalar(-t);
    const i = G.copy(gt).add(St), o = z.copy(this._targetEnd).add(i);
    return this.moveTo(o.x, o.y, o.z, e);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(s, t = false) {
    G.setFromMatrixColumn(this._camera.matrix, 0), G.crossVectors(this._camera.up, G), G.multiplyScalar(s);
    const e = z.copy(this._targetEnd).add(G);
    return this.moveTo(e.x, e.y, e.z, t);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(s, t = false) {
    return G.copy(this._camera.up).multiplyScalar(s), this.moveTo(this._targetEnd.x + G.x, this._targetEnd.y + G.y, this._targetEnd.z + G.z, t);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(s, t, e, i = false) {
    this._isUserControllingTruck = false;
    const o = G.set(s, t, e).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, o, this.boundaryFriction), this._needsUpdate = true, i || this._target.copy(this._targetEnd);
    const n = !i || k(this._target.x, this._targetEnd.x, this.restThreshold) && k(this._target.y, this._targetEnd.y, this.restThreshold) && k(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(s, t, e, i = false) {
    const r = G.set(s, t, e).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius);
    return this.setPosition(r.x, r.y, r.z, i);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(s, t, { cover: e = false, paddingLeft: i = 0, paddingRight: o = 0, paddingBottom: n = 0, paddingTop: r = 0 } = {}) {
    const a = [], c = s.isBox3 ? ue.copy(s) : ue.setFromObject(s);
    c.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    const h = rn(this._sphericalEnd.theta, on), d = rn(this._sphericalEnd.phi, on);
    a.push(this.rotateTo(h, d, t));
    const E = G.setFromSpherical(this._sphericalEnd).normalize(), u = dn.setFromUnitVectors(E, ti), p = k(Math.abs(E.y), 1);
    p && u.multiply(si.setFromAxisAngle(us, h)), u.multiply(this._yAxisUpSpaceInverse);
    const A = En.makeEmpty();
    z.copy(c.min).applyQuaternion(u), A.expandByPoint(z), z.copy(c.min).setX(c.max.x).applyQuaternion(u), A.expandByPoint(z), z.copy(c.min).setY(c.max.y).applyQuaternion(u), A.expandByPoint(z), z.copy(c.max).setZ(c.min.z).applyQuaternion(u), A.expandByPoint(z), z.copy(c.min).setZ(c.max.z).applyQuaternion(u), A.expandByPoint(z), z.copy(c.max).setY(c.min.y).applyQuaternion(u), A.expandByPoint(z), z.copy(c.max).setX(c.min.x).applyQuaternion(u), A.expandByPoint(z), z.copy(c.max).applyQuaternion(u), A.expandByPoint(z), A.min.x -= i, A.min.y -= n, A.max.x += o, A.max.y += r, u.setFromUnitVectors(ti, E), p && u.premultiply(si.invert()), u.premultiply(this._yAxisUpSpace);
    const m = A.getSize(G), C = A.getCenter(z).applyQuaternion(u);
    if (Zt(this._camera)) {
      const R = this.getDistanceToFitBox(m.x, m.y, m.z, e);
      a.push(this.moveTo(C.x, C.y, C.z, t)), a.push(this.dollyTo(R, t)), a.push(this.setFocalOffset(0, 0, 0, t));
    } else if (bt(this._camera)) {
      const R = this._camera, F = R.right - R.left, f = R.top - R.bottom, T = e ? Math.max(F / m.x, f / m.y) : Math.min(F / m.x, f / m.y);
      a.push(this.moveTo(C.x, C.y, C.z, t)), a.push(this.zoomTo(T, t)), a.push(this.setFocalOffset(0, 0, 0, t));
    }
    return Promise.all(a);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(s, t) {
    const e = [], o = s instanceof Y.Sphere ? ei.copy(s) : _ot.createBoundingSphere(s, ei);
    if (e.push(this.moveTo(o.center.x, o.center.y, o.center.z, t)), Zt(this._camera)) {
      const n = this.getDistanceToFitSphere(o.radius);
      e.push(this.dollyTo(n, t));
    } else if (bt(this._camera)) {
      const n = this._camera.right - this._camera.left, r = this._camera.top - this._camera.bottom, a = 2 * o.radius, c = Math.min(n / a, r / a);
      e.push(this.zoomTo(c, t));
    }
    return e.push(this.setFocalOffset(0, 0, 0, t)), Promise.all(e);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(s, t, e, i, o, n, r = false) {
    this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._lastDollyDirection = he.NONE, this._changedDolly = 0;
    const a = z.set(i, o, n), c = G.set(s, t, e);
    this._targetEnd.copy(a), this._sphericalEnd.setFromVector3(c.sub(a).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = true, r || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const h = !r || k(this._target.x, this._targetEnd.x, this.restThreshold) && k(this._target.y, this._targetEnd.y, this.restThreshold) && k(this._target.z, this._targetEnd.z, this.restThreshold) && k(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && k(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && k(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(h);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(s, t, e, i, o, n, r, a, c, h, d, E, u, p = false) {
    this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._lastDollyDirection = he.NONE, this._changedDolly = 0;
    const A = G.set(i, o, n), m = z.set(s, t, e);
    dt.setFromVector3(m.sub(A).applyQuaternion(this._yAxisUpSpace));
    const C = de.set(h, d, E), R = z.set(r, a, c);
    we.setFromVector3(R.sub(C).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(A.lerp(C, u));
    const F = we.theta - dt.theta, f = we.phi - dt.phi, T = we.radius - dt.radius;
    this._sphericalEnd.set(dt.radius + T * u, dt.phi + f * u, dt.theta + F * u), this.normalizeRotations(), this._needsUpdate = true, p || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const O = !p || k(this._target.x, this._targetEnd.x, this.restThreshold) && k(this._target.y, this._targetEnd.y, this.restThreshold) && k(this._target.z, this._targetEnd.z, this.restThreshold) && k(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && k(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && k(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(O);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(s, t, e, i = false) {
    return this.setLookAt(s, t, e, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, i);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(s, t, e, i = false) {
    const o = this.getPosition(G), n = this.setLookAt(o.x, o.y, o.z, s, t, e, i);
    return this._sphericalEnd.phi = mt(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), n;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(s, t, e, i = false) {
    this._isUserControllingOffset = false, this._focalOffsetEnd.set(s, t, e), this._needsUpdate = true, i || this._focalOffset.copy(this._focalOffsetEnd);
    const o = !i || k(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && k(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && k(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(o);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(s, t, e) {
    this._camera.updateMatrixWorld(), gt.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), St.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), Qt.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const i = G.set(s, t, e), o = i.distanceTo(this._camera.position), n = i.sub(this._camera.position);
    gt.multiplyScalar(n.x), St.multiplyScalar(n.y), Qt.multiplyScalar(n.z), G.copy(gt).add(St).add(Qt), G.z = G.z + o, this.dollyTo(o, false), this.setFocalOffset(-G.x, G.y, -G.z, false), this.moveTo(s, t, e, false);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(s) {
    if (!s) {
      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = true;
      return;
    }
    this._boundary.copy(s), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = true;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(s, t, e, i) {
    if (s === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new Y.Vector4(), typeof s == "number" ? this._viewport.set(s, t, e, i) : this._viewport.copy(s);
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(s, t, e, i = false) {
    if (Js2(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const o = s / t, n = this._camera.getEffectiveFOV() * Ne, r = this._camera.aspect;
    return ((i ? o > r : o < r) ? t : s / r) * 0.5 / Math.tan(n * 0.5) + e * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(s) {
    if (Js2(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const t = this._camera.getEffectiveFOV() * Ne, e = Math.atan(Math.tan(t * 0.5) * this._camera.aspect) * 2, i = 1 < this._camera.aspect ? t : e;
    return s / Math.sin(i * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(s, t = true) {
    return (s && s.isVector3 ? s : new Y.Vector3()).copy(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(s, t = true) {
    return (s && s.isVector3 ? s : new Y.Vector3()).setFromSpherical(t ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(s, t = true) {
    return (s && s instanceof Y.Spherical ? s : new Y.Spherical()).copy(t ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(s, t = true) {
    return (s && s.isVector3 ? s : new Y.Vector3()).copy(t ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % Ee, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += Ee), this._spherical.theta += Ee * Math.round((this._sphericalEnd.theta - this._spherical.theta) / Ee);
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(s = false) {
    if (!k(this._camera.up.x, this._cameraUp0.x) || !k(this._camera.up.y, this._cameraUp0.y) || !k(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const e = this.getPosition(G);
      this.updateCameraUp(), this.setPosition(e.x, e.y, e.z);
    }
    const t = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, s),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, s),
      this.zoomTo(this._zoom0, s)
    ];
    return Promise.all(t);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, us), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const s = G.subVectors(this._target, this._camera.position).normalize(), t = z.crossVectors(s, this._camera.up);
    this._camera.up.crossVectors(t, s).normalize(), this._camera.updateMatrixWorld();
    const e = this.getPosition(G);
    this.updateCameraUp(), this.setPosition(e.x, e.y, e.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(s) {
    const t = this._sphericalEnd.theta - this._spherical.theta, e = this._sphericalEnd.phi - this._spherical.phi, i = this._sphericalEnd.radius - this._spherical.radius, o = ln.subVectors(this._targetEnd, this._target), n = hn.subVectors(this._focalOffsetEnd, this._focalOffset), r = this._zoomEnd - this._zoom;
    if (X(t))
      this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
    else {
      const d = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = Es(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, d, 1 / 0, s), this._needsUpdate = true;
    }
    if (X(e))
      this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
    else {
      const d = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = Es(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, d, 1 / 0, s), this._needsUpdate = true;
    }
    if (X(i))
      this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
    else {
      const d = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = Es(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, d, this.maxSpeed, s), this._needsUpdate = true;
    }
    if (X(o.x) && X(o.y) && X(o.z))
      this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
    else {
      const d = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      an(this._target, this._targetEnd, this._targetVelocity, d, this.maxSpeed, s, this._target), this._needsUpdate = true;
    }
    if (X(n.x) && X(n.y) && X(n.z))
      this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
    else {
      const d = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      an(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, d, this.maxSpeed, s, this._focalOffset), this._needsUpdate = true;
    }
    if (X(r))
      this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
    else {
      const d = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = Es(this._zoom, this._zoomEnd, this._zoomVelocity, d, 1 / 0, s);
    }
    if (this.dollyToCursor) {
      if (Zt(this._camera) && this._changedDolly !== 0) {
        const d = this._spherical.radius - this._lastDistance, E = this._camera, u = this._getCameraDirection(ye), p = G.copy(u).cross(E.up).normalize();
        p.lengthSq() === 0 && (p.x = 1);
        const A = z.crossVectors(p, u), m = this._sphericalEnd.radius * Math.tan(E.getEffectiveFOV() * Ne * 0.5), R = (this._sphericalEnd.radius - d - this._sphericalEnd.radius) / this._sphericalEnd.radius, F = de.copy(this._targetEnd).add(p.multiplyScalar(this._dollyControlCoord.x * m * E.aspect)).add(A.multiplyScalar(this._dollyControlCoord.y * m)), f = G.copy(this._targetEnd).lerp(F, R), T = this._lastDollyDirection === he.IN && this._spherical.radius <= this.minDistance, O = this._lastDollyDirection === he.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (T || O)) {
          this._sphericalEnd.radius -= d, this._spherical.radius -= d;
          const _ = z.copy(u).multiplyScalar(-d);
          f.add(_);
        }
        this._boundary.clampPoint(f, f);
        const S = z.subVectors(f, this._targetEnd);
        this._targetEnd.copy(f), this._target.add(S), this._changedDolly -= d, X(this._changedDolly) && (this._changedDolly = 0);
      } else if (bt(this._camera) && this._changedZoom !== 0) {
        const d = this._zoom - this._lastZoom, E = this._camera, u = G.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (E.near + E.far) / (E.near - E.far)).unproject(E), p = z.set(0, 0, -1).applyQuaternion(E.quaternion), A = de.copy(u).add(p.multiplyScalar(-u.dot(E.up))), C = -(this._zoom - d - this._zoom) / this._zoom, R = this._getCameraDirection(ye), F = this._targetEnd.dot(R), f = G.copy(this._targetEnd).lerp(A, C), T = f.dot(R), O = R.multiplyScalar(T - F);
        f.sub(O), this._boundary.clampPoint(f, f);
        const S = z.subVectors(f, this._targetEnd);
        this._targetEnd.copy(f), this._target.add(S), this._changedZoom -= d, X(this._changedZoom) && (this._changedZoom = 0);
      }
    }
    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true), this._dragNeedsUpdate = true;
    const a = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, a), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!X(this._focalOffset.x) || !X(this._focalOffset.y) || !X(this._focalOffset.z)) && (this._camera.updateMatrixWorld(), gt.setFromMatrixColumn(this._camera.matrix, 0), St.setFromMatrixColumn(this._camera.matrix, 1), Qt.setFromMatrixColumn(this._camera.matrix, 2), gt.multiplyScalar(this._focalOffset.x), St.multiplyScalar(-this._focalOffset.y), Qt.multiplyScalar(this._focalOffset.z), G.copy(gt).add(St).add(Qt), this._camera.position.add(G)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), G.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const h = this._needsUpdate;
    return h && !this._updatedLastTime ? (this._hasRested = false, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : h ? (this.dispatchEvent({ type: "update" }), X(t, this.restThreshold) && X(e, this.restThreshold) && X(i, this.restThreshold) && X(o.x, this.restThreshold) && X(o.y, this.restThreshold) && X(o.z, this.restThreshold) && X(n.x, this.restThreshold) && X(n.y, this.restThreshold) && X(n.z, this.restThreshold) && X(r, this.restThreshold) && !this._hasRested && (this._hasRested = true, this.dispatchEvent({ type: "rest" }))) : !h && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = h, this._needsUpdate = false, h;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: Pe(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: Pe(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: Pe(this.maxPolarAngle),
      minAzimuthAngle: Pe(this.minAzimuthAngle),
      maxAzimuthAngle: Pe(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      verticalDragToForward: this.verticalDragToForward,
      target: this._targetEnd.toArray(),
      position: G.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(s, t = false) {
    const e = JSON.parse(s);
    this.enabled = e.enabled, this.minDistance = e.minDistance, this.maxDistance = Le(e.maxDistance), this.minZoom = e.minZoom, this.maxZoom = Le(e.maxZoom), this.minPolarAngle = e.minPolarAngle, this.maxPolarAngle = Le(e.maxPolarAngle), this.minAzimuthAngle = Le(e.minAzimuthAngle), this.maxAzimuthAngle = Le(e.maxAzimuthAngle), this.smoothTime = e.smoothTime, this.draggingSmoothTime = e.draggingSmoothTime, this.dollySpeed = e.dollySpeed, this.truckSpeed = e.truckSpeed, this.dollyToCursor = e.dollyToCursor, this.verticalDragToForward = e.verticalDragToForward, this._target0.fromArray(e.target0), this._position0.fromArray(e.position0), this._zoom0 = e.zoom0, this._focalOffset0.fromArray(e.focalOffset0), this.moveTo(e.target[0], e.target[1], e.target[2], t), dt.setFromVector3(G.fromArray(e.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(dt.theta, dt.phi, t), this.dollyTo(dt.radius, t), this.zoomTo(e.zoom, t), this.setFocalOffset(e.focalOffset[0], e.focalOffset[1], e.focalOffset[2], t), this._needsUpdate = true;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(s) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    s.setAttribute("data-camera-controls-version", Sr), this._addAllEventListeners(s), this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0);
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners(), this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(s) {
    return s.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(s) {
    return this._getTargetDirection(s).negate();
  }
  _findPointerById(s) {
    return this._activePointers.find((t) => t.pointerId === s);
  }
  _findPointerByMouseButton(s) {
    return this._activePointers.find((t) => t.mouseButton === s);
  }
  _disposePointer(s) {
    this._activePointers.splice(this._activePointers.indexOf(s), 1);
  }
  _encloseToBoundary(s, t, e) {
    const i = t.lengthSq();
    if (i === 0)
      return s;
    const o = z.copy(t).add(s), r = this._boundary.clampPoint(o, de).sub(o), a = r.lengthSq();
    if (a === 0)
      return s.add(t);
    if (a === i)
      return s;
    if (e === 0)
      return s.add(t).add(r);
    {
      const c = 1 + e * a / t.dot(r);
      return s.add(z.copy(t).multiplyScalar(c)).add(r.multiplyScalar(1 - e));
    }
  }
  _updateNearPlaneCorners() {
    if (Zt(this._camera)) {
      const s = this._camera, t = s.near, e = s.getEffectiveFOV() * Ne, i = Math.tan(e * 0.5) * t, o = i * s.aspect;
      this._nearPlaneCorners[0].set(-o, -i, 0), this._nearPlaneCorners[1].set(o, -i, 0), this._nearPlaneCorners[2].set(o, i, 0), this._nearPlaneCorners[3].set(-o, i, 0);
    } else if (bt(this._camera)) {
      const s = this._camera, t = 1 / s.zoom, e = s.left * t, i = s.right * t, o = s.top * t, n = s.bottom * t;
      this._nearPlaneCorners[0].set(e, o, 0), this._nearPlaneCorners[1].set(i, o, 0), this._nearPlaneCorners[2].set(i, n, 0), this._nearPlaneCorners[3].set(e, n, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let s = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || Js2(this._camera, "_collisionTest"))
      return s;
    const e = this._getTargetDirection(ye);
    ii.lookAt(cn, e, this._camera.up);
    for (let i = 0; i < 4; i++) {
      const o = z.copy(this._nearPlaneCorners[i]);
      o.applyMatrix4(ii);
      const n = de.addVectors(this._target, o);
      Is.set(n, e), Is.far = this._spherical.radius + 1;
      const r = Is.intersectObjects(this.colliderMeshes);
      r.length !== 0 && r[0].distance < s && (s = r[0].distance);
    }
    return s;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(s) {
    if (!this._domElement)
      return;
    const t = this._domElement.getBoundingClientRect();
    return s.x = t.left, s.y = t.top, this._viewport ? (s.x += this._viewport.x, s.y += t.height - this._viewport.w - this._viewport.y, s.width = this._viewport.z, s.height = this._viewport.w) : (s.width = t.width, s.height = t.height), s;
  }
  _createOnRestPromise(s) {
    return s ? Promise.resolve() : (this._hasRested = false, this.dispatchEvent({ type: "transitionstart" }), new Promise((t) => {
      const e = () => {
        this.removeEventListener("rest", e), t();
      };
      this.addEventListener("rest", e);
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(s) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(s) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(s) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(s, t = new Y.Sphere()) {
    const e = t, i = e.center;
    ue.makeEmpty(), s.traverseVisible((n) => {
      n.isMesh && ue.expandByObject(n);
    }), ue.getCenter(i);
    let o = 0;
    return s.traverseVisible((n) => {
      if (!n.isMesh)
        return;
      const r = n, a = r.geometry.clone();
      a.applyMatrix4(r.matrixWorld);
      const h = a.attributes.position;
      for (let d = 0, E = h.count; d < E; d++)
        G.fromBufferAttribute(h, d), o = Math.max(o, i.distanceToSquared(G));
    }), e.radius = Math.sqrt(o), e;
  }
};
var ke = class _ke extends cr {
  constructor(t) {
    super(t);
    I(this, "onBeforeUpdate", new D());
    I(this, "onAfterUpdate", new D());
    I(this, "onAspectUpdated", new D());
    I(this, "onDisposed", new D());
    I(this, "three");
    I(this, "_allControls", /* @__PURE__ */ new Map());
    I(this, "updateAspect", () => {
      var t2;
      if (!(!this.currentWorld || !this.currentWorld.renderer)) {
        if (this.three instanceof OrthographicCamera) {
          this.onAspectUpdated.trigger();
          return;
        }
        if ((t2 = this.currentWorld.renderer) != null && t2.isResizeable()) {
          const e = this.currentWorld.renderer.getSize();
          this.three.aspect = e.width / e.height, this.three.updateProjectionMatrix(), this.onAspectUpdated.trigger();
        }
      }
    });
    this.three = this.setupCamera(), this.setupEvents(true), this.onWorldChanged.add(({ action: e, world: i }) => {
      if (e === "added") {
        const o = this.newCameraControls();
        this._allControls.set(i.uuid, o);
      }
      if (e === "removed") {
        const o = this._allControls.get(i.uuid);
        o && (o.dispose(), this._allControls.delete(i.uuid));
      }
    });
  }
  /**
   * The object that controls the camera. An instance of
   * [yomotsu's cameracontrols](https://github.com/yomotsu/camera-controls).
   * Transforming the camera directly will have no effect: you need to use this
   * object to move, rotate, look at objects, etc.
   */
  get controls() {
    if (!this.currentWorld)
      throw new Error("This camera needs a world to work!");
    const t = this._allControls.get(this.currentWorld.uuid);
    if (!t)
      throw new Error("Controls not found!");
    return t;
  }
  /** {@link Component.enabled} */
  get enabled() {
    return this.currentWorld === null ? false : this.controls.enabled;
  }
  /** {@link Component.enabled} */
  set enabled(t) {
    this.controls.enabled = t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.onAspectUpdated.reset(), this.onBeforeUpdate.reset(), this.onAfterUpdate.reset(), this.three.removeFromParent(), this.onDisposed.trigger(), this.onDisposed.reset();
    for (const [t, e] of this._allControls)
      e.dispose();
  }
  /** {@link Updateable.update} */
  update(t) {
    this.enabled && (this.onBeforeUpdate.trigger(this), this.controls.update(t), this.onAfterUpdate.trigger(this));
  }
  setupCamera() {
    const t = window.innerWidth / window.innerHeight, e = new PerspectiveCamera(60, t, 1, 1e3);
    return e.position.set(50, 50, 50), e.lookAt(new Vector3(0, 0, 0)), e;
  }
  newCameraControls() {
    if (!this.currentWorld)
      throw new Error("This camera needs a world to work!");
    if (!this.currentWorld.renderer)
      throw new Error("This camera needs a renderer to work!");
    ot.install({ THREE: _ke.getSubsetOfThree() });
    const { domElement: t } = this.currentWorld.renderer.three, e = new ot(this.three, t);
    return e.smoothTime = 0.2, e.dollyToCursor = true, e.infinityDolly = true, e;
  }
  setupEvents(t) {
    t ? window.addEventListener("resize", this.updateAspect) : window.removeEventListener("resize", this.updateAspect);
  }
  static getSubsetOfThree() {
    return {
      MOUSE,
      Vector2,
      Vector3,
      Vector4,
      Quaternion,
      Matrix4,
      Spherical,
      Box3,
      Sphere,
      Raycaster,
      MathUtils
    };
  }
};
var gs = class gs2 extends J {
  constructor(t) {
    super(t);
    I(this, "onAfterUpdate", new D());
    I(this, "onBeforeUpdate", new D());
    I(this, "onDisposed", new D());
    I(this, "onWorldCreated", new D());
    I(this, "onWorldDeleted", new D());
    I(this, "list", /* @__PURE__ */ new Map());
    I(this, "enabled", true);
    t.add(gs2.uuid, this);
  }
  /**
   * Creates a new instance of a SimpleWorld and adds it to the list of worlds.
   *
   * @template T - The type of the scene, extending from BaseScene. Defaults to BaseScene.
   * @template U - The type of the camera, extending from BaseCamera. Defaults to BaseCamera.
   * @template S - The type of the renderer, extending from BaseRenderer. Defaults to BaseRenderer.
   *
   * @throws {Error} - Throws an error if a world with the same UUID already exists in the list.
   */
  create() {
    const t = new Or(this.components), e = t.uuid;
    if (this.list.has(e))
      throw new Error("There is already a world with this name!");
    return this.list.set(e, t), this.onWorldCreated.trigger(t), t;
  }
  delete(t) {
    const e = t.uuid;
    this.list.delete(t.uuid), t.dispose(), this.onWorldDeleted.trigger(e);
  }
  dispose() {
    this.enabled = false;
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
  update(t) {
    if (this.enabled)
      for (const [e, i] of this.list)
        i.update(t);
  }
};
I(gs, "uuid", "fdb61dc4-2ec1-4966-b83d-54ea795fad4a");
var Ci = gs;
var Pr = class {
  constructor(s, t, e) {
    I(this, "onDisposed", new D());
    I(this, "world");
    I(this, "components");
    I(this, "three");
    I(this, "_fade", 3);
    I(this, "updateZoom", () => {
      this.world.camera instanceof ke && (this.material.uniforms.uZoom.value = this.world.camera.three.zoom);
    });
    this.world = t;
    const { color: i, size1: o, size2: n, distance: r } = e;
    this.components = s;
    const a = new PlaneGeometry(2, 2, 1, 1), c = new ShaderMaterial({
      side: DoubleSide,
      uniforms: {
        uSize1: {
          value: o
        },
        uSize2: {
          value: n
        },
        uColor: {
          value: i
        },
        uDistance: {
          value: r
        },
        uFade: {
          value: this._fade
        },
        uZoom: {
          value: 1
        }
      },
      transparent: true,
      vertexShader: `
            
            varying vec3 worldPosition;
            
            uniform float uDistance;
            
            void main() {
            
                    vec3 pos = position.xzy * uDistance;
                    pos.xz += cameraPosition.xz;
                    
                    worldPosition = pos;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            
            }
            `,
      fragmentShader: `
            
            varying vec3 worldPosition;
            
            uniform float uZoom;
            uniform float uFade;
            uniform float uSize1;
            uniform float uSize2;
            uniform vec3 uColor;
            uniform float uDistance;
                
                
                
                float getGrid(float size) {
                
                    vec2 r = worldPosition.xz / size;
                    
                    
                    vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
                    float line = min(grid.x, grid.y);
                    
                
                    return 1.0 - min(line, 1.0);
                }
                
            void main() {
            
                    
                    float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / uDistance, 1.0);
                    
                    float g1 = getGrid(uSize1);
                    float g2 = getGrid(uSize2);
                    
                    // Ortho camera fades the grid away when zooming out
                    float minZoom = step(0.2, uZoom);
                    float zoomFactor = pow(min(uZoom, 1.), 2.) * minZoom;
                    
                    gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, uFade));
                    gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2) * zoomFactor;
                    
                    if ( gl_FragColor.a <= 0.0 ) discard;
                    
            
            }
            
            `,
      extensions: {
        derivatives: true
      }
    });
    this.three = new Mesh(a, c), this.three.frustumCulled = false, t.scene.three.add(this.three), this.setupEvents(true);
  }
  /** {@link Hideable.visible} */
  get visible() {
    return this.three.visible;
  }
  /** {@link Hideable.visible} */
  set visible(s) {
    s ? this.world.scene.three.add(this.three) : this.three.removeFromParent();
  }
  /** The material of the grid. */
  get material() {
    return this.three.material;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  get fade() {
    return this._fade === 3;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  set fade(s) {
    this._fade = s ? 3 : 0, this.material.uniforms.uFade.value = this._fade;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.components.get(zt).destroy(this.three), this.onDisposed.trigger(), this.onDisposed.reset(), this.world = null, this.components = null;
  }
  setupEvents(s) {
    if (this.world.isDisposing || !(this.world.camera instanceof ke))
      return;
    const t = this.world.camera.controls;
    s ? t.addEventListener("update", this.updateZoom) : t.removeEventListener("update", this.updateZoom);
  }
};
var Ss = class Ss2 extends J {
  constructor(t) {
    super(t);
    I(this, "list", /* @__PURE__ */ new Map());
    I(this, "onDisposed", new D());
    I(this, "config", {
      color: new Color(12303291),
      size1: 1,
      size2: 10,
      distance: 500
    });
    I(this, "enabled", true);
    t.add(Ss2.uuid, this);
  }
  create(t) {
    if (this.list.has(t.uuid))
      throw new Error("This world already has a grid!");
    const e = new Pr(this.components, t, this.config);
    return this.list.set(t.uuid, e), t.onDisposed.add(() => {
      this.delete(t);
    }), e;
  }
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
I(Ss, "uuid", "d1e814d5-b81c-4452-87a2-f039375e0489");
var un = Ss;
var jt = new Raycaster();
var nt = new Vector3();
var xt = new Vector3();
var j = new Quaternion();
var In = {
  X: new Vector3(1, 0, 0),
  Y: new Vector3(0, 1, 0),
  Z: new Vector3(0, 0, 1)
};
var ni = { type: "change" };
var fn = { type: "mouseDown" };
var pn = { type: "mouseUp", mode: null };
var Cn = { type: "objectChange" };
var Lr = class extends Object3D {
  constructor(s, t) {
    super(), t === void 0 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), t = document), this.isTransformControls = true, this.visible = false, this.domElement = t, this.domElement.style.touchAction = "none";
    const e = new xr();
    this._gizmo = e, this.add(e);
    const i = new br();
    this._plane = i, this.add(i);
    const o = this;
    function n(R, F) {
      let f = F;
      Object.defineProperty(o, R, {
        get: function() {
          return f !== void 0 ? f : F;
        },
        set: function(T) {
          f !== T && (f = T, i[R] = T, e[R] = T, o.dispatchEvent({ type: R + "-changed", value: T }), o.dispatchEvent(ni));
        }
      }), o[R] = F, i[R] = F, e[R] = F;
    }
    n("camera", s), n("object", void 0), n("enabled", true), n("axis", null), n("mode", "translate"), n("translationSnap", null), n("rotationSnap", null), n("scaleSnap", null), n("space", "world"), n("size", 1), n("dragging", false), n("showX", true), n("showY", true), n("showZ", true);
    const r = new Vector3(), a = new Vector3(), c = new Quaternion(), h = new Quaternion(), d = new Vector3(), E = new Quaternion(), u = new Vector3(), p = new Vector3(), A = new Vector3(), m = 0, C = new Vector3();
    n("worldPosition", r), n("worldPositionStart", a), n("worldQuaternion", c), n("worldQuaternionStart", h), n("cameraPosition", d), n("cameraQuaternion", E), n("pointStart", u), n("pointEnd", p), n("rotationAxis", A), n("rotationAngle", m), n("eye", C), this._offset = new Vector3(), this._startNorm = new Vector3(), this._endNorm = new Vector3(), this._cameraScale = new Vector3(), this._parentPosition = new Vector3(), this._parentQuaternion = new Quaternion(), this._parentQuaternionInv = new Quaternion(), this._parentScale = new Vector3(), this._worldScaleStart = new Vector3(), this._worldQuaternionInv = new Quaternion(), this._worldScale = new Vector3(), this._positionStart = new Vector3(), this._quaternionStart = new Quaternion(), this._scaleStart = new Vector3(), this._getPointer = yr.bind(this), this._onPointerDown = Mr.bind(this), this._onPointerHover = wr.bind(this), this._onPointerMove = Dr.bind(this), this._onPointerUp = Ur.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  // updateMatrixWorld  updates key transformation variables
  updateMatrixWorld() {
    this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye).negate() : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this);
  }
  pointerHover(s) {
    if (this.object === void 0 || this.dragging === true)
      return;
    jt.setFromCamera(s, this.camera);
    const t = oi(this._gizmo.picker[this.mode], jt);
    t ? this.axis = t.object.name : this.axis = null;
  }
  pointerDown(s) {
    if (!(this.object === void 0 || this.dragging === true || s.button !== 0) && this.axis !== null) {
      jt.setFromCamera(s, this.camera);
      const t = oi(this._plane, jt, true);
      t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t.point).sub(this.worldPositionStart)), this.dragging = true, fn.mode = this.mode, this.dispatchEvent(fn);
    }
  }
  pointerMove(s) {
    const t = this.axis, e = this.mode, i = this.object;
    let o = this.space;
    if (e === "scale" ? o = "local" : (t === "E" || t === "XYZE" || t === "XYZ") && (o = "world"), i === void 0 || t === null || this.dragging === false || s.button !== -1)
      return;
    jt.setFromCamera(s, this.camera);
    const n = oi(this._plane, jt, true);
    if (n) {
      if (this.pointEnd.copy(n.point).sub(this.worldPositionStart), e === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), o === "local" && t !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), t.indexOf("X") === -1 && (this._offset.x = 0), t.indexOf("Y") === -1 && (this._offset.y = 0), t.indexOf("Z") === -1 && (this._offset.z = 0), o === "local" && t !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), i.position.copy(this._offset).add(this._positionStart), this.translationSnap && (o === "local" && (i.position.applyQuaternion(j.copy(this._quaternionStart).invert()), t.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.position.applyQuaternion(this._quaternionStart)), o === "world" && (i.parent && i.position.add(nt.setFromMatrixPosition(i.parent.matrixWorld)), t.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.parent && i.position.sub(nt.setFromMatrixPosition(i.parent.matrixWorld))));
      else if (e === "scale") {
        if (t.search("XYZ") !== -1) {
          let r = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (r *= -1), xt.set(r, r, r);
        } else
          nt.copy(this.pointStart), xt.copy(this.pointEnd), nt.applyQuaternion(this._worldQuaternionInv), xt.applyQuaternion(this._worldQuaternionInv), xt.divide(nt), t.search("X") === -1 && (xt.x = 1), t.search("Y") === -1 && (xt.y = 1), t.search("Z") === -1 && (xt.z = 1);
        i.scale.copy(this._scaleStart).multiply(xt), this.scaleSnap && (t.search("X") !== -1 && (i.scale.x = Math.round(i.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Y") !== -1 && (i.scale.y = Math.round(i.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Z") !== -1 && (i.scale.z = Math.round(i.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (e === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const r = 20 / this.worldPosition.distanceTo(nt.setFromMatrixPosition(this.camera.matrixWorld));
        let a = false;
        t === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(nt.copy(this.rotationAxis).cross(this.eye)) * r) : (t === "X" || t === "Y" || t === "Z") && (this.rotationAxis.copy(In[t]), nt.copy(In[t]), o === "local" && nt.applyQuaternion(this.worldQuaternion), nt.cross(this.eye), nt.length() === 0 ? a = true : this.rotationAngle = this._offset.dot(nt.normalize()) * r), (t === "E" || a) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), o === "local" && t !== "E" && t !== "XYZE" ? (i.quaternion.copy(this._quaternionStart), i.quaternion.multiply(j.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), i.quaternion.copy(j.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), i.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(ni), this.dispatchEvent(Cn);
    }
  }
  pointerUp(s) {
    s.button === 0 && (this.dragging && this.axis !== null && (pn.mode = this.mode, this.dispatchEvent(pn)), this.dragging = false, this.axis = null);
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function(s) {
      s.geometry && s.geometry.dispose(), s.material && s.material.dispose();
    });
  }
  // Set current object
  attach(s) {
    return this.object = s, this.visible = true, this;
  }
  // Detach from object
  detach() {
    return this.object = void 0, this.visible = false, this.axis = null, this;
  }
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(ni), this.dispatchEvent(Cn), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return jt;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(s) {
    this.mode = s;
  }
  setTranslationSnap(s) {
    this.translationSnap = s;
  }
  setRotationSnap(s) {
    this.rotationSnap = s;
  }
  setScaleSnap(s) {
    this.scaleSnap = s;
  }
  setSize(s) {
    this.size = s;
  }
  setSpace(s) {
    this.space = s;
  }
};
function yr(l) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: l.button
    };
  {
    const s = this.domElement.getBoundingClientRect();
    return {
      x: (l.clientX - s.left) / s.width * 2 - 1,
      y: -(l.clientY - s.top) / s.height * 2 + 1,
      button: l.button
    };
  }
}
function wr(l) {
  if (this.enabled)
    switch (l.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(l));
        break;
    }
}
function Mr(l) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(l.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(l)), this.pointerDown(this._getPointer(l)));
}
function Dr(l) {
  this.enabled && this.pointerMove(this._getPointer(l));
}
function Ur(l) {
  this.enabled && (this.domElement.releasePointerCapture(l.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(l)));
}
function oi(l, s, t) {
  const e = s.intersectObject(l, true);
  for (let i = 0; i < e.length; i++)
    if (e[i].object.visible || t)
      return e[i];
  return false;
}
var fs = new Euler();
var W = new Vector3(0, 1, 0);
var Tn = new Vector3(0, 0, 0);
var mn = new Matrix4();
var ps = new Quaternion();
var Rs = new Quaternion();
var _t = new Vector3();
var Rn = new Matrix4();
var Ue = new Vector3(1, 0, 0);
var qt = new Vector3(0, 1, 0);
var xe = new Vector3(0, 0, 1);
var Cs = new Vector3();
var Me = new Vector3();
var De = new Vector3();
var xr = class extends Object3D {
  constructor() {
    super(), this.isTransformControlsGizmo = true, this.type = "TransformControlsGizmo";
    const s = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    }), t = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    }), e = s.clone();
    e.opacity = 0.15;
    const i = t.clone();
    i.opacity = 0.5;
    const o = s.clone();
    o.color.setHex(16711680);
    const n = s.clone();
    n.color.setHex(65280);
    const r = s.clone();
    r.color.setHex(255);
    const a = s.clone();
    a.color.setHex(16711680), a.opacity = 0.5;
    const c = s.clone();
    c.color.setHex(65280), c.opacity = 0.5;
    const h = s.clone();
    h.color.setHex(255), h.opacity = 0.5;
    const d = s.clone();
    d.opacity = 0.25;
    const E = s.clone();
    E.color.setHex(16776960), E.opacity = 0.25, s.clone().color.setHex(16776960);
    const p = s.clone();
    p.color.setHex(7895160);
    const A = new CylinderGeometry(0, 0.04, 0.1, 12);
    A.translate(0, 0.05, 0);
    const m = new BoxGeometry(0.08, 0.08, 0.08);
    m.translate(0, 0.04, 0);
    const C = new BufferGeometry();
    C.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
    const R = new CylinderGeometry(75e-4, 75e-4, 0.5, 3);
    R.translate(0, 0.25, 0);
    function F(B, H) {
      const q = new TorusGeometry(B, 75e-4, 3, 64, H * Math.PI * 2);
      return q.rotateY(Math.PI / 2), q.rotateX(Math.PI / 2), q;
    }
    function f() {
      const B = new BufferGeometry();
      return B.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3)), B;
    }
    const T = {
      X: [
        [new Mesh(A, o), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(A, o), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Mesh(R, o), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(A, n), [0, 0.5, 0]],
        [new Mesh(A, n), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Mesh(R, n)]
      ],
      Z: [
        [new Mesh(A, r), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(A, r), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Mesh(R, r), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.1, 0), d.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), h.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), a.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), c.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, O = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.2, 0), e)]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), e), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), e), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), e), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, S = {
      START: [
        [new Mesh(new OctahedronGeometry(0.01, 2), i), null, null, null, "helper"]
      ],
      END: [
        [new Mesh(new OctahedronGeometry(0.01, 2), i), null, null, null, "helper"]
      ],
      DELTA: [
        [new Line(f(), i), null, null, null, "helper"]
      ],
      X: [
        [new Line(C, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(C, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(C, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, _ = {
      XYZE: [
        [new Mesh(F(0.5, 1), p), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Mesh(F(0.5, 0.5), o)]
      ],
      Y: [
        [new Mesh(F(0.5, 0.5), n), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Mesh(F(0.5, 0.5), r), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Mesh(F(0.75, 1), E), null, [0, Math.PI / 2, 0]]
      ]
    }, N = {
      AXIS: [
        [new Line(C, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, L = {
      XYZE: [
        [new Mesh(new SphereGeometry(0.25, 10, 8), e)]
      ],
      X: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), e), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), e), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), e), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Mesh(new TorusGeometry(0.75, 0.1, 2, 24), e)]
      ]
    }, M = {
      X: [
        [new Mesh(m, o), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(R, o), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(m, o), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(m, n), [0, 0.5, 0]],
        [new Mesh(R, n)],
        [new Mesh(m, n), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(m, r), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(R, r), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Mesh(m, r), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), h), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), a), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), c), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.1, 0.1, 0.1), d.clone())]
      ]
    }, y = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), e), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), e), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), e), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), e), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.2), e), [0, 0, 0]]
      ]
    }, x = {
      X: [
        [new Line(C, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(C, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(C, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function b(B) {
      const H = new Object3D();
      for (const q in B)
        for (let st = B[q].length; st--; ) {
          const Q = B[q][st][0].clone(), Ht = B[q][st][1], kt = B[q][st][2], Wt = B[q][st][3], Xe = B[q][st][4];
          Q.name = q, Q.tag = Xe, Ht && Q.position.set(Ht[0], Ht[1], Ht[2]), kt && Q.rotation.set(kt[0], kt[1], kt[2]), Wt && Q.scale.set(Wt[0], Wt[1], Wt[2]), Q.updateMatrix();
          const Te = Q.geometry.clone();
          Te.applyMatrix4(Q.matrix), Q.geometry = Te, Q.renderOrder = 1 / 0, Q.position.set(0, 0, 0), Q.rotation.set(0, 0, 0), Q.scale.set(1, 1, 1), H.add(Q);
        }
      return H;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = b(T)), this.add(this.gizmo.rotate = b(_)), this.add(this.gizmo.scale = b(M)), this.add(this.picker.translate = b(O)), this.add(this.picker.rotate = b(L)), this.add(this.picker.scale = b(y)), this.add(this.helper.translate = b(S)), this.add(this.helper.rotate = b(N)), this.add(this.helper.scale = b(x)), this.picker.translate.visible = false, this.picker.rotate.visible = false, this.picker.scale.visible = false;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(s) {
    const e = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : Rs;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let i = [];
    i = i.concat(this.picker[this.mode].children), i = i.concat(this.gizmo[this.mode].children), i = i.concat(this.helper[this.mode].children);
    for (let o = 0; o < i.length; o++) {
      const n = i[o];
      n.visible = true, n.rotation.set(0, 0, 0), n.position.copy(this.worldPosition);
      let r;
      if (this.camera.isOrthographicCamera ? r = (this.camera.top - this.camera.bottom) / this.camera.zoom : r = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), n.scale.set(1, 1, 1).multiplyScalar(r * this.size / 4), n.tag === "helper") {
        n.visible = false, n.name === "AXIS" ? (n.visible = !!this.axis, this.axis === "X" && (j.setFromEuler(fs.set(0, 0, 0)), n.quaternion.copy(e).multiply(j), Math.abs(W.copy(Ue).applyQuaternion(e).dot(this.eye)) > 0.9 && (n.visible = false)), this.axis === "Y" && (j.setFromEuler(fs.set(0, 0, Math.PI / 2)), n.quaternion.copy(e).multiply(j), Math.abs(W.copy(qt).applyQuaternion(e).dot(this.eye)) > 0.9 && (n.visible = false)), this.axis === "Z" && (j.setFromEuler(fs.set(0, Math.PI / 2, 0)), n.quaternion.copy(e).multiply(j), Math.abs(W.copy(xe).applyQuaternion(e).dot(this.eye)) > 0.9 && (n.visible = false)), this.axis === "XYZE" && (j.setFromEuler(fs.set(0, Math.PI / 2, 0)), W.copy(this.rotationAxis), n.quaternion.setFromRotationMatrix(mn.lookAt(Tn, W, qt)), n.quaternion.multiply(j), n.visible = this.dragging), this.axis === "E" && (n.visible = false)) : n.name === "START" ? (n.position.copy(this.worldPositionStart), n.visible = this.dragging) : n.name === "END" ? (n.position.copy(this.worldPosition), n.visible = this.dragging) : n.name === "DELTA" ? (n.position.copy(this.worldPositionStart), n.quaternion.copy(this.worldQuaternionStart), nt.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), nt.applyQuaternion(this.worldQuaternionStart.clone().invert()), n.scale.copy(nt), n.visible = this.dragging) : (n.quaternion.copy(e), this.dragging ? n.position.copy(this.worldPositionStart) : n.position.copy(this.worldPosition), this.axis && (n.visible = this.axis.search(n.name) !== -1));
        continue;
      }
      n.quaternion.copy(e), this.mode === "translate" || this.mode === "scale" ? (n.name === "X" && Math.abs(W.copy(Ue).applyQuaternion(e).dot(this.eye)) > 0.99 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = false), n.name === "Y" && Math.abs(W.copy(qt).applyQuaternion(e).dot(this.eye)) > 0.99 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = false), n.name === "Z" && Math.abs(W.copy(xe).applyQuaternion(e).dot(this.eye)) > 0.99 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = false), n.name === "XY" && Math.abs(W.copy(xe).applyQuaternion(e).dot(this.eye)) < 0.2 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = false), n.name === "YZ" && Math.abs(W.copy(Ue).applyQuaternion(e).dot(this.eye)) < 0.2 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = false), n.name === "XZ" && Math.abs(W.copy(qt).applyQuaternion(e).dot(this.eye)) < 0.2 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = false)) : this.mode === "rotate" && (ps.copy(e), W.copy(this.eye).applyQuaternion(j.copy(e).invert()), n.name.search("E") !== -1 && n.quaternion.setFromRotationMatrix(mn.lookAt(this.eye, Tn, qt)), n.name === "X" && (j.setFromAxisAngle(Ue, Math.atan2(-W.y, W.z)), j.multiplyQuaternions(ps, j), n.quaternion.copy(j)), n.name === "Y" && (j.setFromAxisAngle(qt, Math.atan2(W.x, W.z)), j.multiplyQuaternions(ps, j), n.quaternion.copy(j)), n.name === "Z" && (j.setFromAxisAngle(xe, Math.atan2(W.y, W.x)), j.multiplyQuaternions(ps, j), n.quaternion.copy(j))), n.visible = n.visible && (n.name.indexOf("X") === -1 || this.showX), n.visible = n.visible && (n.name.indexOf("Y") === -1 || this.showY), n.visible = n.visible && (n.name.indexOf("Z") === -1 || this.showZ), n.visible = n.visible && (n.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), n.material._color = n.material._color || n.material.color.clone(), n.material._opacity = n.material._opacity || n.material.opacity, n.material.color.copy(n.material._color), n.material.opacity = n.material._opacity, this.enabled && this.axis && (n.name === this.axis || this.axis.split("").some(function(a) {
        return n.name === a;
      })) && (n.material.color.setHex(16776960), n.material.opacity = 1);
    }
    super.updateMatrixWorld(s);
  }
};
var br = class extends Mesh {
  constructor() {
    super(
      new PlaneGeometry(1e5, 1e5, 2, 2),
      new MeshBasicMaterial({ visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false })
    ), this.isTransformControlsPlane = true, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(s) {
    let t = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (t = "local"), Cs.copy(Ue).applyQuaternion(t === "local" ? this.worldQuaternion : Rs), Me.copy(qt).applyQuaternion(t === "local" ? this.worldQuaternion : Rs), De.copy(xe).applyQuaternion(t === "local" ? this.worldQuaternion : Rs), W.copy(Me), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            W.copy(this.eye).cross(Cs), _t.copy(Cs).cross(W);
            break;
          case "Y":
            W.copy(this.eye).cross(Me), _t.copy(Me).cross(W);
            break;
          case "Z":
            W.copy(this.eye).cross(De), _t.copy(De).cross(W);
            break;
          case "XY":
            _t.copy(De);
            break;
          case "YZ":
            _t.copy(Cs);
            break;
          case "XZ":
            W.copy(De), _t.copy(Me);
            break;
          case "XYZ":
          case "E":
            _t.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        _t.set(0, 0, 0);
    }
    _t.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (Rn.lookAt(nt.set(0, 0, 0), _t, W), this.quaternion.setFromRotationMatrix(Rn)), super.updateMatrixWorld(s);
  }
};
var Pi = class _Pi {
  constructor(s, t, e, i, o, n = 5, r = true) {
    I(this, "onDraggingStarted", new D());
    I(this, "onDraggingEnded", new D());
    I(this, "onDisposed", new D());
    I(this, "normal");
    I(this, "origin");
    I(this, "three", new Plane());
    I(this, "_helper");
    I(this, "_visible", true);
    I(this, "_enabled", true);
    I(this, "components");
    I(this, "world");
    I(this, "_controlsActive", false);
    I(this, "_arrowBoundBox", new Mesh());
    I(this, "_planeMesh");
    I(this, "_controls");
    I(this, "_hiddenMaterial", new MeshBasicMaterial({
      visible: false
    }));
    I(this, "update", () => {
      this._enabled && this.three.setFromNormalAndCoplanarPoint(
        this.normal,
        this._helper.position
      );
    });
    I(this, "changeDrag", (s2) => {
      this._visible = !s2.value, this.preventCameraMovement(), this.notifyDraggingChanged(s2);
    });
    if (this.components = s, this.world = t, !t.renderer)
      throw new Error("The given world must have a renderer!");
    this.normal = i, this.origin = e, t.renderer.setPlane(true, this.three), this._planeMesh = _Pi.newPlaneMesh(n, o), this._helper = this.newHelper(), this._controls = this.newTransformControls(), this.three.setFromNormalAndCoplanarPoint(i, e), r && this.toggleControls(true);
  }
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(s) {
    if (!this.world.renderer)
      throw new Error("No renderer found for clipping plane!");
    this._enabled = s, this.world.renderer.setPlane(s, this.three);
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(s) {
    this._visible = s, this._controls.visible = s, this._helper.visible = s, this.toggleControls(s);
  }
  /** The meshes used for raycasting */
  get meshes() {
    return [this._planeMesh, this._arrowBoundBox];
  }
  /** The material of the clipping plane representation. */
  get planeMaterial() {
    return this._planeMesh.material;
  }
  /** The material of the clipping plane representation. */
  set planeMaterial(s) {
    this._planeMesh.material = s;
  }
  /** The size of the clipping plane representation. */
  get size() {
    return this._planeMesh.scale.x;
  }
  /** Sets the size of the clipping plane representation. */
  set size(s) {
    this._planeMesh.scale.set(s, s, s);
  }
  get helper() {
    return this._helper;
  }
  setFromNormalAndCoplanarPoint(s, t) {
    this.reset(), this.normal.equals(s) || (this.normal.copy(s), this._helper.lookAt(s)), this.origin.copy(t), this._helper.position.copy(t), this._helper.updateMatrix(), this.update();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = false, this.onDraggingStarted.reset(), this.onDraggingEnded.reset(), this._helper.removeFromParent(), this.world.renderer && this.world.renderer.setPlane(false, this.three), this._arrowBoundBox.removeFromParent(), this._arrowBoundBox.geometry.dispose(), this._planeMesh.geometry.dispose(), this._controls.removeFromParent(), this._controls.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  reset() {
    const s = new Vector3(1, 0, 0), t = new Vector3();
    this.normal.equals(s) || (this.normal.copy(s), this._helper.lookAt(s)), this.origin.copy(t), this._helper.position.copy(t), this._helper.updateMatrix();
  }
  toggleControls(s) {
    if (s) {
      if (this._controlsActive)
        return;
      this._controls.addEventListener("change", this.update), this._controls.addEventListener("dragging-changed", this.changeDrag);
    } else
      this._controls.removeEventListener("change", this.update), this._controls.removeEventListener("dragging-changed", this.changeDrag);
    this._controlsActive = s;
  }
  newTransformControls() {
    if (!this.world.renderer)
      throw new Error("No renderer found for clipping plane!");
    const s = this.world.camera.three, t = this.world.renderer.three.domElement, e = new Lr(s, t);
    return this.initializeControls(e), this.world.scene.three.add(e), e;
  }
  initializeControls(s) {
    s.attach(this._helper), s.showX = false, s.showY = false, s.setSpace("local"), this.createArrowBoundingBox(), s.children[0].children[0].add(this._arrowBoundBox);
  }
  createArrowBoundingBox() {
    this._arrowBoundBox.geometry = new CylinderGeometry(0.18, 0.18, 1.2), this._arrowBoundBox.material = this._hiddenMaterial, this._arrowBoundBox.rotateX(Math.PI / 2), this._arrowBoundBox.updateMatrix(), this._arrowBoundBox.geometry.applyMatrix4(this._arrowBoundBox.matrix);
  }
  notifyDraggingChanged(s) {
    s.value ? this.onDraggingStarted.trigger() : this.onDraggingEnded.trigger();
  }
  preventCameraMovement() {
    this.world.camera.enabled = this._visible;
  }
  newHelper() {
    const s = new Object3D();
    return s.lookAt(this.normal), s.position.copy(this.origin), this._planeMesh.position.z += 0.01, s.add(this._planeMesh), this.world.scene.three.add(s), s;
  }
  static newPlaneMesh(s, t) {
    const e = new PlaneGeometry(1), i = new Mesh(e, t);
    return i.scale.set(s, s, s), i;
  }
};
var Be = class Be2 extends J {
  constructor(t) {
    super(t);
    I(this, "onAfterCreate", new D());
    I(this, "onAfterDelete", new D());
    I(this, "onBeforeDrag", new D());
    I(this, "onAfterDrag", new D());
    I(this, "onBeforeCreate", new D());
    I(this, "onBeforeCancel", new D());
    I(this, "onAfterCancel", new D());
    I(this, "onBeforeDelete", new D());
    I(this, "onDisposed", new D());
    I(this, "orthogonalY", false);
    I(this, "toleranceOrthogonalY", 0.7);
    I(this, "Type", Pi);
    I(this, "list", []);
    I(this, "_material", new MeshBasicMaterial({
      color: 12255487,
      side: DoubleSide,
      transparent: true,
      opacity: 0.2
    }));
    I(this, "_size", 5);
    I(this, "_enabled", false);
    I(this, "_visible", true);
    I(this, "_onStartDragging", () => {
      this.onBeforeDrag.trigger();
    });
    I(this, "_onEndDragging", () => {
      this.onAfterDrag.trigger();
    });
    this.components.add(Be2.uuid, this);
  }
  /** {@link Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(t) {
    this._enabled = t;
    for (const e of this.list)
      e.enabled = t;
    this.updateMaterialsAndPlanes();
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(t) {
    this._visible = t;
    for (const e of this.list)
      e.visible = t;
  }
  /** The material of the clipping plane representation. */
  get material() {
    return this._material;
  }
  /** The material of the clipping plane representation. */
  set material(t) {
    this._material = t;
    for (const e of this.list)
      e.planeMaterial = t;
  }
  /** The size of the geometric representation of the clippings planes. */
  get size() {
    return this._size;
  }
  /** The size of the geometric representation of the clippings planes. */
  set size(t) {
    this._size = t;
    for (const e of this.list)
      e.size = t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = false;
    for (const t of this.list)
      t.dispose();
    this.list.length = 0, this._material.dispose(), this.onBeforeCreate.reset(), this.onBeforeCancel.reset(), this.onBeforeDelete.reset(), this.onBeforeDrag.reset(), this.onAfterCreate.reset(), this.onAfterCancel.reset(), this.onAfterDelete.reset(), this.onAfterDrag.reset(), this.onDisposed.trigger(Be2.uuid), this.onDisposed.reset();
  }
  /** {@link Createable.create} */
  create(t) {
    if (!this.enabled)
      return;
    const o = this.components.get(He).get(t).castRay();
    o && this.createPlaneFromIntersection(t, o);
  }
  /**
   * Creates a plane in a certain place and with a certain orientation,
   * without the need of the mouse.
   *
   * @param world - the world where this plane should be created.
   * @param normal - the orientation of the clipping plane.
   * @param point - the position of the clipping plane.
   * navigation.
   */
  createFromNormalAndCoplanarPoint(t, e, i) {
    const o = this.newPlane(t, i, e);
    return this.updateMaterialsAndPlanes(), o;
  }
  /**
   * {@link Createable.delete}
   *
   * @param world - the world where the plane to delete is.
   * @param plane - the plane to delete. If undefined, the first plane
   * found under the cursor will be deleted.
   */
  delete(t, e) {
    this.enabled && (e || (e = this.pickPlane(t)), e && this.deletePlane(e));
  }
  /** Deletes all the existing clipping planes. */
  deleteAll() {
    for (; this.list.length > 0; ) {
      const t = this.list[0];
      this.delete(t.world, t);
    }
  }
  deletePlane(t) {
    const e = this.list.indexOf(t);
    if (e !== -1) {
      if (this.list.splice(e, 1), !t.world.renderer)
        throw new Error("Renderer not found for this plane's world!");
      t.world.renderer.setPlane(false, t.three), t.dispose(), this.updateMaterialsAndPlanes(), this.onAfterDelete.trigger(t);
    }
  }
  pickPlane(t) {
    const i = this.components.get(He).get(t), o = this.getAllPlaneMeshes(), n = i.castRay(o);
    if (n) {
      const r = n.object;
      return this.list.find((a) => a.meshes.includes(r));
    }
  }
  getAllPlaneMeshes() {
    const t = [];
    for (const e of this.list)
      t.push(...e.meshes);
    return t;
  }
  createPlaneFromIntersection(t, e) {
    var a;
    if (!t.renderer)
      throw new Error("The given world must have a renderer!");
    const i = e.point.distanceTo(new Vector3(0, 0, 0)), o = (a = e.face) == null ? void 0 : a.normal;
    if (!i || !o)
      return;
    const n = this.getWorldNormal(e, o), r = this.newPlane(t, e.point, n.negate());
    r.visible = this._visible, r.size = this._size, t.renderer.setPlane(true, r.three), this.updateMaterialsAndPlanes();
  }
  getWorldNormal(t, e) {
    const i = t.object;
    let o = t.object.matrixWorld.clone();
    if (i instanceof InstancedMesh && t.instanceId !== void 0) {
      const c = new Matrix4();
      i.getMatrixAt(t.instanceId, c), o = c.multiply(o);
    }
    const r = new Matrix3().getNormalMatrix(o), a = e.clone().applyMatrix3(r).normalize();
    return this.normalizePlaneDirectionY(a), a;
  }
  normalizePlaneDirectionY(t) {
    this.orthogonalY && (t.y > this.toleranceOrthogonalY && (t.x = 0, t.y = 1, t.z = 0), t.y < -this.toleranceOrthogonalY && (t.x = 0, t.y = -1, t.z = 0));
  }
  newPlane(t, e, i) {
    const o = new this.Type(
      this.components,
      t,
      e,
      i,
      this._material
    );
    return o.onDraggingStarted.add(this._onStartDragging), o.onDraggingEnded.add(this._onEndDragging), this.list.push(o), this.onAfterCreate.trigger(o), o;
  }
  updateMaterialsAndPlanes() {
    const t = this.components.get(Ci);
    for (const [e, i] of t.list) {
      if (!i.renderer)
        continue;
      i.renderer.updateClippingPlanes();
      const { clippingPlanes: o } = i.renderer;
      for (const n of i.meshes)
        if (Array.isArray(n.material))
          for (const r of n.material)
            r.clippingPlanes = o;
        else
          n.material.clippingPlanes = o;
    }
  }
};
I(Be, "uuid", "66290bc5-18c4-4cd1-9379-2e17a0617611");
var An = Be;
function vr(l, s, t, e) {
  return new Promise((i, o) => {
    function n() {
      const r = l.clientWaitSync(s, t, 0);
      if (r === l.WAIT_FAILED) {
        o();
        return;
      }
      if (r === l.TIMEOUT_EXPIRED) {
        setTimeout(n, e);
        return;
      }
      i();
    }
    n();
  });
}
async function Br(l, s, t, e, i, o, n) {
  const r = l.fenceSync(l.SYNC_GPU_COMMANDS_COMPLETE, 0);
  l.flush(), await vr(l, r, 0, 10), l.deleteSync(r), l.bindBuffer(s, t), l.getBufferSubData(s, e, i, o, n), l.bindBuffer(s, null);
}
async function Yr(l, s, t, e, i, o, n, r) {
  const a = l.createBuffer();
  return l.bindBuffer(l.PIXEL_PACK_BUFFER, a), l.bufferData(l.PIXEL_PACK_BUFFER, r.byteLength, l.STREAM_READ), l.readPixels(s, t, e, i, o, n, 0), l.bindBuffer(l.PIXEL_PACK_BUFFER, null), await Br(l, l.PIXEL_PACK_BUFFER, a, 0, r), l.deleteBuffer(a), r;
}
var Vr = class {
  constructor(s, t, e) {
    I(this, "onDisposed", new D());
    I(this, "onViewUpdated", new $t());
    I(this, "enabled", true);
    I(this, "needsUpdate", false);
    I(this, "renderDebugFrame", false);
    I(this, "components");
    I(this, "world");
    I(this, "renderer");
    I(this, "autoUpdate", true);
    I(this, "updateInterval", 1e3);
    I(this, "worker");
    I(this, "scene", new Scene());
    I(this, "_width", 512);
    I(this, "_height", 512);
    I(this, "_availableColor", 1);
    I(this, "renderTarget");
    I(this, "bufferSize");
    I(this, "_buffer");
    I(this, "_isWorkerBusy", false);
    I(this, "updateVisibility", async (s2) => {
      if (!this.enabled || !this.needsUpdate && !s2 || this._isWorkerBusy)
        return;
      this._isWorkerBusy = true;
      const t2 = this.world.camera.three;
      t2.updateMatrix(), this.renderer.setSize(this._width, this._height), this.renderer.setRenderTarget(this.renderTarget), this.renderer.render(this.scene, t2);
      const e2 = this.renderer.getContext();
      await Yr(
        e2,
        0,
        0,
        this._width,
        this._height,
        e2.RGBA,
        e2.UNSIGNED_BYTE,
        this._buffer
      ), this.renderer.setRenderTarget(null), this.renderDebugFrame && this.renderer.render(this.scene, t2), this.worker.postMessage({
        buffer: this._buffer
      }), this.needsUpdate = false;
    });
    if (!t.renderer)
      throw new Error("The given world must have a renderer!");
    this.components = s, this.applySettings(e), this.world = t, this.renderer = new WebGLRenderer(), this.renderTarget = new WebGLRenderTarget(this._width, this._height), this.bufferSize = this._width * this._height * 4, this._buffer = new Uint8Array(this.bufferSize), this.renderer.clippingPlanes = t.renderer.clippingPlanes;
    const i = `
      addEventListener("message", (event) => {
        const { buffer } = event.data;
        const colors = new Map();
        for (let i = 0; i < buffer.length; i += 4) {
          const r = buffer[i];
          const g = buffer[i + 1];
          const b = buffer[i + 2];
          const code = "" + r + "-" + g + "-" + b;
          if(colors.has(code)) {
            colors.set(code, colors.get(code) + 1);
          } else {
            colors.set(code, 1);
          }
        }
        postMessage({ colors });
      });
    `, o = new Blob([i], { type: "application/javascript" });
    this.worker = new Worker(URL.createObjectURL(o));
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false;
    for (const s of this.scene.children)
      s.removeFromParent();
    this.onViewUpdated.reset(), this.worker.terminate(), this.renderer.dispose(), this.renderTarget.dispose(), this._buffer = null, this.onDisposed.reset();
  }
  getAvailableColor() {
    let s = BigInt(this._availableColor.toString());
    const t = [];
    do
      t.unshift(Number(s % 256n)), s /= 256n;
    while (s);
    for (; t.length !== 3; )
      t.unshift(0);
    const [e, i, o] = t, n = `${e}-${i}-${o}`;
    return { r: e, g: i, b: o, code: n };
  }
  increaseColor() {
    if (this._availableColor === 256 * 256 * 256) {
      console.warn("Color can't be increased over 256 x 256 x 256!");
      return;
    }
    this._availableColor++;
  }
  decreaseColor() {
    if (this._availableColor === 1) {
      console.warn("Color can't be decreased under 0!");
      return;
    }
    this._availableColor--;
  }
  applySettings(s) {
    s && (s.updateInterval !== void 0 && (this.updateInterval = s.updateInterval), s.height !== void 0 && (this._height = s.height), s.width !== void 0 && (this._width = s.width), s.autoUpdate !== void 0 && (this.autoUpdate = s.autoUpdate));
  }
};
var Gr = class extends Vr {
  constructor(t, e, i) {
    super(t, e, i);
    I(this, "threshold", 100);
    I(this, "onViewUpdated", new D());
    I(this, "colorMeshes", /* @__PURE__ */ new Map());
    I(this, "isProcessing", false);
    I(this, "_colorCodeMeshMap", /* @__PURE__ */ new Map());
    I(this, "_meshIDColorCodeMap", /* @__PURE__ */ new Map());
    I(this, "_currentVisibleMeshes", /* @__PURE__ */ new Set());
    I(this, "_recentlyHiddenMeshes", /* @__PURE__ */ new Set());
    I(this, "_intervalID", null);
    I(this, "_transparentMat", new MeshBasicMaterial({
      transparent: true,
      opacity: 0
    }));
    I(this, "handleWorkerMessage", async (t2) => {
      if (this.isProcessing)
        return;
      const e2 = t2.data.colors;
      this._recentlyHiddenMeshes = new Set(this._currentVisibleMeshes), this._currentVisibleMeshes.clear();
      for (const [i2, o] of e2) {
        if (o < this.threshold)
          continue;
        const n = this._colorCodeMeshMap.get(i2);
        n && (this._currentVisibleMeshes.add(n), this._recentlyHiddenMeshes.delete(n));
      }
      this.onViewUpdated.trigger({
        seen: this._currentVisibleMeshes,
        unseen: this._recentlyHiddenMeshes
      }), this._isWorkerBusy = false;
    });
    this.worker.addEventListener("message", this.handleWorkerMessage), this.autoUpdate && window.setInterval(async () => {
      this.isProcessing || await this.updateVisibility();
    }, this.updateInterval), this.onViewUpdated.add(({ seen: o, unseen: n }) => {
      for (const r of o)
        r.visible = true;
      for (const r of n)
        r.visible = false;
    });
  }
  dispose() {
    super.dispose(), this._intervalID !== null && (window.clearInterval(this._intervalID), this._intervalID = null), this._currentVisibleMeshes.clear(), this._recentlyHiddenMeshes.clear(), this._meshIDColorCodeMap.clear(), this._transparentMat.dispose(), this._colorCodeMeshMap.clear();
    const t = this.components.get(zt);
    for (const e in this.colorMeshes) {
      const i = this.colorMeshes.get(e);
      i && t.destroy(i, true);
    }
    this.colorMeshes.clear();
  }
  add(t) {
    if (!this.enabled)
      return;
    if (this.isProcessing) {
      console.log("Culler processing not finished yet.");
      return;
    }
    this.isProcessing = true;
    const e = t instanceof InstancedMesh, { geometry: i, material: o } = t, { colorMaterial: n, code: r } = this.getAvailableMaterial();
    let a;
    if (Array.isArray(o)) {
      let d = true;
      const E = [];
      for (const u of o)
        nn.isTransparent(u) ? E.push(this._transparentMat) : (d = false, E.push(n));
      if (d) {
        n.dispose(), this.isProcessing = false;
        return;
      }
      a = E;
    } else if (nn.isTransparent(o)) {
      n.dispose(), this.isProcessing = false;
      return;
    } else
      a = n;
    this._colorCodeMeshMap.set(r, t), this._meshIDColorCodeMap.set(t.uuid, r);
    const c = e ? t.count : 1, h = new InstancedMesh(i, a, c);
    e ? h.instanceMatrix = t.instanceMatrix : h.setMatrixAt(0, new Matrix4()), t.visible = false, h.applyMatrix4(t.matrix), h.updateMatrix(), this.scene.add(h), this.colorMeshes.set(t.uuid, h), this.increaseColor(), this.isProcessing = false;
  }
  remove(t) {
    if (this.isProcessing) {
      console.log("Culler processing not finished yet.");
      return;
    }
    this.isProcessing = true;
    const e = this.components.get(zt);
    this._currentVisibleMeshes.delete(t), this._recentlyHiddenMeshes.delete(t);
    const i = this.colorMeshes.get(t.uuid), o = this._meshIDColorCodeMap.get(t.uuid);
    if (!i || !o) {
      this.isProcessing = false, console.log(t.visible);
      return;
    }
    this._colorCodeMeshMap.delete(o), this._meshIDColorCodeMap.delete(t.uuid), this.colorMeshes.delete(t.uuid), i.geometry = void 0, i.material = [], e.destroy(i, true), this._recentlyHiddenMeshes.delete(t), this._currentVisibleMeshes.delete(t), this.isProcessing = false;
  }
  getAvailableMaterial() {
    const { r: t, g: e, b: i, code: o } = this.getAvailableColor(), n = ColorManagement.enabled;
    ColorManagement.enabled = false;
    const r = new Color(`rgb(${t}, ${e}, ${i})`);
    if (!this.world.renderer)
      throw new Error("Renderer not found in the world!");
    const a = this.world.renderer.clippingPlanes, c = new MeshBasicMaterial({
      color: r,
      clippingPlanes: a,
      side: DoubleSide
    });
    return ColorManagement.enabled = n, { colorMaterial: c, code: o };
  }
};
var Ye = class Ye2 extends J {
  constructor(t) {
    super(t);
    I(this, "_enabled", true);
    I(this, "list", /* @__PURE__ */ new Map());
    I(this, "onDisposed", new D());
    t.add(Ye2.uuid, this);
  }
  /**
   * Gets the enabled state of the Cullers component.
   *
   * @returns The current enabled state.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Sets the enabled state of the Cullers component.
   * Also sets the enabled state of all MeshCullerRenderer instances.
   *
   * @param value - The new enabled state.
   */
  set enabled(t) {
    this._enabled = t;
    for (const [e, i] of this.list)
      i.enabled = t;
  }
  /**
  * Creates a new MeshCullerRenderer for the given world.
  * If a MeshCullerRenderer already exists for the world, it will return the existing one.
  *
  * @param world - The world for which to create the MeshCullerRenderer.
  * @param config - Optional configuration settings for the MeshCullerRenderer.
  *
  * @returns The newly created or existing MeshCullerRenderer for the given world.
  */
  create(t, e) {
    if (this.list.has(t.uuid))
      return this.list.get(t.uuid);
    const i = new Gr(this.components, t, e);
    return this.list.set(t.uuid, i), i;
  }
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false, this.onDisposed.trigger(Ye2.uuid), this.onDisposed.reset();
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear();
  }
};
I(Ye, "uuid", "69f2a50d-c266-44fc-b1bd-fa4d34be89e6");
var Ti = Ye;
var zr = class {
  constructor(s) {
    I(this, "onDisposed", new D());
    I(this, "onAfterUpdate", new D());
    I(this, "onBeforeUpdate", new D());
    I(this, "onResize", new D());
    I(this, "frontOffset", 0);
    I(this, "overrideMaterial", new MeshDepthMaterial());
    I(this, "backgroundColor", new Color(395274));
    I(this, "renderer");
    I(this, "enabled", true);
    I(this, "world");
    I(this, "_lockRotation", true);
    I(this, "_camera");
    I(this, "_plane");
    I(this, "_size", new Vector2(320, 160));
    I(this, "_tempVector1", new Vector3());
    I(this, "_tempVector2", new Vector3());
    I(this, "_tempTarget", new Vector3());
    I(this, "down", new Vector3(0, -1, 0));
    I(this, "updatePlanes", () => {
      if (!this.world.renderer)
        throw new Error("The given world must have a renderer!");
      const s2 = [], t2 = this.world.renderer.three;
      for (const e2 of t2.clippingPlanes)
        s2.push(e2);
      s2.push(this._plane), this.renderer.clippingPlanes = s2;
    });
    if (this.world = s, !this.world.renderer)
      throw new Error("The given world must have a renderer!");
    this.renderer = new WebGLRenderer(), this.renderer.setSize(this._size.x, this._size.y);
    const t = 1, e = this._size.x / this._size.y;
    this._camera = new OrthographicCamera(
      t * e / -2,
      t * e / 2,
      t / 2,
      t / -2
    ), this.world.renderer.onClippingPlanesUpdated.add(this.updatePlanes), this._camera.position.set(0, 200, 0), this._camera.zoom = 0.1, this._camera.rotation.x = -Math.PI / 2, this._plane = new Plane(this.down, 200), this.updatePlanes();
  }
  get lockRotation() {
    return this._lockRotation;
  }
  set lockRotation(s) {
    this._lockRotation = s, s && (this._camera.rotation.z = 0);
  }
  get zoom() {
    return this._camera.zoom;
  }
  set zoom(s) {
    this._camera.zoom = s, this._camera.updateProjectionMatrix();
  }
  dispose() {
    this.enabled = false, this.onBeforeUpdate.reset(), this.onAfterUpdate.reset(), this.onResize.reset(), this.overrideMaterial.dispose(), this.renderer.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  get() {
    return this._camera;
  }
  update() {
    if (!this.enabled)
      return;
    this.onBeforeUpdate.trigger();
    const s = this.world.scene.three, t = this.world.camera;
    if (!t.hasCameraControls())
      throw new Error("The given world must use camera controls!");
    if (!(s instanceof Scene))
      throw new Error("The given world must have a THREE.Scene as a root!");
    const e = t.controls;
    if (e.getPosition(this._tempVector1), this._camera.position.x = this._tempVector1.x, this._camera.position.z = this._tempVector1.z, this.frontOffset !== 0 && (e.getTarget(this._tempVector2), this._tempVector2.sub(this._tempVector1), this._tempVector2.normalize().multiplyScalar(this.frontOffset), this._camera.position.x += this._tempVector2.x, this._camera.position.z += this._tempVector2.z), !this._lockRotation) {
      e.getTarget(this._tempTarget);
      const o = Math.atan2(
        this._tempTarget.x - this._tempVector1.x,
        this._tempTarget.z - this._tempVector1.z
      );
      this._camera.rotation.z = o + Math.PI;
    }
    this._plane.set(this.down, this._tempVector1.y);
    const i = s.background;
    s.background = this.backgroundColor, this.renderer.render(s, this._camera), s.background = i, this.onAfterUpdate.trigger();
  }
  getSize() {
    return this._size;
  }
  resize(s = this._size) {
    this._size.copy(s), this.renderer.setSize(s.x, s.y);
    const t = s.x / s.y, e = 1;
    this._camera.left = e * t / -2, this._camera.right = e * t / 2, this._camera.top = e / 2, this._camera.bottom = -e / 2, this._camera.updateProjectionMatrix(), this.onResize.trigger(s);
  }
};
var _s = class _s2 extends J {
  constructor(t) {
    super(t);
    I(this, "onAfterUpdate", new D());
    I(this, "onBeforeUpdate", new D());
    I(this, "onDisposed", new D());
    I(this, "enabled", true);
    I(this, "list", /* @__PURE__ */ new Map());
    this.components.add(_s2.uuid, this);
  }
  create(t) {
    if (this.list.has(t.uuid))
      throw new Error("This world already has a minimap!");
    const e = new zr(t);
    return this.list.set(t.uuid, e), e;
  }
  delete(t) {
    const e = this.list.get(t);
    e && e.dispose(), this.list.delete(t);
  }
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
  update() {
    for (const [t, e] of this.list)
      e.update();
  }
};
I(_s, "uuid", "39ad6aad-84c8-4adf-a1e0-7f25313a9e7f");
var Fn = _s;
var Hr = class {
  constructor(s) {
    I(this, "enabled", false);
    I(this, "id", "FirstPerson");
    this.camera = s;
  }
  /** {@link NavigationMode.set} */
  set(s) {
    if (this.enabled = s, s) {
      if (this.camera.projection.current !== "Perspective") {
        this.camera.set("Orbit");
        return;
      }
      this.setupFirstPersonCamera();
    }
  }
  setupFirstPersonCamera() {
    const s = this.camera.controls, t = new Vector3();
    s.distance--, s.getPosition(t), s.minDistance = 1, s.maxDistance = 1, s.distance = 1, s.moveTo(
      t.x,
      t.y,
      t.z
    ), s.truckSpeed = 50, s.mouseButtons.wheel = ot.ACTION.DOLLY, s.touches.two = ot.ACTION.TOUCH_ZOOM_TRUCK;
  }
};
var kr = class {
  constructor(s) {
    I(this, "enabled", true);
    I(this, "id", "Orbit");
    this.camera = s, this.activateOrbitControls();
  }
  /** {@link NavigationMode.set} */
  set(s) {
    this.enabled = s, s && this.activateOrbitControls();
  }
  activateOrbitControls() {
    const s = this.camera.controls;
    s.minDistance = 1, s.maxDistance = 300;
    const t = new Vector3();
    s.getPosition(t);
    const e = t.length();
    s.distance = e, s.truckSpeed = 2;
    const { rotation: i } = this.camera.three, o = new Vector3(0, 0, -1).applyEuler(i), n = t.addScaledVector(o, e);
    s.moveTo(n.x, n.y, n.z);
  }
};
var Wr = class {
  constructor(s) {
    I(this, "enabled", false);
    I(this, "id", "Plan");
    I(this, "mouseAction1");
    I(this, "mouseAction2");
    I(this, "mouseInitialized", false);
    I(this, "defaultAzimuthSpeed");
    I(this, "defaultPolarSpeed");
    this.camera = s, this.defaultAzimuthSpeed = s.controls.azimuthRotateSpeed, this.defaultPolarSpeed = s.controls.polarRotateSpeed;
  }
  /** {@link NavigationMode.set} */
  set(s) {
    this.enabled = s;
    const t = this.camera.controls;
    t.azimuthRotateSpeed = s ? 0 : this.defaultAzimuthSpeed, t.polarRotateSpeed = s ? 0 : this.defaultPolarSpeed, this.mouseInitialized || (this.mouseAction1 = t.touches.one, this.mouseAction2 = t.touches.two, this.mouseInitialized = true), s ? (t.mouseButtons.left = ot.ACTION.TRUCK, t.touches.one = ot.ACTION.TOUCH_TRUCK, t.touches.two = ot.ACTION.TOUCH_ZOOM) : (t.mouseButtons.left = ot.ACTION.ROTATE, t.touches.one = this.mouseAction1, t.touches.two = this.mouseAction2);
  }
};
var Xr = class {
  constructor(s) {
    I(this, "onChanged", new D());
    I(this, "current", "Perspective");
    I(this, "camera");
    I(this, "_component");
    I(this, "_previousDistance", -1);
    I(this, "matchOrthoDistanceEnabled", false);
    this._component = s, this.camera = s.three;
  }
  /**
   * Sets the {@link CameraProjection} of the {@link OrthoPerspectiveCamera}.
   *
   * @param projection - the new projection to set. If it is the current projection,
   * it will have no effect.
   */
  async set(s) {
    this.current !== s && (s === "Orthographic" ? this.setOrthoCamera() : await this.setPerspectiveCamera(), this.onChanged.trigger(this.camera));
  }
  /**
   * Changes the current {@link CameraProjection} from Ortographic to Perspective
   * and vice versa.
   */
  async toggle() {
    const t = this.current === "Perspective" ? "Orthographic" : "Perspective";
    await this.set(t);
  }
  setOrthoCamera() {
    if (this._component.mode === null || this._component.mode.id === "FirstPerson")
      return;
    this._previousDistance = this._component.controls.distance, this._component.controls.distance = 200;
    const s = this.getPerspectiveDims();
    if (!s)
      return;
    const { width: t, height: e } = s;
    this.setupOrthoCamera(e, t), this.camera = this._component.threeOrtho, this.current = "Orthographic";
  }
  getPerspectiveDims() {
    const s = this._component.currentWorld;
    if (!s || !s.renderer)
      return null;
    const t = new Vector3();
    this._component.threePersp.getWorldDirection(t);
    const e = new Vector3();
    this._component.controls.getTarget(e);
    const o = e.clone().sub(this._component.threePersp.position).dot(t), n = s.renderer.getSize(), r = n.x / n.y, a = this._component.threePersp, c = o * 2 * Math.atan(a.fov * (Math.PI / 180) / 2);
    return { width: c * r, height: c };
  }
  setupOrthoCamera(s, t) {
    this._component.controls.mouseButtons.wheel = ot.ACTION.ZOOM, this._component.controls.mouseButtons.middle = ot.ACTION.ZOOM;
    const e = this._component.threePersp, i = this._component.threeOrtho;
    i.zoom = 1, i.left = t / -2, i.right = t / 2, i.top = s / 2, i.bottom = s / -2, i.updateProjectionMatrix(), i.position.copy(e.position), i.quaternion.copy(e.quaternion), this._component.controls.camera = i;
  }
  getDistance() {
    const s = this._component.threePersp, t = this._component.threeOrtho;
    return (t.top - t.bottom) / t.zoom / (2 * Math.atan(s.fov * (Math.PI / 180) / 2));
  }
  async setPerspectiveCamera() {
    this._component.controls.mouseButtons.wheel = ot.ACTION.DOLLY, this._component.controls.mouseButtons.middle = ot.ACTION.DOLLY;
    const s = this._component.threePersp, t = this._component.threeOrtho;
    s.position.copy(t.position), s.quaternion.copy(t.quaternion), this._component.controls.mouseButtons.wheel = ot.ACTION.DOLLY, this.matchOrthoDistanceEnabled ? this._component.controls.distance = this.getDistance() : this._component.controls.distance = this._previousDistance, await this._component.controls.zoomTo(1), s.updateProjectionMatrix(), this._component.controls.camera = s, this.camera = s, this.current = "Perspective";
  }
};
var oa = class extends ke {
  constructor(t) {
    super(t);
    I(this, "_mode", null);
    I(this, "projection");
    I(this, "threeOrtho");
    I(this, "threePersp");
    I(this, "_userInputButtons", {});
    I(this, "_frustumSize", 50);
    I(this, "_navigationModes", /* @__PURE__ */ new Map());
    I(this, "previousSize", null);
    this.threePersp = this.three, this.threeOrtho = this.newOrthoCamera(), this.projection = new Xr(this), this.onAspectUpdated.add(() => {
      this.setOrthoPerspCameraAspect();
    }), this.projection.onChanged.add(
      (e) => {
        this.three = e, this.updateAspect();
      }
    ), this.onWorldChanged.add(({ action: e }) => {
      e === "added" && (this._navigationModes.clear(), this._navigationModes.set("Orbit", new kr(this)), this._navigationModes.set("FirstPerson", new Hr(this)), this._navigationModes.set("Plan", new Wr(this)), this._mode = this._navigationModes.get("Orbit"), this.mode.set(true, { preventTargetAdjustment: true }), this.currentWorld && this.currentWorld.renderer && (this.previousSize = this.currentWorld.renderer.getSize().clone()));
    });
  }
  get mode() {
    if (!this._mode)
      throw new Error("Mode not found, camera not initialized");
    return this._mode;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    super.dispose(), this.threeOrtho.removeFromParent();
  }
  /**
   * Sets a new {@link NavigationMode} and disables the previous one.
   *
   * @param mode - The {@link NavigationMode} to set.
   */
  set(t) {
    if (this.mode !== null && this.mode.id !== t) {
      if (this.mode.set(false), !this._navigationModes.has(t))
        throw new Error("The specified mode does not exist!");
      this._mode = this._navigationModes.get(t), this.mode.set(true);
    }
  }
  /**
   * Make the camera view fit all the specified meshes.
   *
   * @param meshes the meshes to fit. If it is not defined, it will
   * evaluate {@link Components.meshes}.
   * @param offset the distance to the fit object
   */
  async fit(t, e = 1.5) {
    if (!this.enabled)
      return;
    const i = Number.MAX_VALUE, o = Number.MIN_VALUE, n = new Vector3(i, i, i), r = new Vector3(o, o, o);
    for (const u of t) {
      const p = new Box3().setFromObject(u);
      p.min.x < n.x && (n.x = p.min.x), p.min.y < n.y && (n.y = p.min.y), p.min.z < n.z && (n.z = p.min.z), p.max.x > r.x && (r.x = p.max.x), p.max.y > r.y && (r.y = p.max.y), p.max.z > r.z && (r.z = p.max.z);
    }
    const a = new Box3(n, r), c = new Vector3();
    a.getSize(c);
    const h = new Vector3();
    a.getCenter(h);
    const d = Math.max(c.x, c.y, c.z) * e, E = new Sphere(h, d);
    await this.controls.fitToSphere(E, true);
  }
  /**
   * Allows or prevents all user input.
   *
   * @param active - whether to enable or disable user inputs.
   */
  setUserInput(t) {
    t ? this.enableUserInput() : this.disableUserInput();
  }
  disableUserInput() {
    this._userInputButtons.left = this.controls.mouseButtons.left, this._userInputButtons.right = this.controls.mouseButtons.right, this._userInputButtons.middle = this.controls.mouseButtons.middle, this._userInputButtons.wheel = this.controls.mouseButtons.wheel, this.controls.mouseButtons.left = 0, this.controls.mouseButtons.right = 0, this.controls.mouseButtons.middle = 0, this.controls.mouseButtons.wheel = 0;
  }
  enableUserInput() {
    Object.keys(this._userInputButtons).length !== 0 && (this.controls.mouseButtons.left = this._userInputButtons.left, this.controls.mouseButtons.right = this._userInputButtons.right, this.controls.mouseButtons.middle = this._userInputButtons.middle, this.controls.mouseButtons.wheel = this._userInputButtons.wheel);
  }
  newOrthoCamera() {
    const t = window.innerWidth / window.innerHeight;
    return new OrthographicCamera(
      this._frustumSize * t / -2,
      this._frustumSize * t / 2,
      this._frustumSize / 2,
      this._frustumSize / -2,
      0.1,
      1e3
    );
  }
  setOrthoPerspCameraAspect() {
    if (!this.currentWorld || !this.currentWorld.renderer || !this.previousSize)
      return;
    const t = this.currentWorld.renderer.getSize(), e = this.threeOrtho.top, i = this.threeOrtho.right, o = t.y / this.previousSize.y, n = t.x / this.previousSize.x, r = e * o, a = i * n;
    this.threeOrtho.left = -a, this.threeOrtho.right = a, this.threeOrtho.top = r, this.threeOrtho.bottom = -r, this.threeOrtho.updateProjectionMatrix(), this.previousSize.copy(t);
  }
};
var At = class At2 extends J {
  constructor(t) {
    super(t);
    I(this, "enabled", true);
    I(this, "onDisposed", new D());
    I(this, "_absoluteMin");
    I(this, "_absoluteMax");
    I(this, "_meshes", []);
    this.components.add(At2.uuid, this), this._absoluteMin = At2.newBound(true), this._absoluteMax = At2.newBound(false);
  }
  static getDimensions(t) {
    const { min: e, max: i } = t, o = Math.abs(i.x - e.x), n = Math.abs(i.y - e.y), r = Math.abs(i.z - e.z), a = new Vector3();
    return a.subVectors(i, e).divideScalar(2).add(e), { width: o, height: n, depth: r, center: a };
  }
  static newBound(t) {
    const e = t ? 1 : -1;
    return new Vector3(
      e * Number.MAX_VALUE,
      e * Number.MAX_VALUE,
      e * Number.MAX_VALUE
    );
  }
  static getBounds(t, e, i) {
    const o = i || this.newBound(false), n = e || this.newBound(true);
    for (const r of t)
      r.x < n.x && (n.x = r.x), r.y < n.y && (n.y = r.y), r.z < n.z && (n.z = r.z), r.x > o.x && (o.x = r.x), r.y > o.y && (o.y = r.y), r.z > o.z && (o.z = r.z);
    return new Box3(e, i);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    const t = this.components.get(zt);
    for (const e of this._meshes)
      t.destroy(e);
    this._meshes = [], this.onDisposed.trigger(At2.uuid), this.onDisposed.reset();
  }
  get() {
    const t = this._absoluteMin.clone(), e = this._absoluteMax.clone();
    return new Box3(t, e);
  }
  getSphere() {
    const t = this._absoluteMin.clone(), e = this._absoluteMax.clone(), i = Math.abs((e.x - t.x) / 2), o = Math.abs((e.y - t.y) / 2), n = Math.abs((e.z - t.z) / 2), r = new Vector3(t.x + i, t.y + o, t.z + n), a = r.distanceTo(t);
    return new Sphere(r, a);
  }
  getMesh() {
    const t = new Box3(this._absoluteMin, this._absoluteMax), e = At2.getDimensions(t), { width: i, height: o, depth: n, center: r } = e, a = new BoxGeometry(i, o, n), c = new Mesh(a);
    return this._meshes.push(c), c.position.copy(r), c;
  }
  reset() {
    this._absoluteMin = At2.newBound(true), this._absoluteMax = At2.newBound(false);
  }
  add(t) {
    for (const e of t.items)
      this.addMesh(e.mesh);
  }
  addMesh(t, e) {
    if (!t.geometry.index)
      return;
    const i = At2.getFragmentBounds(t);
    t.updateMatrixWorld();
    const o = t.matrixWorld, n = new Matrix4(), r = t instanceof InstancedMesh, a = /* @__PURE__ */ new Set();
    if (e && t instanceof Js)
      for (const c of e) {
        const h = t.fragment.getInstancesIDs(c);
        if (h)
          for (const d of h)
            a.add(d);
      }
    else
      a.add(0);
    for (const c of a) {
      const h = i.min.clone(), d = i.max.clone();
      r && (t.getMatrixAt(c, n), h.applyMatrix4(n), d.applyMatrix4(n)), h.applyMatrix4(o), d.applyMatrix4(o), h.x < this._absoluteMin.x && (this._absoluteMin.x = h.x), h.y < this._absoluteMin.y && (this._absoluteMin.y = h.y), h.z < this._absoluteMin.z && (this._absoluteMin.z = h.z), h.x > this._absoluteMax.x && (this._absoluteMax.x = h.x), h.y > this._absoluteMax.y && (this._absoluteMax.y = h.y), h.z > this._absoluteMax.z && (this._absoluteMax.z = h.z), d.x > this._absoluteMax.x && (this._absoluteMax.x = d.x), d.y > this._absoluteMax.y && (this._absoluteMax.y = d.y), d.z > this._absoluteMax.z && (this._absoluteMax.z = d.z), d.x < this._absoluteMin.x && (this._absoluteMin.x = d.x), d.y < this._absoluteMin.y && (this._absoluteMin.y = d.y), d.z < this._absoluteMin.z && (this._absoluteMin.z = d.z);
    }
  }
  static getFragmentBounds(t) {
    const e = t.geometry.attributes.position, i = Number.MAX_VALUE, o = -i, n = new Vector3(i, i, i), r = new Vector3(o, o, o);
    if (!t.geometry.index)
      throw new Error("Geometry must be indexed!");
    const a = Array.from(t.geometry.index.array);
    for (let c = 0; c < a.length; c++) {
      if (c % 3 === 0 && a[c] === 0 && a[c + 1] === 0 && a[c + 2] === 0) {
        c += 2;
        continue;
      }
      const h = a[c], d = e.getX(h), E = e.getY(h), u = e.getZ(h);
      d < n.x && (n.x = d), E < n.y && (n.y = E), u < n.z && (n.z = u), d > r.x && (r.x = d), E > r.y && (r.y = E), u > r.z && (r.z = u);
    }
    return new Box3(n, r);
  }
};
I(At, "uuid", "d1444724-dba6-4cdd-a0c7-68ee1450d166");
var On = At;
var Li = /* @__PURE__ */ new Set([
  1123145078,
  574549367,
  1675464909,
  2059837836,
  3798115385,
  32440307,
  3125803723,
  3207858831,
  2740243338,
  2624227202,
  4240577450,
  3615266464,
  3724593414,
  220341763,
  477187591,
  1878645084,
  1300840506,
  3303107099,
  1607154358,
  1878645084,
  846575682,
  1351298697,
  2417041796,
  3049322572,
  3331915920,
  1416205885,
  776857604,
  3285139300,
  3958052878,
  2827736869,
  2732653382,
  673634403,
  3448662350,
  4142052618,
  2924175390,
  803316827,
  2556980723,
  1809719519,
  2205249479,
  807026263,
  3737207727,
  1660063152,
  2347385850,
  3940055652,
  2705031697,
  3732776249,
  2485617015,
  2611217952,
  1704287377,
  2937912522,
  2770003689,
  1281925730,
  1484403080,
  3448662350,
  4142052618,
  3800577675,
  4006246654,
  3590301190,
  1383045692,
  2775532180,
  2047409740,
  370225590,
  3593883385,
  2665983363,
  4124623270,
  812098782,
  3649129432,
  987898635,
  1105321065,
  3510044353,
  1635779807,
  2603310189,
  3406155212,
  1310608509,
  4261334040,
  2736907675,
  3649129432,
  1136057603,
  1260505505,
  4182860854,
  2713105998,
  2898889636,
  59481748,
  3749851601,
  3486308946,
  3150382593,
  1062206242,
  3264961684,
  15328376,
  1485152156,
  370225590,
  1981873012,
  2859738748,
  45288368,
  2614616156,
  2732653382,
  775493141,
  2147822146,
  2601014836,
  2629017746,
  1186437898,
  2367409068,
  1213902940,
  3632507154,
  3900360178,
  476780140,
  1472233963,
  2804161546,
  3008276851,
  738692330,
  374418227,
  315944413,
  3905492369,
  3570813810,
  2571569899,
  178912537,
  2294589976,
  1437953363,
  2133299955,
  572779678,
  3092502836,
  388784114,
  2624227202,
  1425443689,
  3057273783,
  2347385850,
  1682466193,
  2519244187,
  2839578677,
  3958567839,
  2513912981,
  2830218821,
  427810014
]);
var Ns = class Ns2 extends J {
  constructor(t) {
    super(t);
    I(this, "enabled", true);
    t.add(Ns2.uuid, this);
  }
  /**
   * Exports all the properties of an IFC into an array of JS objects.
   * @param webIfc The instance of [web-ifc]{@link https://github.com/ThatOpen/engine_web-ifc} to use.
   * @param modelID ID of the IFC model whose properties to extract.
   * @param indirect whether to get the indirect relationships as well.
   * @param recursiveSpatial whether to get the properties of spatial items recursively
   * to make the location data available (e.g. absolute position of building).
   */
  async export(t, e, i = false, o = true) {
    const n = {}, r = new Set(t.GetIfcEntityList(e)), a = /* @__PURE__ */ new Set([
      IFCPROJECT,
      IFCSITE,
      IFCBUILDING,
      IFCBUILDINGSTOREY,
      IFCSPACE
    ]);
    for (const c of a)
      r.add(c);
    for (const c of r) {
      if (Li.has(c))
        continue;
      const h = a.has(c) && o, d = t.GetLineIDsWithType(e, c);
      for (const E of d) {
        const u = t.GetLine(0, E, h, i);
        n[u.expressID] = u;
      }
    }
    return n;
  }
};
I(Ns, "uuid", "b32c4332-cd67-436e-ba7f-196646c7a635");
var mi = Ns;
var Ps = class Ps2 extends J {
  constructor(t) {
    super(t);
    I(this, "onDisposed", new D());
    I(this, "onFragmentsLoaded", new D());
    I(this, "onFragmentsDisposed", new D());
    I(this, "list", /* @__PURE__ */ new Map());
    I(this, "groups", /* @__PURE__ */ new Map());
    I(this, "enabled", true);
    I(this, "baseCoordinationModel", "");
    I(this, "_loader", new Hi());
    this.components.add(Ps2.uuid, this);
  }
  /** The list of meshes of the created fragments. */
  get meshes() {
    const t = [];
    for (const [e, i] of this.list)
      t.push(i.mesh);
    return t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.groups)
      e.dispose(true);
    this.baseCoordinationModel = "", this.groups.clear(), this.list.clear(), this.onFragmentsLoaded.reset(), this.onFragmentsDisposed.reset(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  disposeGroup(t) {
    const { uuid: e } = t, i = [];
    for (const o of t.items)
      i.push(o.id), this.list.delete(o.id);
    t.dispose(true), this.groups.delete(t.uuid), this.onFragmentsDisposed.trigger({
      groupID: e,
      fragmentIDs: i
    });
  }
  /**
   * Loads a binar file that contain fragment geometry.
   * @param data - The binary data to load.
   * @param config - Optional configuration for loading.
   * @param config.coordinate - Whether to apply coordinate transformation. Default is true.
   * @param config.properties - Ifc properties to set on the loaded fragments. Not to be used when streaming.
   * @returns The loaded FragmentsGroup.
   */
  load(t, e) {
    const o = { ...{ coordinate: true }, ...e }, { coordinate: n, name: r, properties: a, relationsMap: c } = o, h = this._loader.import(t);
    r && (h.name = r);
    for (const d of h.items)
      d.group = h, this.list.set(d.id, d);
    return n && this.coordinate([h]), this.groups.set(h.uuid, h), a && h.setLocalProperties(a), c && this.components.get(We).setRelationMap(h, c), this.onFragmentsLoaded.trigger(h), h;
  }
  /**
   * Export the specified fragments.
   * @param group - the fragments group to be exported.
   * @returns the exported data as binary buffer.
   */
  export(t) {
    return this._loader.export(t);
  }
  coordinate(t = Array.from(this.groups.values())) {
    if (this.baseCoordinationModel.length === 0) {
      const o = t.pop();
      if (!o)
        return;
      this.baseCoordinationModel = o.uuid;
    }
    if (!t.length)
      return;
    const i = this.groups.get(this.baseCoordinationModel);
    if (!i) {
      console.log("No base model found for coordination!");
      return;
    }
    for (const o of t)
      o !== i && (o.position.set(0, 0, 0), o.rotation.set(0, 0, 0), o.scale.set(1, 1, 1), o.updateMatrix(), o.applyMatrix4(o.coordinationMatrix.clone().invert()), o.applyMatrix4(i.coordinationMatrix));
  }
};
I(Ps, "uuid", "fef46874-46a3-461b-8c44-2922ab77c806");
var ut = Ps;
var Zr = /* @__PURE__ */ new Map([
  [
    IFCRELAGGREGATES,
    {
      forRelating: "IsDecomposedBy",
      forRelated: "Decomposes"
    }
  ],
  [
    IFCRELASSOCIATESMATERIAL,
    {
      forRelating: "AssociatedTo",
      forRelated: "HasAssociations"
    }
  ],
  [
    IFCRELASSOCIATESCLASSIFICATION,
    {
      forRelating: "ClassificationForObjects",
      forRelated: "HasAssociations"
    }
  ],
  [
    IFCRELASSIGNSTOGROUP,
    {
      forRelating: "IsGroupedBy",
      forRelated: "HasAssignments"
    }
  ],
  [
    IFCRELDEFINESBYPROPERTIES,
    {
      forRelated: "IsDefinedBy",
      forRelating: "DefinesOcurrence"
    }
  ],
  [
    IFCRELDEFINESBYTYPE,
    {
      forRelated: "IsTypedBy",
      forRelating: "Types"
    }
  ],
  [
    IFCRELDEFINESBYTEMPLATE,
    {
      forRelated: "IsDefinedBy",
      forRelating: "Defines"
    }
  ],
  [
    IFCRELCONTAINEDINSPATIALSTRUCTURE,
    {
      forRelated: "ContainedInStructure",
      forRelating: "ContainsElements"
    }
  ]
]);
var Ve = class Ve2 extends J {
  constructor(t) {
    super(t);
    I(this, "onDisposed", new D());
    I(this, "enabled", true);
    I(this, "onRelationsIndexed", new D());
    I(this, "_relToAttributesMap", Zr);
    I(this, "_inverseAttributes", [
      "IsDecomposedBy",
      "Decomposes",
      "AssociatedTo",
      "HasAssociations",
      "ClassificationForObjects",
      "IsGroupedBy",
      "HasAssignments",
      "IsDefinedBy",
      "DefinesOcurrence",
      "IsTypedBy",
      "Types",
      "Defines",
      "ContainedInStructure",
      "ContainsElements"
    ]);
    I(this, "_ifcRels", [
      IFCRELAGGREGATES,
      IFCRELASSOCIATESMATERIAL,
      IFCRELASSOCIATESCLASSIFICATION,
      IFCRELASSIGNSTOGROUP,
      IFCRELDEFINESBYPROPERTIES,
      IFCRELDEFINESBYTYPE,
      IFCRELDEFINESBYTEMPLATE,
      IFCRELCONTAINEDINSPATIALSTRUCTURE
    ]);
    I(this, "relationMaps", {});
    I(this, "onFragmentsDisposed", (t2) => {
      delete this.relationMaps[t2.groupID];
    });
    this.components.add(Ve2.uuid, this), t.get(ut).onFragmentsDisposed.add(this.onFragmentsDisposed);
  }
  indexRelations(t, e, i, o) {
    const n = Object.keys(e).find(
      (E) => E.startsWith("Relating")
    ), r = Object.keys(e).find(
      (E) => E.startsWith("Related")
    );
    if (!(n && r))
      return;
    const a = e[n].value, c = e[r].map((E) => E.value), h = t.get(a) ?? /* @__PURE__ */ new Map(), d = this._inverseAttributes.indexOf(o);
    h.set(d, c), t.set(a, h);
    for (const E of c) {
      const u = t.get(E) ?? /* @__PURE__ */ new Map(), p = this._inverseAttributes.indexOf(i), A = u.get(p) ?? [];
      A.push(a), u.set(p, A), t.set(E, u);
    }
  }
  /**
   * Adds a relation map to the model's relations map.
   *
   * @param model - The `FragmentsGroup` model to which the relation map will be added.
   * @param relationMap - The `RelationsMap` to be added to the model's relations map.
   *
   * @fires onRelationsIndexed - Triggers an event with the model's UUID and the added relation map.
   */
  setRelationMap(t, e) {
    this.relationMaps[t.uuid] = e, this.onRelationsIndexed.trigger({
      modelID: t.uuid,
      relationsMap: e
    });
  }
  /**
   * Processes a given model to index its IFC entities relations based on predefined inverse attributes.
   * This method iterates through each specified inverse attribute, retrieves the corresponding relations,
   * and maps them in a structured way to facilitate quick access to related entities.
   *
   * The process involves querying the model for each relation type associated with the inverse attributes
   * and updating the internal relationMaps with the relationships found. This map is keyed by the model's UUID
   * and contains a nested map where each key is an entity's expressID and its value is another map.
   * This inner map's keys are the indices of the inverse attributes, and its values are arrays of expressIDs
   * of entities that are related through that attribute.
   *
   * @param model The `FragmentsGroup` model to be processed. It must have properties loaded.
   * @returns A promise that resolves to the relations map for the processed model. This map is a detailed
   * representation of the relations indexed by entity expressIDs and relation types.
   * @throws An error if the model does not have properties loaded.
   */
  async process(t) {
    if (!t.hasProperties)
      throw new Error("FragmentsGroup properties not found");
    let e = this.relationMaps[t.uuid];
    if (e)
      return e;
    e = /* @__PURE__ */ new Map();
    for (const i of this._ifcRels) {
      const o = await t.getAllPropertiesOfType(i);
      if (!o)
        continue;
      const n = this._relToAttributesMap.get(i);
      if (!n)
        continue;
      const { forRelated: r, forRelating: a } = n;
      for (const c in o) {
        const h = o[c];
        this.indexRelations(e, h, r, a);
      }
    }
    return this.setRelationMap(t, e), e;
  }
  /**
   * Processes a given model from a WebIfc API to index its IFC entities relations.
   *
   * @param ifcApi - The WebIfc API instance from which to retrieve the model's properties.
   * @param modelID - The unique identifier of the model within the WebIfc API.
   * @returns A promise that resolves to the relations map for the processed model.
   *          This map is a detailed representation of the relations indexed by entity expressIDs and relation types.
   */
  async processFromWebIfc(t, e) {
    const i = /* @__PURE__ */ new Map();
    for (const o of this._ifcRels) {
      const n = this._relToAttributesMap.get(o);
      if (!n)
        continue;
      const { forRelated: r, forRelating: a } = n, c = t.GetLineIDsWithType(e, o);
      for (let h = 0; h < c.size(); h++) {
        const d = await t.properties.getItemProperties(
          e,
          c.get(h)
        );
        this.indexRelations(i, d, r, a);
      }
    }
    return this.onRelationsIndexed.trigger({
      modelID: e.toString(),
      relationsMap: i
    }), i;
  }
  /**
   * Retrieves the relations of a specific entity within a model based on the given relation name.
   * This method searches the indexed relation maps for the specified model and entity,
   * returning the IDs of related entities if a match is found.
   *
   * @param model The `FragmentsGroup` model containing the entity.
   * @param expressID The unique identifier of the entity within the model.
   * @param relationName The IFC schema inverse attribute of the relation to search for (e.g., "IsDefinedBy", "ContainsElements").
   * @returns An array of express IDs representing the related entities, or `null` if no relations are found
   * or the specified relation name is not indexed.
   */
  getEntityRelations(t, e, i) {
    const o = this.relationMaps[t.uuid];
    if (!o)
      return null;
    const n = o.get(e), r = this._inverseAttributes.indexOf(i);
    if (!n || r === -1)
      return null;
    const a = n.get(r);
    return a || null;
  }
  /**
   * Serializes the relations of a given relation map into a JSON string.
   * This method iterates through the relations in the given map, organizing them into a structured object where each key is an expressID of an entity,
   * and its value is another object mapping relation indices to arrays of related entity expressIDs.
   * The resulting object is then serialized into a JSON string.
   *
   * @param relationMap - The map of relations to be serialized. The map keys are expressIDs of entities, and the values are maps where each key is a relation type ID and its value is an array of expressIDs of entities related through that relation type.
   * @returns A JSON string representing the serialized relations of the given relation map.
   */
  serializeRelations(t) {
    const e = {};
    for (const [i, o] of t.entries()) {
      e[i] || (e[i] = {});
      for (const [n, r] of o.entries())
        e[i][n] = r;
    }
    return JSON.stringify(e);
  }
  /**
   * Serializes the relations of a specific model into a JSON string.
   * This method iterates through the relations indexed for the given model,
   * organizing them into a structured object where each key is an expressID of an entity,
   * and its value is another object mapping relation indices to arrays of related entity expressIDs.
   * The resulting object is then serialized into a JSON string.
   *
   * @param model The `FragmentsGroup` model whose relations are to be serialized.
   * @returns A JSON string representing the serialized relations of the specified model.
   * If the model has no indexed relations, `null` is returned.
   */
  serializeModelRelations(t) {
    const e = this.relationMaps[t.uuid];
    return e ? this.serializeRelations(e) : null;
  }
  /**
   * Serializes all relations of every model processed by the indexer into a JSON string.
   * This method iterates through each model's relations indexed in `relationMaps`, organizing them
   * into a structured JSON object. Each top-level key in this object corresponds to a model's UUID,
   * and its value is another object mapping entity expressIDs to their related entities, categorized
   * by relation types. The structure facilitates easy access to any entity's relations across all models.
   *
   * @returns A JSON string representing the serialized relations of all models processed by the indexer.
   *          If no relations have been indexed, an empty object is returned as a JSON string.
   */
  serializeAllRelations() {
    const t = {};
    for (const e in this.relationMaps) {
      const i = this.relationMaps[e], o = {};
      for (const [n, r] of i.entries()) {
        o[n] || (o[n] = {});
        for (const [a, c] of r.entries())
          o[n][a] = c;
      }
      t[e] = o;
    }
    return JSON.stringify(t);
  }
  /**
   * Converts a JSON string representing relations between entities into a structured map.
   * This method parses the JSON string to reconstruct the relations map that indexes
   * entity relations by their express IDs. The outer map keys are the express IDs of entities,
   * and the values are maps where each key is a relation type ID and its value is an array
   * of express IDs of entities related through that relation type.
   *
   * @param json The JSON string to be parsed into the relations map.
   * @returns A `Map` where the key is the express ID of an entity as a number, and the value
   * is another `Map`. This inner map's key is the relation type ID as a number, and its value
   * is an array of express IDs (as numbers) of entities related through that relation type.
   */
  getRelationsMapFromJSON(t) {
    const e = JSON.parse(t), i = /* @__PURE__ */ new Map();
    for (const o in e) {
      const n = e[o], r = /* @__PURE__ */ new Map();
      for (const a in n)
        r.set(Number(a), n[a]);
      i.set(Number(o), r);
    }
    return i;
  }
  /**
   * Disposes the component, cleaning up resources and detaching event listeners.
   * This ensures that the component is properly cleaned up and does not leave behind any
   * references that could prevent garbage collection.
   */
  dispose() {
    this.relationMaps = {}, this.components.get(ut).onFragmentsDisposed.remove(this.onFragmentsDisposed), this.onDisposed.trigger(Ve2.uuid), this.onDisposed.reset();
  }
};
I(Ve, "uuid", "23a889ab-83b3-44a4-8bee-ead83438370b");
var We = Ve;
var Qr = {
  103090709: "IFCPROJECT",
  4097777520: "IFCSITE",
  4031249490: "IFCBUILDING",
  3124254112: "IFCBUILDINGSTOREY",
  3856911033: "IFCSPACE",
  1674181508: "IFCANNOTATION",
  25142252: "IFCCONTROLLER",
  32344328: "IFCBOILER",
  76236018: "IFCLAMP",
  90941305: "IFCPUMP",
  177149247: "IFCAIRTERMINALBOX",
  182646315: "IFCFLOWINSTRUMENT",
  263784265: "IFCFURNISHINGELEMENT",
  264262732: "IFCELECTRICGENERATOR",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  310824031: "IFCPIPEFITTING",
  331165859: "IFCSTAIR",
  342316401: "IFCDUCTFITTING",
  377706215: "IFCMECHANICALFASTENER",
  395920057: "IFCDOOR",
  402227799: "IFCELECTRICMOTOR",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  484807127: "IFCEVAPORATOR",
  486154966: "IFCWINDOWSTANDARDCASE",
  629592764: "IFCLIGHTFIXTURE",
  630975310: "IFCUNITARYCONTROLELEMENT",
  635142910: "IFCCABLECARRIERFITTING",
  639361253: "IFCCOIL",
  647756555: "IFCFASTENER",
  707683696: "IFCFLOWSTORAGEDEVICE",
  738039164: "IFCPROTECTIVEDEVICE",
  753842376: "IFCBEAM",
  812556717: "IFCTANK",
  819412036: "IFCFILTER",
  843113511: "IFCCOLUMN",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  900683007: "IFCFOOTING",
  905975707: "IFCCOLUMNSTANDARDCASE",
  926996030: "IFCVOIDINGFEATURE",
  979691226: "IFCREINFORCINGBAR",
  987401354: "IFCFLOWSEGMENT",
  1003880860: "IFCELECTRICTIMECONTROL",
  1051757585: "IFCCABLEFITTING",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  1073191201: "IFCMEMBER",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  1156407060: "IFCPLATESTANDARDCASE",
  1162798199: "IFCSWITCHINGDEVICE",
  1329646415: "IFCSHADINGDEVICE",
  1335981549: "IFCDISCRETEACCESSORY",
  1360408905: "IFCDUCTSILENCER",
  1404847402: "IFCSTACKTERMINAL",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  1437502449: "IFCMEDICALDEVICE",
  1509553395: "IFCFURNITURE",
  1529196076: "IFCSLAB",
  1620046519: "IFCTRANSPORTELEMENT",
  1634111441: "IFCAIRTERMINAL",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  1677625105: "IFCCIVILELEMENT",
  1687234759: "IFCPILE",
  1904799276: "IFCELECTRICAPPLIANCE",
  1911478936: "IFCMEMBERSTANDARDCASE",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  1973544240: "IFCCOVERING",
  1999602285: "IFCSPACEHEATER",
  2016517767: "IFCROOF",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  2058353004: "IFCFLOWCONTROLLER",
  2068733104: "IFCHUMIDIFIER",
  2176052936: "IFCJUNCTIONBOX",
  2188021234: "IFCFLOWMETER",
  2223149337: "IFCFLOWTERMINAL",
  2262370178: "IFCRAILING",
  2272882330: "IFCCONDENSER",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  2320036040: "IFCREINFORCINGMESH",
  2347447852: "IFCTENDONANCHOR",
  2391383451: "IFCVIBRATIONISOLATOR",
  2391406946: "IFCWALL",
  2474470126: "IFCMOTORCONNECTION",
  2769231204: "IFCVIRTUALELEMENT",
  2814081492: "IFCENGINE",
  2906023776: "IFCBEAMSTANDARDCASE",
  2938176219: "IFCBURNER",
  2979338954: "IFCBUILDINGELEMENTPART",
  3024970846: "IFCRAMP",
  3026737570: "IFCTUBEBUNDLE",
  3027962421: "IFCSLABSTANDARDCASE",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  3053780830: "IFCSANITARYTERMINAL",
  3079942009: "IFCOPENINGSTANDARDCASE",
  3087945054: "IFCALARM",
  3101698114: "IFCSURFACEFEATURE",
  3127900445: "IFCSLABELEMENTEDCASE",
  3132237377: "IFCFLOWMOVINGDEVICE",
  3171933400: "IFCPLATE",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  3242481149: "IFCDOORSTANDARDCASE",
  3283111854: "IFCRAMPFLIGHT",
  3296154744: "IFCCHIMNEY",
  3304561284: "IFCWINDOW",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  3319311131: "IFCHEATEXCHANGER",
  3415622556: "IFCFAN",
  3420628829: "IFCSOLARDEVICE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  3495092785: "IFCCURTAINWALL",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  3512223829: "IFCWALLSTANDARDCASE",
  3518393246: "IFCDUCTSEGMENT",
  3571504051: "IFCCOMPRESSOR",
  3588315303: "IFCOPENINGELEMENT",
  3612865200: "IFCPIPESEGMENT",
  3640358203: "IFCCOOLINGTOWER",
  3651124850: "IFCPROJECTIONELEMENT",
  3694346114: "IFCOUTLET",
  3747195512: "IFCEVAPORATIVECOOLER",
  3758799889: "IFCCABLECARRIERSEGMENT",
  3824725483: "IFCTENDON",
  3825984169: "IFCTRANSFORMER",
  3902619387: "IFCCHILLER",
  4074379575: "IFCDAMPER",
  4086658281: "IFCSENSOR",
  4123344466: "IFCELEMENTASSEMBLY",
  4136498852: "IFCCOOLEDBEAM",
  4156078855: "IFCWALLELEMENTEDCASE",
  4175244083: "IFCINTERCEPTOR",
  4207607924: "IFCVALVE",
  4217484030: "IFCCABLESEGMENT",
  4237592921: "IFCWASTETERMINAL",
  4252922144: "IFCSTAIRFLIGHT",
  4278956645: "IFCFLOWFITTING",
  4288193352: "IFCACTUATOR",
  4292641817: "IFCUNITARYEQUIPMENT",
  3009204131: "IFCGRID"
};
var ra = class {
  getAll(s, t) {
    const e = {}, i = Object.keys(Qr).map((o) => parseInt(o, 10));
    for (let o = 0; o < i.length; o++) {
      const n = i[o], r = s.GetLineIDsWithType(t, n), a = r.size();
      for (let c = 0; c < a; c++)
        e[r.get(c)] = n;
    }
    return e;
  }
};
var Bn = {
  950732822: "IFCURIREFERENCE",
  4075327185: "IFCTIME",
  1209108979: "IFCTEMPERATURERATEOFCHANGEMEASURE",
  3457685358: "IFCSOUNDPRESSURELEVELMEASURE",
  4157543285: "IFCSOUNDPOWERLEVELMEASURE",
  2798247006: "IFCPROPERTYSETDEFINITIONSET",
  1790229001: "IFCPOSITIVEINTEGER",
  525895558: "IFCNONNEGATIVELENGTHMEASURE",
  1774176899: "IFCLINEINDEX",
  1275358634: "IFCLANGUAGEID",
  2541165894: "IFCDURATION",
  3701338814: "IFCDAYINWEEKNUMBER",
  2195413836: "IFCDATETIME",
  937566702: "IFCDATE",
  1683019596: "IFCCARDINALPOINTREFERENCE",
  2314439260: "IFCBINARY",
  1500781891: "IFCAREADENSITYMEASURE",
  3683503648: "IFCARCINDEX",
  4065007721: "IFCYEARNUMBER",
  1718600412: "IFCWARPINGMOMENTMEASURE",
  51269191: "IFCWARPINGCONSTANTMEASURE",
  2593997549: "IFCVOLUMETRICFLOWRATEMEASURE",
  3458127941: "IFCVOLUMEMEASURE",
  3345633955: "IFCVAPORPERMEABILITYMEASURE",
  1278329552: "IFCTORQUEMEASURE",
  2591213694: "IFCTIMESTAMP",
  2726807636: "IFCTIMEMEASURE",
  743184107: "IFCTHERMODYNAMICTEMPERATUREMEASURE",
  2016195849: "IFCTHERMALTRANSMITTANCEMEASURE",
  857959152: "IFCTHERMALRESISTANCEMEASURE",
  2281867870: "IFCTHERMALEXPANSIONCOEFFICIENTMEASURE",
  2645777649: "IFCTHERMALCONDUCTIVITYMEASURE",
  232962298: "IFCTHERMALADMITTANCEMEASURE",
  296282323: "IFCTEXTTRANSFORMATION",
  603696268: "IFCTEXTFONTNAME",
  3490877962: "IFCTEXTDECORATION",
  1460886941: "IFCTEXTALIGNMENT",
  2801250643: "IFCTEXT",
  58845555: "IFCTEMPERATUREGRADIENTMEASURE",
  361837227: "IFCSPECULARROUGHNESS",
  2757832317: "IFCSPECULAREXPONENT",
  3477203348: "IFCSPECIFICHEATCAPACITYMEASURE",
  993287707: "IFCSOUNDPRESSUREMEASURE",
  846465480: "IFCSOUNDPOWERMEASURE",
  3471399674: "IFCSOLIDANGLEMEASURE",
  408310005: "IFCSHEARMODULUSMEASURE",
  2190458107: "IFCSECTIONALAREAINTEGRALMEASURE",
  3467162246: "IFCSECTIONMODULUSMEASURE",
  2766185779: "IFCSECONDINMINUTE",
  3211557302: "IFCROTATIONALSTIFFNESSMEASURE",
  1755127002: "IFCROTATIONALMASSMEASURE",
  2133746277: "IFCROTATIONALFREQUENCYMEASURE",
  200335297: "IFCREAL",
  96294661: "IFCRATIOMEASURE",
  3972513137: "IFCRADIOACTIVITYMEASURE",
  3665567075: "IFCPRESSUREMEASURE",
  2169031380: "IFCPRESENTABLETEXT",
  1364037233: "IFCPOWERMEASURE",
  1245737093: "IFCPOSITIVERATIOMEASURE",
  3054510233: "IFCPOSITIVEPLANEANGLEMEASURE",
  2815919920: "IFCPOSITIVELENGTHMEASURE",
  4042175685: "IFCPLANEANGLEMEASURE",
  2642773653: "IFCPLANARFORCEMEASURE",
  2260317790: "IFCPARAMETERVALUE",
  929793134: "IFCPHMEASURE",
  2395907400: "IFCNUMERICMEASURE",
  2095195183: "IFCNORMALISEDRATIOMEASURE",
  765770214: "IFCMONTHINYEARNUMBER",
  2615040989: "IFCMONETARYMEASURE",
  3114022597: "IFCMOMENTOFINERTIAMEASURE",
  1648970520: "IFCMOLECULARWEIGHTMEASURE",
  3177669450: "IFCMOISTUREDIFFUSIVITYMEASURE",
  1753493141: "IFCMODULUSOFSUBGRADEREACTIONMEASURE",
  1052454078: "IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE",
  2173214787: "IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE",
  3341486342: "IFCMODULUSOFELASTICITYMEASURE",
  102610177: "IFCMINUTEINHOUR",
  3531705166: "IFCMASSPERLENGTHMEASURE",
  3124614049: "IFCMASSMEASURE",
  4017473158: "IFCMASSFLOWRATEMEASURE",
  1477762836: "IFCMASSDENSITYMEASURE",
  2486716878: "IFCMAGNETICFLUXMEASURE",
  286949696: "IFCMAGNETICFLUXDENSITYMEASURE",
  151039812: "IFCLUMINOUSINTENSITYMEASURE",
  2755797622: "IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE",
  2095003142: "IFCLUMINOUSFLUXMEASURE",
  503418787: "IFCLOGICAL",
  3086160713: "IFCLINEARVELOCITYMEASURE",
  1307019551: "IFCLINEARSTIFFNESSMEASURE",
  2128979029: "IFCLINEARMOMENTMEASURE",
  191860431: "IFCLINEARFORCEMEASURE",
  1243674935: "IFCLENGTHMEASURE",
  3258342251: "IFCLABEL",
  2054016361: "IFCKINEMATICVISCOSITYMEASURE",
  3192672207: "IFCISOTHERMALMOISTURECAPACITYMEASURE",
  3686016028: "IFCIONCONCENTRATIONMEASURE",
  3809634241: "IFCINTEGERCOUNTRATEMEASURE",
  1939436016: "IFCINTEGER",
  2679005408: "IFCINDUCTANCEMEASURE",
  3358199106: "IFCILLUMINANCEMEASURE",
  983778844: "IFCIDENTIFIER",
  2589826445: "IFCHOURINDAY",
  1158859006: "IFCHEATINGVALUEMEASURE",
  3113092358: "IFCHEATFLUXDENSITYMEASURE",
  3064340077: "IFCGLOBALLYUNIQUEID",
  3044325142: "IFCFREQUENCYMEASURE",
  1361398929: "IFCFORCEMEASURE",
  2590844177: "IFCFONTWEIGHT",
  2715512545: "IFCFONTVARIANT",
  1102727119: "IFCFONTSTYLE",
  2078135608: "IFCENERGYMEASURE",
  2506197118: "IFCELECTRICVOLTAGEMEASURE",
  2951915441: "IFCELECTRICRESISTANCEMEASURE",
  3790457270: "IFCELECTRICCURRENTMEASURE",
  2093906313: "IFCELECTRICCONDUCTANCEMEASURE",
  3818826038: "IFCELECTRICCHARGEMEASURE",
  1827137117: "IFCELECTRICCAPACITANCEMEASURE",
  69416015: "IFCDYNAMICVISCOSITYMEASURE",
  524656162: "IFCDOSEEQUIVALENTMEASURE",
  4134073009: "IFCDIMENSIONCOUNT",
  1514641115: "IFCDESCRIPTIVEMEASURE",
  300323983: "IFCDAYLIGHTSAVINGHOUR",
  86635668: "IFCDAYINMONTHNUMBER",
  94842927: "IFCCURVATUREMEASURE",
  1778710042: "IFCCOUNTMEASURE",
  3238673880: "IFCCONTEXTDEPENDENTMEASURE",
  3812528620: "IFCCOMPOUNDPLANEANGLEMEASURE",
  2991860651: "IFCCOMPLEXNUMBER",
  1867003952: "IFCBOXALIGNMENT",
  2735952531: "IFCBOOLEAN",
  2650437152: "IFCAREAMEASURE",
  632304761: "IFCANGULARVELOCITYMEASURE",
  360377573: "IFCAMOUNTOFSUBSTANCEMEASURE",
  4182062534: "IFCACCELERATIONMEASURE",
  3699917729: "IFCABSORBEDDOSEMEASURE",
  1971632696: "IFCGEOSLICE",
  2680139844: "IFCGEOMODEL",
  24726584: "IFCELECTRICFLOWTREATMENTDEVICE",
  3693000487: "IFCDISTRIBUTIONBOARD",
  3460952963: "IFCCONVEYORSEGMENT",
  3999819293: "IFCCAISSONFOUNDATION",
  3314249567: "IFCBOREHOLE",
  4196446775: "IFCBEARING",
  325726236: "IFCALIGNMENT",
  3425753595: "IFCTRACKELEMENT",
  991950508: "IFCSIGNAL",
  3798194928: "IFCREINFORCEDSOIL",
  3290496277: "IFCRAIL",
  1383356374: "IFCPAVEMENT",
  2182337498: "IFCNAVIGATIONELEMENT",
  234836483: "IFCMOORINGDEVICE",
  2078563270: "IFCMOBILETELECOMMUNICATIONSAPPLIANCE",
  1638804497: "IFCLIQUIDTERMINAL",
  1154579445: "IFCLINEARPOSITIONINGELEMENT",
  2696325953: "IFCKERB",
  2713699986: "IFCGEOTECHNICALASSEMBLY",
  2142170206: "IFCELECTRICFLOWTREATMENTDEVICETYPE",
  3376911765: "IFCEARTHWORKSFILL",
  1077100507: "IFCEARTHWORKSELEMENT",
  3071239417: "IFCEARTHWORKSCUT",
  479945903: "IFCDISTRIBUTIONBOARDTYPE",
  3426335179: "IFCDEEPFOUNDATION",
  1502416096: "IFCCOURSE",
  2940368186: "IFCCONVEYORSEGMENTTYPE",
  3203706013: "IFCCAISSONFOUNDATIONTYPE",
  3862327254: "IFCBUILTSYSTEM",
  1876633798: "IFCBUILTELEMENT",
  963979645: "IFCBRIDGEPART",
  644574406: "IFCBRIDGE",
  3649138523: "IFCBEARINGTYPE",
  1662888072: "IFCALIGNMENTVERTICAL",
  317615605: "IFCALIGNMENTSEGMENT",
  1545765605: "IFCALIGNMENTHORIZONTAL",
  4266260250: "IFCALIGNMENTCANT",
  3956297820: "IFCVIBRATIONDAMPERTYPE",
  1530820697: "IFCVIBRATIONDAMPER",
  840318589: "IFCVEHICLE",
  1953115116: "IFCTRANSPORTATIONDEVICE",
  618700268: "IFCTRACKELEMENTTYPE",
  2281632017: "IFCTENDONCONDUITTYPE",
  3663046924: "IFCTENDONCONDUIT",
  42703149: "IFCSINESPIRAL",
  1894708472: "IFCSIGNALTYPE",
  3599934289: "IFCSIGNTYPE",
  33720170: "IFCSIGN",
  1027922057: "IFCSEVENTHORDERPOLYNOMIALSPIRAL",
  544395925: "IFCSEGMENTEDREFERENCECURVE",
  3649235739: "IFCSECONDORDERPOLYNOMIALSPIRAL",
  550521510: "IFCROADPART",
  146592293: "IFCROAD",
  3818125796: "IFCRELADHERESTOELEMENT",
  4021432810: "IFCREFERENT",
  1891881377: "IFCRAILWAYPART",
  3992365140: "IFCRAILWAY",
  1763565496: "IFCRAILTYPE",
  1946335990: "IFCPOSITIONINGELEMENT",
  514975943: "IFCPAVEMENTTYPE",
  506776471: "IFCNAVIGATIONELEMENTTYPE",
  710110818: "IFCMOORINGDEVICETYPE",
  1950438474: "IFCMOBILETELECOMMUNICATIONSAPPLIANCETYPE",
  976884017: "IFCMARINEPART",
  525669439: "IFCMARINEFACILITY",
  1770583370: "IFCLIQUIDTERMINALTYPE",
  2176059722: "IFCLINEARELEMENT",
  679976338: "IFCKERBTYPE",
  3948183225: "IFCIMPACTPROTECTIONDEVICETYPE",
  2568555532: "IFCIMPACTPROTECTIONDEVICE",
  2898700619: "IFCGRADIENTCURVE",
  1594536857: "IFCGEOTECHNICALSTRATUM",
  4230923436: "IFCGEOTECHNICALELEMENT",
  4228831410: "IFCFACILITYPARTCOMMON",
  1310830890: "IFCFACILITYPART",
  24185140: "IFCFACILITY",
  4234616927: "IFCDIRECTRIXDERIVEDREFERENCESWEPTAREASOLID",
  1306400036: "IFCDEEPFOUNDATIONTYPE",
  4189326743: "IFCCOURSETYPE",
  2000195564: "IFCCOSINESPIRAL",
  3497074424: "IFCCLOTHOID",
  1626504194: "IFCBUILTELEMENTTYPE",
  3651464721: "IFCVEHICLETYPE",
  1229763772: "IFCTRIANGULATEDIRREGULARNETWORK",
  3665877780: "IFCTRANSPORTATIONDEVICETYPE",
  782932809: "IFCTHIRDORDERPOLYNOMIALSPIRAL",
  2735484536: "IFCSPIRAL",
  1356537516: "IFCSECTIONEDSURFACE",
  1290935644: "IFCSECTIONEDSOLIDHORIZONTAL",
  1862484736: "IFCSECTIONEDSOLID",
  1441486842: "IFCRELPOSITIONS",
  1033248425: "IFCRELASSOCIATESPROFILEDEF",
  3381221214: "IFCPOLYNOMIALCURVE",
  2485787929: "IFCOFFSETCURVEBYDISTANCES",
  590820931: "IFCOFFSETCURVE",
  3465909080: "IFCINDEXEDPOLYGONALTEXTUREMAP",
  593015953: "IFCDIRECTRIXCURVESWEPTAREASOLID",
  4212018352: "IFCCURVESEGMENT",
  3425423356: "IFCAXIS2PLACEMENTLINEAR",
  823603102: "IFCSEGMENT",
  2165702409: "IFCPOINTBYDISTANCEEXPRESSION",
  182550632: "IFCOPENCROSSPROFILEDEF",
  388784114: "IFCLINEARPLACEMENT",
  536804194: "IFCALIGNMENTHORIZONTALSEGMENT",
  3752311538: "IFCALIGNMENTCANTSEGMENT",
  1010789467: "IFCTEXTURECOORDINATEINDICESWITHVOIDS",
  222769930: "IFCTEXTURECOORDINATEINDICES",
  2691318326: "IFCQUANTITYNUMBER",
  3633395639: "IFCALIGNMENTVERTICALSEGMENT",
  2879124712: "IFCALIGNMENTPARAMETERSEGMENT",
  25142252: "IFCCONTROLLER",
  3087945054: "IFCALARM",
  4288193352: "IFCACTUATOR",
  630975310: "IFCUNITARYCONTROLELEMENT",
  4086658281: "IFCSENSOR",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  182646315: "IFCFLOWINSTRUMENT",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  819412036: "IFCFILTER",
  3415622556: "IFCFAN",
  1003880860: "IFCELECTRICTIMECONTROL",
  402227799: "IFCELECTRICMOTOR",
  264262732: "IFCELECTRICGENERATOR",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  1904799276: "IFCELECTRICAPPLIANCE",
  1360408905: "IFCDUCTSILENCER",
  3518393246: "IFCDUCTSEGMENT",
  342316401: "IFCDUCTFITTING",
  562808652: "IFCDISTRIBUTIONCIRCUIT",
  4074379575: "IFCDAMPER",
  3640358203: "IFCCOOLINGTOWER",
  4136498852: "IFCCOOLEDBEAM",
  2272882330: "IFCCONDENSER",
  3571504051: "IFCCOMPRESSOR",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  639361253: "IFCCOIL",
  3902619387: "IFCCHILLER",
  4217484030: "IFCCABLESEGMENT",
  1051757585: "IFCCABLEFITTING",
  3758799889: "IFCCABLECARRIERSEGMENT",
  635142910: "IFCCABLECARRIERFITTING",
  2938176219: "IFCBURNER",
  32344328: "IFCBOILER",
  2906023776: "IFCBEAMSTANDARDCASE",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  177149247: "IFCAIRTERMINALBOX",
  1634111441: "IFCAIRTERMINAL",
  486154966: "IFCWINDOWSTANDARDCASE",
  4237592921: "IFCWASTETERMINAL",
  4156078855: "IFCWALLELEMENTEDCASE",
  4207607924: "IFCVALVE",
  4292641817: "IFCUNITARYEQUIPMENT",
  3179687236: "IFCUNITARYCONTROLELEMENTTYPE",
  3026737570: "IFCTUBEBUNDLE",
  3825984169: "IFCTRANSFORMER",
  812556717: "IFCTANK",
  1162798199: "IFCSWITCHINGDEVICE",
  385403989: "IFCSTRUCTURALLOADCASE",
  1404847402: "IFCSTACKTERMINAL",
  1999602285: "IFCSPACEHEATER",
  3420628829: "IFCSOLARDEVICE",
  3027962421: "IFCSLABSTANDARDCASE",
  3127900445: "IFCSLABELEMENTEDCASE",
  1329646415: "IFCSHADINGDEVICE",
  3053780830: "IFCSANITARYTERMINAL",
  2572171363: "IFCREINFORCINGBARTYPE",
  1232101972: "IFCRATIONALBSPLINECURVEWITHKNOTS",
  90941305: "IFCPUMP",
  655969474: "IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",
  738039164: "IFCPROTECTIVEDEVICE",
  1156407060: "IFCPLATESTANDARDCASE",
  3612865200: "IFCPIPESEGMENT",
  310824031: "IFCPIPEFITTING",
  3694346114: "IFCOUTLET",
  144952367: "IFCOUTERBOUNDARYCURVE",
  2474470126: "IFCMOTORCONNECTION",
  1911478936: "IFCMEMBERSTANDARDCASE",
  1437502449: "IFCMEDICALDEVICE",
  629592764: "IFCLIGHTFIXTURE",
  76236018: "IFCLAMP",
  2176052936: "IFCJUNCTIONBOX",
  4175244083: "IFCINTERCEPTOR",
  2068733104: "IFCHUMIDIFIER",
  3319311131: "IFCHEATEXCHANGER",
  2188021234: "IFCFLOWMETER",
  1209101575: "IFCEXTERNALSPATIALELEMENT",
  484807127: "IFCEVAPORATOR",
  3747195512: "IFCEVAPORATIVECOOLER",
  2814081492: "IFCENGINE",
  2417008758: "IFCELECTRICDISTRIBUTIONBOARDTYPE",
  3242481149: "IFCDOORSTANDARDCASE",
  3205830791: "IFCDISTRIBUTIONSYSTEM",
  400855858: "IFCCOMMUNICATIONSAPPLIANCETYPE",
  905975707: "IFCCOLUMNSTANDARDCASE",
  1677625105: "IFCCIVILELEMENT",
  3296154744: "IFCCHIMNEY",
  2674252688: "IFCCABLEFITTINGTYPE",
  2188180465: "IFCBURNERTYPE",
  1177604601: "IFCBUILDINGSYSTEM",
  39481116: "IFCBUILDINGELEMENTPARTTYPE",
  1136057603: "IFCBOUNDARYCURVE",
  2461110595: "IFCBSPLINECURVEWITHKNOTS",
  1532957894: "IFCAUDIOVISUALAPPLIANCETYPE",
  4088093105: "IFCWORKCALENDAR",
  4009809668: "IFCWINDOWTYPE",
  926996030: "IFCVOIDINGFEATURE",
  2391383451: "IFCVIBRATIONISOLATOR",
  2415094496: "IFCTENDONTYPE",
  3081323446: "IFCTENDONANCHORTYPE",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  3101698114: "IFCSURFACEFEATURE",
  3657597509: "IFCSTRUCTURALSURFACEACTION",
  2757150158: "IFCSTRUCTURALCURVEREACTION",
  1004757350: "IFCSTRUCTURALCURVEACTION",
  338393293: "IFCSTAIRTYPE",
  1072016465: "IFCSOLARDEVICETYPE",
  4074543187: "IFCSHADINGDEVICETYPE",
  2157484638: "IFCSEAMCURVE",
  2781568857: "IFCROOFTYPE",
  2310774935: "IFCREINFORCINGMESHTYPE",
  964333572: "IFCREINFORCINGELEMENTTYPE",
  683857671: "IFCRATIONALBSPLINESURFACEWITHKNOTS",
  1469900589: "IFCRAMPTYPE",
  2839578677: "IFCPOLYGONALFACESET",
  1158309216: "IFCPILETYPE",
  3079942009: "IFCOPENINGSTANDARDCASE",
  1114901282: "IFCMEDICALDEVICETYPE",
  3113134337: "IFCINTERSECTIONCURVE",
  3946677679: "IFCINTERCEPTORTYPE",
  2571569899: "IFCINDEXEDPOLYCURVE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  1509553395: "IFCFURNITURE",
  1893162501: "IFCFOOTINGTYPE",
  2853485674: "IFCEXTERNALSPATIALSTRUCTUREELEMENT",
  4148101412: "IFCEVENT",
  132023988: "IFCENGINETYPE",
  2397081782: "IFCELEMENTASSEMBLYTYPE",
  2323601079: "IFCDOORTYPE",
  1213902940: "IFCCYLINDRICALSURFACE",
  1525564444: "IFCCONSTRUCTIONPRODUCTRESOURCETYPE",
  4105962743: "IFCCONSTRUCTIONMATERIALRESOURCETYPE",
  2185764099: "IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",
  15328376: "IFCCOMPOSITECURVEONSURFACE",
  3875453745: "IFCCOMPLEXPROPERTYTEMPLATE",
  3893394355: "IFCCIVILELEMENTTYPE",
  2197970202: "IFCCHIMNEYTYPE",
  167062518: "IFCBSPLINESURFACEWITHKNOTS",
  2887950389: "IFCBSPLINESURFACE",
  2603310189: "IFCADVANCEDBREPWITHVOIDS",
  1635779807: "IFCADVANCEDBREP",
  2916149573: "IFCTRIANGULATEDFACESET",
  1935646853: "IFCTOROIDALSURFACE",
  2387106220: "IFCTESSELLATEDFACESET",
  3206491090: "IFCTASKTYPE",
  699246055: "IFCSURFACECURVE",
  4095615324: "IFCSUBCONTRACTRESOURCETYPE",
  603775116: "IFCSTRUCTURALSURFACEREACTION",
  4015995234: "IFCSPHERICALSURFACE",
  2481509218: "IFCSPATIALZONETYPE",
  463610769: "IFCSPATIALZONE",
  710998568: "IFCSPATIALELEMENTTYPE",
  1412071761: "IFCSPATIALELEMENT",
  3663146110: "IFCSIMPLEPROPERTYTEMPLATE",
  3243963512: "IFCREVOLVEDAREASOLIDTAPERED",
  816062949: "IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",
  1521410863: "IFCRELSPACEBOUNDARY2NDLEVEL",
  3523091289: "IFCRELSPACEBOUNDARY1STLEVEL",
  427948657: "IFCRELINTERFERESELEMENTS",
  307848117: "IFCRELDEFINESBYTEMPLATE",
  1462361463: "IFCRELDEFINESBYOBJECT",
  2565941209: "IFCRELDECLARES",
  1027710054: "IFCRELASSIGNSTOGROUPBYFACTOR",
  3521284610: "IFCPROPERTYTEMPLATE",
  492091185: "IFCPROPERTYSETTEMPLATE",
  653396225: "IFCPROJECTLIBRARY",
  569719735: "IFCPROCEDURETYPE",
  3967405729: "IFCPREDEFINEDPROPERTYSET",
  1682466193: "IFCPCURVE",
  428585644: "IFCLABORRESOURCETYPE",
  2294589976: "IFCINDEXEDPOLYGONALFACEWITHVOIDS",
  178912537: "IFCINDEXEDPOLYGONALFACE",
  4095422895: "IFCGEOGRAPHICELEMENTTYPE",
  2652556860: "IFCFIXEDREFERENCESWEPTAREASOLID",
  2804161546: "IFCEXTRUDEDAREASOLIDTAPERED",
  4024345920: "IFCEVENTTYPE",
  2629017746: "IFCCURVEBOUNDEDSURFACE",
  1815067380: "IFCCREWRESOURCETYPE",
  3419103109: "IFCCONTEXT",
  2574617495: "IFCCONSTRUCTIONRESOURCETYPE",
  2059837836: "IFCCARTESIANPOINTLIST3D",
  1675464909: "IFCCARTESIANPOINTLIST2D",
  574549367: "IFCCARTESIANPOINTLIST",
  3406155212: "IFCADVANCEDFACE",
  3698973494: "IFCTYPERESOURCE",
  3736923433: "IFCTYPEPROCESS",
  901063453: "IFCTESSELLATEDITEM",
  1096409881: "IFCSWEPTDISKSOLIDPOLYGONAL",
  1042787934: "IFCRESOURCETIME",
  1608871552: "IFCRESOURCECONSTRAINTRELATIONSHIP",
  2943643501: "IFCRESOURCEAPPROVALRELATIONSHIP",
  2090586900: "IFCQUANTITYSET",
  1482703590: "IFCPROPERTYTEMPLATEDEFINITION",
  3778827333: "IFCPREDEFINEDPROPERTIES",
  2998442950: "IFCMIRROREDPROFILEDEF",
  853536259: "IFCMATERIALRELATIONSHIP",
  3404854881: "IFCMATERIALPROFILESETUSAGETAPERING",
  3079605661: "IFCMATERIALPROFILESETUSAGE",
  2852063980: "IFCMATERIALCONSTITUENTSET",
  3708119e3: "IFCMATERIALCONSTITUENT",
  1585845231: "IFCLAGTIME",
  2133299955: "IFCINDEXEDTRIANGLETEXTUREMAP",
  1437953363: "IFCINDEXEDTEXTUREMAP",
  3570813810: "IFCINDEXEDCOLOURMAP",
  1437805879: "IFCEXTERNALREFERENCERELATIONSHIP",
  297599258: "IFCEXTENDEDPROPERTIES",
  211053100: "IFCEVENTTIME",
  2713554722: "IFCCONVERSIONBASEDUNITWITHOFFSET",
  3285139300: "IFCCOLOURRGBLIST",
  1236880293: "IFCWORKTIME",
  1199560280: "IFCTIMEPERIOD",
  3611470254: "IFCTEXTUREVERTEXLIST",
  2771591690: "IFCTASKTIMERECURRING",
  1549132990: "IFCTASKTIME",
  2043862942: "IFCTABLECOLUMN",
  2934153892: "IFCSURFACEREINFORCEMENTAREA",
  609421318: "IFCSTRUCTURALLOADORRESULT",
  3478079324: "IFCSTRUCTURALLOADCONFIGURATION",
  1054537805: "IFCSCHEDULINGTIME",
  2439245199: "IFCRESOURCELEVELRELATIONSHIP",
  2433181523: "IFCREFERENCE",
  3915482550: "IFCRECURRENCEPATTERN",
  986844984: "IFCPROPERTYABSTRACTION",
  3843373140: "IFCPROJECTEDCRS",
  677532197: "IFCPRESENTATIONITEM",
  1507914824: "IFCMATERIALUSAGEDEFINITION",
  552965576: "IFCMATERIALPROFILEWITHOFFSETS",
  164193824: "IFCMATERIALPROFILESET",
  2235152071: "IFCMATERIALPROFILE",
  1847252529: "IFCMATERIALLAYERWITHOFFSETS",
  760658860: "IFCMATERIALDEFINITION",
  3057273783: "IFCMAPCONVERSION",
  4294318154: "IFCEXTERNALINFORMATION",
  1466758467: "IFCCOORDINATEREFERENCESYSTEM",
  1785450214: "IFCCOORDINATEOPERATION",
  775493141: "IFCCONNECTIONVOLUMEGEOMETRY",
  979691226: "IFCREINFORCINGBAR",
  3700593921: "IFCELECTRICDISTRIBUTIONPOINT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  578613899: "IFCCONTROLLERTYPE",
  2454782716: "IFCCHAMFEREDGEFEATURE",
  753842376: "IFCBEAM",
  3001207471: "IFCALARMTYPE",
  2874132201: "IFCACTUATORTYPE",
  3304561284: "IFCWINDOW",
  3512223829: "IFCWALLSTANDARDCASE",
  2391406946: "IFCWALL",
  3313531582: "IFCVIBRATIONISOLATORTYPE",
  2347447852: "IFCTENDONANCHOR",
  3824725483: "IFCTENDON",
  2515109513: "IFCSTRUCTURALANALYSISMODEL",
  4252922144: "IFCSTAIRFLIGHT",
  331165859: "IFCSTAIR",
  1529196076: "IFCSLAB",
  1783015770: "IFCSENSORTYPE",
  1376911519: "IFCROUNDEDEDGEFEATURE",
  2016517767: "IFCROOF",
  2320036040: "IFCREINFORCINGMESH",
  3027567501: "IFCREINFORCINGELEMENT",
  3055160366: "IFCRATIONALBEZIERCURVE",
  3283111854: "IFCRAMPFLIGHT",
  3024970846: "IFCRAMP",
  2262370178: "IFCRAILING",
  3171933400: "IFCPLATE",
  1687234759: "IFCPILE",
  1073191201: "IFCMEMBER",
  900683007: "IFCFOOTING",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  2223149337: "IFCFLOWTERMINAL",
  707683696: "IFCFLOWSTORAGEDEVICE",
  987401354: "IFCFLOWSEGMENT",
  3132237377: "IFCFLOWMOVINGDEVICE",
  4037862832: "IFCFLOWINSTRUMENTTYPE",
  4278956645: "IFCFLOWFITTING",
  2058353004: "IFCFLOWCONTROLLER",
  4222183408: "IFCFIRESUPPRESSIONTERMINALTYPE",
  1810631287: "IFCFILTERTYPE",
  346874300: "IFCFANTYPE",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  857184966: "IFCELECTRICALELEMENT",
  1634875225: "IFCELECTRICALCIRCUIT",
  712377611: "IFCELECTRICTIMECONTROLTYPE",
  1217240411: "IFCELECTRICMOTORTYPE",
  1365060375: "IFCELECTRICHEATERTYPE",
  1534661035: "IFCELECTRICGENERATORTYPE",
  3277789161: "IFCELECTRICFLOWSTORAGEDEVICETYPE",
  663422040: "IFCELECTRICAPPLIANCETYPE",
  855621170: "IFCEDGEFEATURE",
  2030761528: "IFCDUCTSILENCERTYPE",
  3760055223: "IFCDUCTSEGMENTTYPE",
  869906466: "IFCDUCTFITTINGTYPE",
  395920057: "IFCDOOR",
  3041715199: "IFCDISTRIBUTIONPORT",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  2063403501: "IFCDISTRIBUTIONCONTROLELEMENTTYPE",
  1599208980: "IFCDISTRIBUTIONCHAMBERELEMENTTYPE",
  2635815018: "IFCDISCRETEACCESSORYTYPE",
  1335981549: "IFCDISCRETEACCESSORY",
  4147604152: "IFCDIAMETERDIMENSION",
  3961806047: "IFCDAMPERTYPE",
  3495092785: "IFCCURTAINWALL",
  1973544240: "IFCCOVERING",
  2954562838: "IFCCOOLINGTOWERTYPE",
  335055490: "IFCCOOLEDBEAMTYPE",
  488727124: "IFCCONSTRUCTIONPRODUCTRESOURCE",
  1060000209: "IFCCONSTRUCTIONMATERIALRESOURCE",
  3898045240: "IFCCONSTRUCTIONEQUIPMENTRESOURCE",
  1163958913: "IFCCONDITIONCRITERION",
  2188551683: "IFCCONDITION",
  2816379211: "IFCCONDENSERTYPE",
  3850581409: "IFCCOMPRESSORTYPE",
  843113511: "IFCCOLUMN",
  2301859152: "IFCCOILTYPE",
  2611217952: "IFCCIRCLE",
  2951183804: "IFCCHILLERTYPE",
  1285652485: "IFCCABLESEGMENTTYPE",
  3293546465: "IFCCABLECARRIERSEGMENTTYPE",
  395041908: "IFCCABLECARRIERFITTINGTYPE",
  1909888760: "IFCBUILDINGELEMENTPROXYTYPE",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  2979338954: "IFCBUILDINGELEMENTPART",
  52481810: "IFCBUILDINGELEMENTCOMPONENT",
  3299480353: "IFCBUILDINGELEMENT",
  231477066: "IFCBOILERTYPE",
  1916977116: "IFCBEZIERCURVE",
  819618141: "IFCBEAMTYPE",
  1967976161: "IFCBSPLINECURVE",
  3460190687: "IFCASSET",
  2470393545: "IFCANGULARDIMENSION",
  1871374353: "IFCAIRTOAIRHEATRECOVERYTYPE",
  3352864051: "IFCAIRTERMINALTYPE",
  1411407467: "IFCAIRTERMINALBOXTYPE",
  3821786052: "IFCACTIONREQUEST",
  1213861670: "IFC2DCOMPOSITECURVE",
  1033361043: "IFCZONE",
  3342526732: "IFCWORKSCHEDULE",
  4218914973: "IFCWORKPLAN",
  1028945134: "IFCWORKCONTROL",
  1133259667: "IFCWASTETERMINALTYPE",
  1898987631: "IFCWALLTYPE",
  2769231204: "IFCVIRTUALELEMENT",
  728799441: "IFCVALVETYPE",
  1911125066: "IFCUNITARYEQUIPMENTTYPE",
  1600972822: "IFCTUBEBUNDLETYPE",
  3593883385: "IFCTRIMMEDCURVE",
  1620046519: "IFCTRANSPORTELEMENT",
  1692211062: "IFCTRANSFORMERTYPE",
  1637806684: "IFCTIMESERIESSCHEDULE",
  5716631: "IFCTANKTYPE",
  2254336722: "IFCSYSTEM",
  2315554128: "IFCSWITCHINGDEVICETYPE",
  148013059: "IFCSUBCONTRACTRESOURCE",
  1975003073: "IFCSTRUCTURALSURFACECONNECTION",
  2986769608: "IFCSTRUCTURALRESULTGROUP",
  1235345126: "IFCSTRUCTURALPOINTREACTION",
  734778138: "IFCSTRUCTURALPOINTCONNECTION",
  2082059205: "IFCSTRUCTURALPOINTACTION",
  3987759626: "IFCSTRUCTURALPLANARACTIONVARYING",
  1621171031: "IFCSTRUCTURALPLANARACTION",
  1252848954: "IFCSTRUCTURALLOADGROUP",
  1721250024: "IFCSTRUCTURALLINEARACTIONVARYING",
  1807405624: "IFCSTRUCTURALLINEARACTION",
  2445595289: "IFCSTRUCTURALCURVEMEMBERVARYING",
  214636428: "IFCSTRUCTURALCURVEMEMBER",
  4243806635: "IFCSTRUCTURALCURVECONNECTION",
  1179482911: "IFCSTRUCTURALCONNECTION",
  682877961: "IFCSTRUCTURALACTION",
  1039846685: "IFCSTAIRFLIGHTTYPE",
  3112655638: "IFCSTACKTERMINALTYPE",
  3812236995: "IFCSPACETYPE",
  652456506: "IFCSPACEPROGRAM",
  1305183839: "IFCSPACEHEATERTYPE",
  3856911033: "IFCSPACE",
  2533589738: "IFCSLABTYPE",
  4097777520: "IFCSITE",
  4105383287: "IFCSERVICELIFE",
  3517283431: "IFCSCHEDULETIMECONTROL",
  1768891740: "IFCSANITARYTERMINALTYPE",
  2863920197: "IFCRELASSIGNSTASKS",
  160246688: "IFCRELAGGREGATES",
  2324767716: "IFCRAMPFLIGHTTYPE",
  2893384427: "IFCRAILINGTYPE",
  3248260540: "IFCRADIUSDIMENSION",
  2250791053: "IFCPUMPTYPE",
  1842657554: "IFCPROTECTIVEDEVICETYPE",
  3651124850: "IFCPROJECTIONELEMENT",
  3642467123: "IFCPROJECTORDERRECORD",
  2904328755: "IFCPROJECTORDER",
  2744685151: "IFCPROCEDURE",
  3740093272: "IFCPORT",
  3724593414: "IFCPOLYLINE",
  4017108033: "IFCPLATETYPE",
  4231323485: "IFCPIPESEGMENTTYPE",
  804291784: "IFCPIPEFITTINGTYPE",
  3327091369: "IFCPERMIT",
  2382730787: "IFCPERFORMANCEHISTORY",
  2837617999: "IFCOUTLETTYPE",
  3425660407: "IFCORDERACTION",
  3588315303: "IFCOPENINGELEMENT",
  4143007308: "IFCOCCUPANT",
  1916936684: "IFCMOVE",
  977012517: "IFCMOTORCONNECTIONTYPE",
  3181161470: "IFCMEMBERTYPE",
  2108223431: "IFCMECHANICALFASTENERTYPE",
  377706215: "IFCMECHANICALFASTENER",
  2506943328: "IFCLINEARDIMENSION",
  1161773419: "IFCLIGHTFIXTURETYPE",
  1051575348: "IFCLAMPTYPE",
  3827777499: "IFCLABORRESOURCE",
  4288270099: "IFCJUNCTIONBOXTYPE",
  2391368822: "IFCINVENTORY",
  1806887404: "IFCHUMIDIFIERTYPE",
  1251058090: "IFCHEATEXCHANGERTYPE",
  2706460486: "IFCGROUP",
  3009204131: "IFCGRID",
  200128114: "IFCGASTERMINALTYPE",
  814719939: "IFCFURNITURESTANDARD",
  263784265: "IFCFURNISHINGELEMENT",
  3009222698: "IFCFLOWTREATMENTDEVICETYPE",
  2297155007: "IFCFLOWTERMINALTYPE",
  1339347760: "IFCFLOWSTORAGEDEVICETYPE",
  1834744321: "IFCFLOWSEGMENTTYPE",
  1482959167: "IFCFLOWMOVINGDEVICETYPE",
  3815607619: "IFCFLOWMETERTYPE",
  3198132628: "IFCFLOWFITTINGTYPE",
  3907093117: "IFCFLOWCONTROLLERTYPE",
  1287392070: "IFCFEATUREELEMENTSUBTRACTION",
  2143335405: "IFCFEATUREELEMENTADDITION",
  2827207264: "IFCFEATUREELEMENT",
  2489546625: "IFCFASTENERTYPE",
  647756555: "IFCFASTENER",
  3737207727: "IFCFACETEDBREPWITHVOIDS",
  807026263: "IFCFACETEDBREP",
  3390157468: "IFCEVAPORATORTYPE",
  3174744832: "IFCEVAPORATIVECOOLERTYPE",
  3272907226: "IFCEQUIPMENTSTANDARD",
  1962604670: "IFCEQUIPMENTELEMENT",
  2107101300: "IFCENERGYCONVERSIONDEVICETYPE",
  1704287377: "IFCELLIPSE",
  2590856083: "IFCELEMENTCOMPONENTTYPE",
  1623761950: "IFCELEMENTCOMPONENT",
  4123344466: "IFCELEMENTASSEMBLY",
  1758889154: "IFCELEMENT",
  360485395: "IFCELECTRICALBASEPROPERTIES",
  3849074793: "IFCDISTRIBUTIONFLOWELEMENTTYPE",
  3256556792: "IFCDISTRIBUTIONELEMENTTYPE",
  681481545: "IFCDIMENSIONCURVEDIRECTEDCALLOUT",
  1457835157: "IFCCURTAINWALLTYPE",
  3295246426: "IFCCREWRESOURCE",
  1916426348: "IFCCOVERINGTYPE",
  1419761937: "IFCCOSTSCHEDULE",
  3895139033: "IFCCOSTITEM",
  3293443760: "IFCCONTROL",
  2559216714: "IFCCONSTRUCTIONRESOURCE",
  2510884976: "IFCCONIC",
  3732776249: "IFCCOMPOSITECURVE",
  300633059: "IFCCOLUMNTYPE",
  2937912522: "IFCCIRCLEHOLLOWPROFILEDEF",
  3124254112: "IFCBUILDINGSTOREY",
  1950629157: "IFCBUILDINGELEMENTTYPE",
  4031249490: "IFCBUILDING",
  1260505505: "IFCBOUNDEDCURVE",
  3649129432: "IFCBOOLEANCLIPPINGRESULT",
  1334484129: "IFCBLOCK",
  3207858831: "IFCASYMMETRICISHAPEPROFILEDEF",
  1674181508: "IFCANNOTATION",
  2296667514: "IFCACTOR",
  2097647324: "IFCTRANSPORTELEMENTTYPE",
  3473067441: "IFCTASK",
  1580310250: "IFCSYSTEMFURNITUREELEMENTTYPE",
  4124788165: "IFCSURFACEOFREVOLUTION",
  2809605785: "IFCSURFACEOFLINEAREXTRUSION",
  2028607225: "IFCSURFACECURVESWEPTAREASOLID",
  4070609034: "IFCSTRUCTUREDDIMENSIONCALLOUT",
  2218152070: "IFCSTRUCTURALSURFACEMEMBERVARYING",
  3979015343: "IFCSTRUCTURALSURFACEMEMBER",
  3689010777: "IFCSTRUCTURALREACTION",
  530289379: "IFCSTRUCTURALMEMBER",
  3136571912: "IFCSTRUCTURALITEM",
  3544373492: "IFCSTRUCTURALACTIVITY",
  451544542: "IFCSPHERE",
  3893378262: "IFCSPATIALSTRUCTUREELEMENTTYPE",
  2706606064: "IFCSPATIALSTRUCTUREELEMENT",
  3626867408: "IFCRIGHTCIRCULARCYLINDER",
  4158566097: "IFCRIGHTCIRCULARCONE",
  1856042241: "IFCREVOLVEDAREASOLID",
  2914609552: "IFCRESOURCE",
  1401173127: "IFCRELVOIDSELEMENT",
  3451746338: "IFCRELSPACEBOUNDARY",
  366585022: "IFCRELSERVICESBUILDINGS",
  4122056220: "IFCRELSEQUENCE",
  1058617721: "IFCRELSCHEDULESCOSTITEMS",
  1245217292: "IFCRELREFERENCEDINSPATIALSTRUCTURE",
  750771296: "IFCRELPROJECTSELEMENT",
  202636808: "IFCRELOVERRIDESPROPERTIES",
  2051452291: "IFCRELOCCUPIESSPACES",
  3268803585: "IFCRELNESTS",
  4189434867: "IFCRELINTERACTIONREQUIREMENTS",
  279856033: "IFCRELFLOWCONTROLELEMENTS",
  3940055652: "IFCRELFILLSELEMENT",
  781010003: "IFCRELDEFINESBYTYPE",
  4186316022: "IFCRELDEFINESBYPROPERTIES",
  693640335: "IFCRELDEFINES",
  2551354335: "IFCRELDECOMPOSES",
  2802773753: "IFCRELCOVERSSPACES",
  886880790: "IFCRELCOVERSBLDGELEMENTS",
  3242617779: "IFCRELCONTAINEDINSPATIALSTRUCTURE",
  3678494232: "IFCRELCONNECTSWITHREALIZINGELEMENTS",
  504942748: "IFCRELCONNECTSWITHECCENTRICITY",
  1638771189: "IFCRELCONNECTSSTRUCTURALMEMBER",
  3912681535: "IFCRELCONNECTSSTRUCTURALELEMENT",
  2127690289: "IFCRELCONNECTSSTRUCTURALACTIVITY",
  3190031847: "IFCRELCONNECTSPORTS",
  4201705270: "IFCRELCONNECTSPORTTOELEMENT",
  3945020480: "IFCRELCONNECTSPATHELEMENTS",
  1204542856: "IFCRELCONNECTSELEMENTS",
  826625072: "IFCRELCONNECTS",
  2851387026: "IFCRELASSOCIATESPROFILEPROPERTIES",
  2655215786: "IFCRELASSOCIATESMATERIAL",
  3840914261: "IFCRELASSOCIATESLIBRARY",
  982818633: "IFCRELASSOCIATESDOCUMENT",
  2728634034: "IFCRELASSOCIATESCONSTRAINT",
  919958153: "IFCRELASSOCIATESCLASSIFICATION",
  4095574036: "IFCRELASSOCIATESAPPROVAL",
  1327628568: "IFCRELASSOCIATESAPPLIEDVALUE",
  1865459582: "IFCRELASSOCIATES",
  205026976: "IFCRELASSIGNSTORESOURCE",
  3372526763: "IFCRELASSIGNSTOPROJECTORDER",
  2857406711: "IFCRELASSIGNSTOPRODUCT",
  4278684876: "IFCRELASSIGNSTOPROCESS",
  1307041759: "IFCRELASSIGNSTOGROUP",
  2495723537: "IFCRELASSIGNSTOCONTROL",
  1683148259: "IFCRELASSIGNSTOACTOR",
  3939117080: "IFCRELASSIGNS",
  3454111270: "IFCRECTANGULARTRIMMEDSURFACE",
  2798486643: "IFCRECTANGULARPYRAMID",
  2770003689: "IFCRECTANGLEHOLLOWPROFILEDEF",
  3219374653: "IFCPROXY",
  1451395588: "IFCPROPERTYSET",
  4194566429: "IFCPROJECTIONCURVE",
  103090709: "IFCPROJECT",
  4208778838: "IFCPRODUCT",
  2945172077: "IFCPROCESS",
  220341763: "IFCPLANE",
  603570806: "IFCPLANARBOX",
  3566463478: "IFCPERMEABLECOVERINGPROPERTIES",
  3505215534: "IFCOFFSETCURVE3D",
  3388369263: "IFCOFFSETCURVE2D",
  3888040117: "IFCOBJECT",
  1425443689: "IFCMANIFOLDSOLIDBREP",
  1281925730: "IFCLINE",
  572779678: "IFCLSHAPEPROFILEDEF",
  1484403080: "IFCISHAPEPROFILEDEF",
  987898635: "IFCGEOMETRICCURVESET",
  1268542332: "IFCFURNITURETYPE",
  4238390223: "IFCFURNISHINGELEMENTTYPE",
  3455213021: "IFCFLUIDFLOWPROPERTIES",
  315944413: "IFCFILLAREASTYLETILES",
  4203026998: "IFCFILLAREASTYLETILESYMBOLWITHSTYLE",
  374418227: "IFCFILLAREASTYLEHATCHING",
  2047409740: "IFCFACEBASEDSURFACEMODEL",
  477187591: "IFCEXTRUDEDAREASOLID",
  80994333: "IFCENERGYPROPERTIES",
  2835456948: "IFCELLIPSEPROFILEDEF",
  2777663545: "IFCELEMENTARYSURFACE",
  339256511: "IFCELEMENTTYPE",
  1883228015: "IFCELEMENTQUANTITY",
  1472233963: "IFCEDGELOOP",
  4006246654: "IFCDRAUGHTINGPREDEFINEDCURVEFONT",
  445594917: "IFCDRAUGHTINGPREDEFINEDCOLOUR",
  3073041342: "IFCDRAUGHTINGCALLOUT",
  526551008: "IFCDOORSTYLE",
  1714330368: "IFCDOORPANELPROPERTIES",
  2963535650: "IFCDOORLININGPROPERTIES",
  32440307: "IFCDIRECTION",
  4054601972: "IFCDIMENSIONCURVETERMINATOR",
  606661476: "IFCDIMENSIONCURVE",
  693772133: "IFCDEFINEDSYMBOL",
  2827736869: "IFCCURVEBOUNDEDPLANE",
  2601014836: "IFCCURVE",
  2147822146: "IFCCSGSOLID",
  2506170314: "IFCCSGPRIMITIVE3D",
  194851669: "IFCCRANERAILFSHAPEPROFILEDEF",
  4133800736: "IFCCRANERAILASHAPEPROFILEDEF",
  2485617015: "IFCCOMPOSITECURVESEGMENT",
  2205249479: "IFCCLOSEDSHELL",
  1383045692: "IFCCIRCLEPROFILEDEF",
  1416205885: "IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",
  3331915920: "IFCCARTESIANTRANSFORMATIONOPERATOR3D",
  3486308946: "IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",
  3749851601: "IFCCARTESIANTRANSFORMATIONOPERATOR2D",
  59481748: "IFCCARTESIANTRANSFORMATIONOPERATOR",
  1123145078: "IFCCARTESIANPOINT",
  2898889636: "IFCCSHAPEPROFILEDEF",
  2713105998: "IFCBOXEDHALFSPACE",
  2581212453: "IFCBOUNDINGBOX",
  4182860854: "IFCBOUNDEDSURFACE",
  2736907675: "IFCBOOLEANRESULT",
  2740243338: "IFCAXIS2PLACEMENT3D",
  3125803723: "IFCAXIS2PLACEMENT2D",
  4261334040: "IFCAXIS1PLACEMENT",
  1302238472: "IFCANNOTATIONSURFACE",
  2265737646: "IFCANNOTATIONFILLAREAOCCURRENCE",
  669184980: "IFCANNOTATIONFILLAREA",
  3288037868: "IFCANNOTATIONCURVEOCCURRENCE",
  2543172580: "IFCZSHAPEPROFILEDEF",
  1299126871: "IFCWINDOWSTYLE",
  512836454: "IFCWINDOWPANELPROPERTIES",
  336235671: "IFCWINDOWLININGPROPERTIES",
  2759199220: "IFCVERTEXLOOP",
  1417489154: "IFCVECTOR",
  427810014: "IFCUSHAPEPROFILEDEF",
  2347495698: "IFCTYPEPRODUCT",
  1628702193: "IFCTYPEOBJECT",
  1345879162: "IFCTWODIRECTIONREPEATFACTOR",
  2715220739: "IFCTRAPEZIUMPROFILEDEF",
  3124975700: "IFCTEXTLITERALWITHEXTENT",
  4282788508: "IFCTEXTLITERAL",
  3028897424: "IFCTERMINATORSYMBOL",
  3071757647: "IFCTSHAPEPROFILEDEF",
  230924584: "IFCSWEPTSURFACE",
  1260650574: "IFCSWEPTDISKSOLID",
  2247615214: "IFCSWEPTAREASOLID",
  1878645084: "IFCSURFACESTYLERENDERING",
  2513912981: "IFCSURFACE",
  2233826070: "IFCSUBEDGE",
  3653947884: "IFCSTRUCTURALSTEELPROFILEPROPERTIES",
  3843319758: "IFCSTRUCTURALPROFILEPROPERTIES",
  1190533807: "IFCSTRUCTURALLOADSINGLEFORCEWARPING",
  1597423693: "IFCSTRUCTURALLOADSINGLEFORCE",
  1973038258: "IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",
  2473145415: "IFCSTRUCTURALLOADSINGLEDISPLACEMENT",
  2668620305: "IFCSTRUCTURALLOADPLANARFORCE",
  1595516126: "IFCSTRUCTURALLOADLINEARFORCE",
  390701378: "IFCSPACETHERMALLOADPROPERTIES",
  1202362311: "IFCSOUNDVALUE",
  2485662743: "IFCSOUNDPROPERTIES",
  723233188: "IFCSOLIDMODEL",
  2609359061: "IFCSLIPPAGECONNECTIONCONDITION",
  4124623270: "IFCSHELLBASEDSURFACEMODEL",
  2411513650: "IFCSERVICELIFEFACTOR",
  1509187699: "IFCSECTIONEDSPINE",
  2778083089: "IFCROUNDEDRECTANGLEPROFILEDEF",
  478536968: "IFCRELATIONSHIP",
  3765753017: "IFCREINFORCEMENTDEFINITIONPROPERTIES",
  3413951693: "IFCREGULARTIMESERIES",
  3615266464: "IFCRECTANGLEPROFILEDEF",
  110355661: "IFCPROPERTYTABLEVALUE",
  3650150729: "IFCPROPERTYSINGLEVALUE",
  3357820518: "IFCPROPERTYSETDEFINITION",
  941946838: "IFCPROPERTYREFERENCEVALUE",
  2752243245: "IFCPROPERTYLISTVALUE",
  4166981789: "IFCPROPERTYENUMERATEDVALUE",
  1680319473: "IFCPROPERTYDEFINITION",
  871118103: "IFCPROPERTYBOUNDEDVALUE",
  673634403: "IFCPRODUCTDEFINITIONSHAPE",
  179317114: "IFCPREDEFINEDPOINTMARKERSYMBOL",
  433424934: "IFCPREDEFINEDDIMENSIONSYMBOL",
  2559016684: "IFCPREDEFINEDCURVEFONT",
  759155922: "IFCPREDEFINEDCOLOUR",
  2775532180: "IFCPOLYGONALBOUNDEDHALFSPACE",
  2924175390: "IFCPOLYLOOP",
  1423911732: "IFCPOINTONSURFACE",
  4022376103: "IFCPOINTONCURVE",
  2067069095: "IFCPOINT",
  1663979128: "IFCPLANAREXTENT",
  2004835150: "IFCPLACEMENT",
  597895409: "IFCPIXELTEXTURE",
  3021840470: "IFCPHYSICALCOMPLEXQUANTITY",
  2519244187: "IFCPATH",
  2529465313: "IFCPARAMETERIZEDPROFILEDEF",
  1029017970: "IFCORIENTEDEDGE",
  2665983363: "IFCOPENSHELL",
  2833995503: "IFCONEDIRECTIONREPEATFACTOR",
  219451334: "IFCOBJECTDEFINITION",
  1430189142: "IFCMECHANICALCONCRETEMATERIALPROPERTIES",
  2022407955: "IFCMATERIALDEFINITIONREPRESENTATION",
  2347385850: "IFCMAPPEDITEM",
  1008929658: "IFCLOOP",
  2624227202: "IFCLOCALPLACEMENT",
  3422422726: "IFCLIGHTSOURCESPOT",
  1520743889: "IFCLIGHTSOURCEPOSITIONAL",
  4266656042: "IFCLIGHTSOURCEGONIOMETRIC",
  2604431987: "IFCLIGHTSOURCEDIRECTIONAL",
  125510826: "IFCLIGHTSOURCEAMBIENT",
  1402838566: "IFCLIGHTSOURCE",
  3741457305: "IFCIRREGULARTIMESERIES",
  3905492369: "IFCIMAGETEXTURE",
  2445078500: "IFCHYGROSCOPICMATERIALPROPERTIES",
  812098782: "IFCHALFSPACESOLID",
  178086475: "IFCGRIDPLACEMENT",
  3590301190: "IFCGEOMETRICSET",
  4142052618: "IFCGEOMETRICREPRESENTATIONSUBCONTEXT",
  2453401579: "IFCGEOMETRICREPRESENTATIONITEM",
  3448662350: "IFCGEOMETRICREPRESENTATIONCONTEXT",
  1446786286: "IFCGENERALPROFILEPROPERTIES",
  803998398: "IFCGENERALMATERIALPROPERTIES",
  3857492461: "IFCFUELPROPERTIES",
  738692330: "IFCFILLAREASTYLE",
  4219587988: "IFCFAILURECONNECTIONCONDITION",
  3008276851: "IFCFACESURFACE",
  803316827: "IFCFACEOUTERBOUND",
  1809719519: "IFCFACEBOUND",
  2556980723: "IFCFACE",
  1860660968: "IFCEXTENDEDMATERIALPROPERTIES",
  476780140: "IFCEDGECURVE",
  3900360178: "IFCEDGE",
  4170525392: "IFCDRAUGHTINGPREDEFINEDTEXTFONT",
  3732053477: "IFCDOCUMENTREFERENCE",
  1694125774: "IFCDIMENSIONPAIR",
  2273265877: "IFCDIMENSIONCALLOUTRELATIONSHIP",
  3632507154: "IFCDERIVEDPROFILEDEF",
  3800577675: "IFCCURVESTYLE",
  2889183280: "IFCCONVERSIONBASEDUNIT",
  3050246964: "IFCCONTEXTDEPENDENTUNIT",
  45288368: "IFCCONNECTIONPOINTECCENTRICITY",
  1981873012: "IFCCONNECTIONCURVEGEOMETRY",
  370225590: "IFCCONNECTEDFACESET",
  1485152156: "IFCCOMPOSITEPROFILEDEF",
  2542286263: "IFCCOMPLEXPROPERTY",
  776857604: "IFCCOLOURRGB",
  647927063: "IFCCLASSIFICATIONREFERENCE",
  3150382593: "IFCCENTERLINEPROFILEDEF",
  616511568: "IFCBLOBTEXTURE",
  2705031697: "IFCARBITRARYPROFILEDEFWITHVOIDS",
  1310608509: "IFCARBITRARYOPENPROFILEDEF",
  3798115385: "IFCARBITRARYCLOSEDPROFILEDEF",
  2297822566: "IFCANNOTATIONTEXTOCCURRENCE",
  3612888222: "IFCANNOTATIONSYMBOLOCCURRENCE",
  962685235: "IFCANNOTATIONSURFACEOCCURRENCE",
  2442683028: "IFCANNOTATIONOCCURRENCE",
  1065908215: "IFCWATERPROPERTIES",
  891718957: "IFCVIRTUALGRIDINTERSECTION",
  1907098498: "IFCVERTEXPOINT",
  3304826586: "IFCVERTEXBASEDTEXTUREMAP",
  2799835756: "IFCVERTEX",
  180925521: "IFCUNITASSIGNMENT",
  1735638870: "IFCTOPOLOGYREPRESENTATION",
  1377556343: "IFCTOPOLOGICALREPRESENTATIONITEM",
  581633288: "IFCTIMESERIESVALUE",
  1718945513: "IFCTIMESERIESREFERENCERELATIONSHIP",
  3101149627: "IFCTIMESERIES",
  3317419933: "IFCTHERMALMATERIALPROPERTIES",
  1210645708: "IFCTEXTUREVERTEX",
  2552916305: "IFCTEXTUREMAP",
  1742049831: "IFCTEXTURECOORDINATEGENERATOR",
  280115917: "IFCTEXTURECOORDINATE",
  1484833681: "IFCTEXTSTYLEWITHBOXCHARACTERISTICS",
  1640371178: "IFCTEXTSTYLETEXTMODEL",
  2636378356: "IFCTEXTSTYLEFORDEFINEDFONT",
  1983826977: "IFCTEXTSTYLEFONTMODEL",
  1447204868: "IFCTEXTSTYLE",
  912023232: "IFCTELECOMADDRESS",
  531007025: "IFCTABLEROW",
  985171141: "IFCTABLE",
  1290481447: "IFCSYMBOLSTYLE",
  626085974: "IFCSURFACETEXTURE",
  1351298697: "IFCSURFACESTYLEWITHTEXTURES",
  846575682: "IFCSURFACESTYLESHADING",
  1607154358: "IFCSURFACESTYLEREFRACTION",
  3303107099: "IFCSURFACESTYLELIGHTING",
  1300840506: "IFCSURFACESTYLE",
  3049322572: "IFCSTYLEDREPRESENTATION",
  3958052878: "IFCSTYLEDITEM",
  2830218821: "IFCSTYLEMODEL",
  3408363356: "IFCSTRUCTURALLOADTEMPERATURE",
  2525727697: "IFCSTRUCTURALLOADSTATIC",
  2162789131: "IFCSTRUCTURALLOAD",
  2273995522: "IFCSTRUCTURALCONNECTIONCONDITION",
  3692461612: "IFCSIMPLEPROPERTY",
  4240577450: "IFCSHAPEREPRESENTATION",
  3982875396: "IFCSHAPEMODEL",
  867548509: "IFCSHAPEASPECT",
  4165799628: "IFCSECTIONREINFORCEMENTPROPERTIES",
  2042790032: "IFCSECTIONPROPERTIES",
  448429030: "IFCSIUNIT",
  2341007311: "IFCROOT",
  3679540991: "IFCRIBPLATEPROFILEPROPERTIES",
  1660063152: "IFCREPRESENTATIONMAP",
  3008791417: "IFCREPRESENTATIONITEM",
  3377609919: "IFCREPRESENTATIONCONTEXT",
  1076942058: "IFCREPRESENTATION",
  1222501353: "IFCRELAXATION",
  1580146022: "IFCREINFORCEMENTBARPROPERTIES",
  2692823254: "IFCREFERENCESVALUEDOCUMENT",
  825690147: "IFCQUANTITYWEIGHT",
  2405470396: "IFCQUANTITYVOLUME",
  3252649465: "IFCQUANTITYTIME",
  931644368: "IFCQUANTITYLENGTH",
  2093928680: "IFCQUANTITYCOUNT",
  2044713172: "IFCQUANTITYAREA",
  3710013099: "IFCPROPERTYENUMERATION",
  148025276: "IFCPROPERTYDEPENDENCYRELATIONSHIP",
  3896028662: "IFCPROPERTYCONSTRAINTRELATIONSHIP",
  2598011224: "IFCPROPERTY",
  2802850158: "IFCPROFILEPROPERTIES",
  3958567839: "IFCPROFILEDEF",
  2267347899: "IFCPRODUCTSOFCOMBUSTIONPROPERTIES",
  2095639259: "IFCPRODUCTREPRESENTATION",
  2417041796: "IFCPRESENTATIONSTYLEASSIGNMENT",
  3119450353: "IFCPRESENTATIONSTYLE",
  1304840413: "IFCPRESENTATIONLAYERWITHSTYLE",
  2022622350: "IFCPRESENTATIONLAYERASSIGNMENT",
  1775413392: "IFCPREDEFINEDTEXTFONT",
  3213052703: "IFCPREDEFINEDTERMINATORSYMBOL",
  990879717: "IFCPREDEFINEDSYMBOL",
  3727388367: "IFCPREDEFINEDITEM",
  3355820592: "IFCPOSTALADDRESS",
  2226359599: "IFCPHYSICALSIMPLEQUANTITY",
  2483315170: "IFCPHYSICALQUANTITY",
  101040310: "IFCPERSONANDORGANIZATION",
  2077209135: "IFCPERSON",
  1207048766: "IFCOWNERHISTORY",
  1411181986: "IFCORGANIZATIONRELATIONSHIP",
  4251960020: "IFCORGANIZATION",
  1227763645: "IFCOPTICALMATERIALPROPERTIES",
  2251480897: "IFCOBJECTIVE",
  3701648758: "IFCOBJECTPLACEMENT",
  1918398963: "IFCNAMEDUNIT",
  2706619895: "IFCMONETARYUNIT",
  3368373690: "IFCMETRIC",
  677618848: "IFCMECHANICALSTEELMATERIALPROPERTIES",
  4256014907: "IFCMECHANICALMATERIALPROPERTIES",
  2597039031: "IFCMEASUREWITHUNIT",
  3265635763: "IFCMATERIALPROPERTIES",
  2199411900: "IFCMATERIALLIST",
  1303795690: "IFCMATERIALLAYERSETUSAGE",
  3303938423: "IFCMATERIALLAYERSET",
  248100487: "IFCMATERIALLAYER",
  1847130766: "IFCMATERIALCLASSIFICATIONRELATIONSHIP",
  1838606355: "IFCMATERIAL",
  30780891: "IFCLOCALTIME",
  1566485204: "IFCLIGHTINTENSITYDISTRIBUTION",
  4162380809: "IFCLIGHTDISTRIBUTIONDATA",
  3452421091: "IFCLIBRARYREFERENCE",
  2655187982: "IFCLIBRARYINFORMATION",
  3020489413: "IFCIRREGULARTIMESERIESVALUE",
  852622518: "IFCGRIDAXIS",
  3548104201: "IFCEXTERNALLYDEFINEDTEXTFONT",
  3207319532: "IFCEXTERNALLYDEFINEDSYMBOL",
  1040185647: "IFCEXTERNALLYDEFINEDSURFACESTYLE",
  2242383968: "IFCEXTERNALLYDEFINEDHATCHSTYLE",
  3200245327: "IFCEXTERNALREFERENCE",
  1648886627: "IFCENVIRONMENTALIMPACTVALUE",
  3796139169: "IFCDRAUGHTINGCALLOUTRELATIONSHIP",
  770865208: "IFCDOCUMENTINFORMATIONRELATIONSHIP",
  1154170062: "IFCDOCUMENTINFORMATION",
  1376555844: "IFCDOCUMENTELECTRONICFORMAT",
  2949456006: "IFCDIMENSIONALEXPONENTS",
  1045800335: "IFCDERIVEDUNITELEMENT",
  1765591967: "IFCDERIVEDUNIT",
  1072939445: "IFCDATEANDTIME",
  3510044353: "IFCCURVESTYLEFONTPATTERN",
  2367409068: "IFCCURVESTYLEFONTANDSCALING",
  1105321065: "IFCCURVESTYLEFONT",
  539742890: "IFCCURRENCYRELATIONSHIP",
  602808272: "IFCCOSTVALUE",
  1065062679: "IFCCOORDINATEDUNIVERSALTIMEOFFSET",
  347226245: "IFCCONSTRAINTRELATIONSHIP",
  613356794: "IFCCONSTRAINTCLASSIFICATIONRELATIONSHIP",
  1658513725: "IFCCONSTRAINTAGGREGATIONRELATIONSHIP",
  1959218052: "IFCCONSTRAINT",
  2732653382: "IFCCONNECTIONSURFACEGEOMETRY",
  4257277454: "IFCCONNECTIONPORTGEOMETRY",
  2614616156: "IFCCONNECTIONPOINTGEOMETRY",
  2859738748: "IFCCONNECTIONGEOMETRY",
  3264961684: "IFCCOLOURSPECIFICATION",
  3639012971: "IFCCLASSIFICATIONNOTATIONFACET",
  938368621: "IFCCLASSIFICATIONNOTATION",
  1098599126: "IFCCLASSIFICATIONITEMRELATIONSHIP",
  1767535486: "IFCCLASSIFICATIONITEM",
  747523909: "IFCCLASSIFICATION",
  622194075: "IFCCALENDARDATE",
  2069777674: "IFCBOUNDARYNODECONDITIONWARPING",
  1387855156: "IFCBOUNDARYNODECONDITION",
  3367102660: "IFCBOUNDARYFACECONDITION",
  1560379544: "IFCBOUNDARYEDGECONDITION",
  4037036970: "IFCBOUNDARYCONDITION",
  3869604511: "IFCAPPROVALRELATIONSHIP",
  390851274: "IFCAPPROVALPROPERTYRELATIONSHIP",
  2080292479: "IFCAPPROVALACTORRELATIONSHIP",
  130549933: "IFCAPPROVAL",
  1110488051: "IFCAPPLIEDVALUERELATIONSHIP",
  411424972: "IFCAPPLIEDVALUE",
  639542469: "IFCAPPLICATION",
  618182010: "IFCADDRESS",
  3630933823: "IFCACTORROLE",
  599546466: "FILE_DESCRIPTION",
  1390159747: "FILE_NAME",
  1109904537: "FILE_SCHEMA"
};
var Kt = class _Kt {
  static async getUnits(s) {
    var n;
    const { IFCUNITASSIGNMENT: t } = web_ifc_api_exports, e = await s.getAllPropertiesOfType(t);
    if (!e)
      return 1;
    const i = Object.keys(e), o = e[parseInt(i[0], 10)];
    for (const r of o.Units) {
      if (r.value === void 0 || r.value === null)
        continue;
      const a = await s.getProperties(r.value);
      if (!a || !a.UnitType || !a.UnitType.value || a.UnitType.value !== "LENGTHUNIT")
        continue;
      let h = 1, d = 1;
      return a.Name.value === "METRE" && (d = 1), a.Name.value === "FOOT" && (d = 0.3048), ((n = a.Prefix) == null ? void 0 : n.value) === "MILLI" && (h = 1e-3), d * h;
    }
    return 1;
  }
  static async findItemByGuid(s, t) {
    var i;
    const e = s.getAllPropertiesIDs();
    for (const o of e) {
      const n = await s.getProperties(o);
      if (n && ((i = n.GlobalId) == null ? void 0 : i.value) === t)
        return n;
    }
    return null;
  }
  static async getRelationMap(s, t, e) {
    var a;
    const o = e ?? (async () => {
    }), n = {}, r = s.getAllPropertiesIDs();
    for (const c of r) {
      const h = await s.getProperties(c);
      if (!h)
        continue;
      const d = h.type === t, E = Object.keys(h).find(
        (C) => C.startsWith("Relating")
      ), u = Object.keys(h).find(
        (C) => C.startsWith("Related")
      );
      if (!(d && E && u))
        continue;
      const p = await s.getProperties((a = h[E]) == null ? void 0 : a.value), A = h[u];
      if (!p || !A || !(A && Array.isArray(A)))
        continue;
      const m = A.map((C) => C.value);
      await o(p.expressID, m), n[p.expressID] = m;
    }
    return n;
  }
  static async getQsetQuantities(s, t, e) {
    const o = e ?? (() => {
    }), n = await s.getProperties(t);
    return !n || n.type !== IFCELEMENTQUANTITY ? null : (n.Quantities ?? [{}]).map((c) => (c.value && o(c.value), c.value)).filter((c) => c !== null);
  }
  static async getPsetProps(s, t, e) {
    const o = e ?? (() => {
    }), n = await s.getProperties(t);
    return !n || n.type !== IFCPROPERTYSET ? null : (n.HasProperties ?? [{}]).map((c) => (c.value && o(c.value), c.value)).filter((c) => c !== null);
  }
  static async getPsetRel(s, t) {
    var r;
    if (!await s.getProperties(t))
      return null;
    const i = await s.getAllPropertiesOfType(
      IFCRELDEFINESBYPROPERTIES
    );
    if (!i)
      return null;
    const o = Object.values(i);
    let n = null;
    for (const a of o)
      ((r = a.RelatingPropertyDefinition) == null ? void 0 : r.value) === t && (n = a.expressID);
    return n;
  }
  static async getQsetRel(s, t) {
    return _Kt.getPsetRel(s, t);
  }
  static async getEntityName(s, t) {
    var n;
    const e = await s.getProperties(t);
    if (!e)
      return { key: null, name: null };
    const i = Object.keys(e).find((r) => r.endsWith("Name")) ?? null, o = i ? (n = e[i]) == null ? void 0 : n.value : null;
    return { key: i, name: o };
  }
  static async getQuantityValue(s, t) {
    const e = await s.getProperties(t);
    if (!e)
      return { key: null, value: null };
    const i = Object.keys(e).find((n) => n.endsWith("Value")) ?? null;
    let o;
    return i === null || e[i] === void 0 || e[i] === null ? o = null : o = e[i].value, { key: i, value: o };
  }
  static isRel(s) {
    return Bn[s].startsWith("IFCREL");
  }
  static async attributeExists(s, t, e) {
    const i = await s.getProperties(t);
    return i ? Object.keys(i).includes(e) : false;
  }
  static async groupEntitiesByType(s, t) {
    var i;
    const e = /* @__PURE__ */ new Map();
    for (const o of t) {
      const n = await s.getProperties(o);
      if (!n)
        continue;
      const r = n.type;
      e.get(r) || e.set(r, /* @__PURE__ */ new Set()), (i = e.get(r)) == null || i.add(o);
    }
    return e;
  }
  // static getPropertyUnits(properties: IfcProperties, expressID: number) {
  //   const entity = properties[expressID];
  //   if (!entity) return null;
  //   const propertyInstance =
  //     entity instanceof WEBIFC.IFC2X3.IfcProperty ||
  //     entity instanceof WEBIFC.IFC4.IfcProperty ||
  //     entity instanceof WEBIFC.IFC4X3.IfcProperty;
  //   if (!propertyInstance) return null;
  //   const { key: valueKey } = IfcPropertiesUtils.getQuantityValue(
  //     properties,
  //     expressID
  //   );
  //   if (!valueKey) return null;
  //   // @ts-ignore
  //   const measureName = entity[valueKey].constructor.name as string;
  //   const isMeasureAttribute = measureName.endsWith("Measure");
  //   if (!isMeasureAttribute) return null;
  //   const measureType = measureName.slice(3, measureName.length - 7);
  //   return propertyInstance;
  // }
};
var jr = class {
  constructor() {
    I(this, "factor", 1);
    I(this, "complement", 1);
  }
  apply(s) {
    const e = this.getScaleMatrix().multiply(s);
    s.copy(e);
  }
  setUp(s) {
    var o;
    this.factor = 1;
    const t = this.getLengthUnits(s);
    if (!t)
      return;
    const e = t == null, i = t.Name === void 0 || t.Name === null;
    e || i || (t.Name.value === "FOOT" ? this.factor = 0.3048 : ((o = t.Prefix) == null ? void 0 : o.value) === "MILLI" && (this.complement = 1e-3));
  }
  getLengthUnits(s) {
    try {
      const e = s.GetLineIDsWithType(
        0,
        IFCUNITASSIGNMENT
      ).get(0), i = s.GetLine(0, e);
      for (const o of i.Units) {
        if (!o || o.value === null || o.value === void 0)
          continue;
        const n = s.GetLine(0, o.value);
        if (n.UnitType && n.UnitType.value === "LENGTHUNIT")
          return n;
      }
      return null;
    } catch {
      return console.log("Could not get units"), null;
    }
  }
  getScaleMatrix() {
    const s = this.factor;
    return new Matrix4().fromArray([
      s,
      0,
      0,
      0,
      0,
      s,
      0,
      0,
      0,
      0,
      s,
      0,
      0,
      0,
      0,
      1
    ]);
  }
};
var Yn = class {
  constructor() {
    I(this, "itemsByFloor", {});
    I(this, "_units", new jr());
  }
  // TODO: Maybe make this more flexible so that it also support more exotic spatial structures?
  setUp(s) {
    this._units.setUp(s), this.cleanUp();
    try {
      const t = s.GetLineIDsWithType(
        0,
        IFCRELCONTAINEDINSPATIALSTRUCTURE
      ), e = /* @__PURE__ */ new Set(), i = s.GetLineIDsWithType(0, IFCSPACE);
      for (let c = 0; c < i.size(); c++)
        e.add(i.get(c));
      const o = s.GetLineIDsWithType(0, IFCRELAGGREGATES), n = o.size();
      for (let c = 0; c < n; c++) {
        const h = o.get(c), d = s.GetLine(0, h);
        if (!d || !d.RelatingObject || !d.RelatedObjects)
          continue;
        const E = d.RelatingObject.value, u = d.RelatedObjects;
        for (const p of u) {
          const A = p.value;
          e.has(A) && (this.itemsByFloor[A] = E);
        }
      }
      const r = {}, a = t.size();
      for (let c = 0; c < a; c++) {
        const h = t.get(c), d = s.GetLine(0, h);
        if (!d || !d.RelatingStructure || !d.RelatedElements)
          continue;
        const E = d.RelatingStructure.value, u = d.RelatedElements;
        if (e.has(E))
          for (const p of u) {
            r[E] || (r[E] = []);
            const A = p.value;
            r[E].push(A);
          }
        else
          for (const p of u) {
            const A = p.value;
            this.itemsByFloor[A] = E;
          }
      }
      for (const c in r) {
        const h = this.itemsByFloor[c];
        if (h !== void 0) {
          const d = r[c];
          for (const E of d)
            this.itemsByFloor[E] = h;
        }
      }
      for (let c = 0; c < n; c++) {
        const h = o.get(c), d = s.GetLine(0, h);
        if (!d || !d.RelatingObject || !d.RelatedObjects)
          continue;
        const E = d.RelatingObject.value, u = d.RelatedObjects;
        for (const p of u) {
          const A = p.value, m = this.itemsByFloor[E];
          m !== void 0 && (this.itemsByFloor[A] = m);
        }
      }
    } catch {
      console.log("Could not get floors.");
    }
  }
  cleanUp() {
    this.itemsByFloor = {};
  }
};
var yi = class {
  constructor() {
    I(this, "includeProperties", true);
    I(this, "optionalCategories", [IFCSPACE]);
    I(this, "coordinate", true);
    I(this, "wasm", {
      path: "",
      absolute: false,
      logLevel: LogLevel.LOG_LEVEL_OFF
    });
    I(this, "excludedCategories", /* @__PURE__ */ new Set());
    I(this, "saveLocations", false);
    I(this, "webIfc", {
      COORDINATE_TO_ORIGIN: true,
      OPTIMIZE_PROFILES: true
    });
    I(this, "autoSetWasm", true);
    I(this, "customLocateFileHandler", null);
  }
};
var Vn = class {
  constructor() {
    I(this, "defLineMat", new LineBasicMaterial({ color: 16777215 }));
  }
  read(s) {
    const t = s.GetAllAlignments(0), e = s.GetAllCrossSections2D(0), i = s.GetAllCrossSections3D(0), o = {
      IfcAlignment: t,
      IfcCrossSection2D: e,
      IfcCrossSection3D: i
    };
    return this.get(o);
  }
  get(s) {
    if (s.IfcAlignment) {
      const t = /* @__PURE__ */ new Map();
      for (const e of s.IfcAlignment) {
        const i = new ki();
        i.absolute = this.getCurves(e.curve3D, i), i.horizontal = this.getCurves(e.horizontal, i), i.vertical = this.getCurves(e.vertical, i), t.set(t.size, i);
      }
      return { alignments: t, coordinationMatrix: new Matrix4() };
    }
  }
  getCurves(s, t) {
    const e = [];
    let i = 0;
    for (const o of s) {
      const n = {};
      if (o.data)
        for (const E of o.data) {
          const [u, p] = E.split(": "), A = parseFloat(p);
          n[u] = A || p;
        }
      const { points: r } = o, a = new Float32Array(r.length * 3);
      for (let E = 0; E < r.length; E++) {
        const { x: u, y: p, z: A } = r[E];
        a[E * 3] = u, a[E * 3 + 1] = p, a[E * 3 + 2] = A || 0;
      }
      const c = new BufferAttribute(a, 3), h = new EdgesGeometry();
      h.setAttribute("position", c);
      const d = new ji(
        i,
        n,
        t,
        h,
        this.defLineMat
      );
      e.push(d.curve), i++;
    }
    return e;
  }
};
var Gn = class {
  getNameInfo(s) {
    var d;
    const t = {}, { arguments: e } = s.GetHeaderLine(0, FILE_NAME) || {};
    if (!e)
      return t;
    const [
      i,
      o,
      n,
      r,
      a,
      c,
      h
    ] = e;
    if (i != null && i.value && (t.name = i.value), o != null && o.value && (t.creationDate = new Date(o.value)), n) {
      t.author = {};
      const [E, u] = n;
      E != null && E.value && (t.author.name = E.value), u != null && u.value && (t.author.email = u.value);
    }
    return (d = r[0]) != null && d.value && (t.organization = r[0].value), a != null && a.value && (t.preprocessorVersion = a == null ? void 0 : a.value), c != null && c.value && (t.originatingSystem = c == null ? void 0 : c.value), h != null && h.value && (t.authorization = h == null ? void 0 : h.value), t;
  }
  getDescriptionInfo(s) {
    var n;
    const t = {}, { arguments: e } = s.GetHeaderLine(0, FILE_DESCRIPTION) || {};
    if (!e)
      return t;
    const [i, o] = e;
    if ((n = i[0]) != null && n.value) {
      const r = i[0].value.match(/\[([^\]]+)\]/);
      r[1] && (t.viewDefinition = r[1]);
    }
    return o != null && o.value && (t.implementationLevel = o.value), t;
  }
};
var Ge = class Ge2 extends J {
  constructor(t) {
    super(t);
    I(this, "onIfcStartedLoading", new D());
    I(this, "onSetup", new D());
    I(this, "onDisposed", new D());
    I(this, "settings", new yi());
    I(this, "enabled", true);
    I(this, "webIfc", new IfcAPI2());
    I(this, "_material", new MeshLambertMaterial());
    I(this, "_spatialTree", new Yn());
    I(this, "_metaData", new Gn());
    I(this, "_fragmentInstances", /* @__PURE__ */ new Map());
    I(this, "_civil", new Vn());
    I(this, "_visitedFragments", /* @__PURE__ */ new Map());
    I(this, "_materialT", new MeshLambertMaterial({
      transparent: true,
      opacity: 0.5
    }));
    this.components.add(Ge2.uuid, this), this.settings.excludedCategories.add(IFCOPENINGELEMENT);
  }
  dispose() {
    this.webIfc = null, this.onDisposed.trigger(Ge2.uuid), this.onDisposed.reset();
  }
  async setup(t) {
    this.settings = { ...this.settings, ...t }, this.settings.autoSetWasm && await this.autoSetWasm(), this.onSetup.trigger();
  }
  async load(t, e = true) {
    const i = performance.now();
    this.onIfcStartedLoading.trigger(), await this.readIfcFile(t);
    const o = await this.getAllGeometries(), r = await this.components.get(mi).export(this.webIfc, 0);
    o.setLocalProperties(r), this.cleanUp();
    const a = this.components.get(ut);
    a.groups.set(o.uuid, o);
    for (const c of o.items)
      a.list.set(c.id, c), c.mesh.uuid = c.id, c.group = o;
    return a.onFragmentsLoaded.trigger(o), e && a.coordinate([o]), console.log(`Streaming the IFC took ${performance.now() - i} ms!`), o;
  }
  async readIfcFile(t) {
    const { path: e, absolute: i, logLevel: o } = this.settings.wasm;
    return this.webIfc.SetWasmPath(e, i), await this.webIfc.Init(), o && this.webIfc.SetLogLevel(o), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  async getAllGeometries() {
    this._spatialTree.setUp(this.webIfc);
    const t = this.webIfc.GetIfcEntityList(0), e = new Gi();
    e.ifcMetadata = {
      name: "",
      description: "",
      ...this._metaData.getNameInfo(this.webIfc),
      ...this._metaData.getDescriptionInfo(this.webIfc),
      schema: this.webIfc.GetModelSchema(0) || "IFC2X3",
      maxExpressID: this.webIfc.GetMaxExpressID(0)
    };
    const i = [];
    for (const n of t) {
      if (!this.webIfc.IsIfcElement(n) && n !== IFCSPACE || this.settings.excludedCategories.has(n))
        continue;
      const r = this.webIfc.GetLineIDsWithType(0, n), a = r.size();
      for (let c = 0; c < a; c++) {
        const h = r.get(c);
        i.push(h);
        const d = this._spatialTree.itemsByFloor[h] || 0;
        e.data.set(h, [[], [d, n]]);
      }
    }
    this._spatialTree.cleanUp(), this.webIfc.StreamMeshes(0, i, (n) => {
      this.getMesh(n, e);
    });
    for (const n of this._visitedFragments) {
      const { index: r, fragment: a } = n[1];
      e.keyFragments.set(r, a.id);
    }
    for (const n of e.items) {
      const r = this._fragmentInstances.get(n.id);
      if (!r)
        throw new Error("Fragment not found!");
      const a = [];
      for (const [c, h] of r)
        a.push(h);
      n.add(a);
    }
    const o = this.webIfc.GetCoordinationMatrix(0);
    return e.coordinationMatrix.fromArray(o), e.civilData = this._civil.read(this.webIfc), e;
  }
  cleanUp() {
    this.webIfc = null, this.webIfc = new IfcAPI2(), this._visitedFragments.clear(), this._fragmentInstances.clear();
  }
  getMesh(t, e) {
    const i = t.geometries.size(), o = t.expressID;
    for (let n = 0; n < i; n++) {
      const r = t.geometries.get(n), { x: a, y: c, z: h, w: d } = r.color, E = d !== 1, { geometryExpressID: u } = r, p = `${u}-${E}`;
      if (!this._visitedFragments.has(p)) {
        const T = this.getGeometry(this.webIfc, u), O = E ? this._materialT : this._material, S = new Ni(T, O, 1);
        e.add(S.mesh), e.items.push(S);
        const _ = this._visitedFragments.size;
        this._visitedFragments.set(p, { index: _, fragment: S });
      }
      const A = new Color().setRGB(a, c, h, "srgb"), m = new Matrix4();
      m.fromArray(r.flatTransformation);
      const C = this._visitedFragments.get(p);
      if (C === void 0)
        throw new Error("Error getting geometry data for streaming!");
      const R = e.data.get(o);
      if (!R)
        throw new Error("Data not found!");
      R[0].push(C.index);
      const { fragment: F } = C;
      this._fragmentInstances.has(F.id) || this._fragmentInstances.set(F.id, /* @__PURE__ */ new Map());
      const f = this._fragmentInstances.get(F.id);
      if (!f)
        throw new Error("Instances not found!");
      if (f.has(o)) {
        const T = f.get(o);
        if (!T)
          throw new Error("Instance not found!");
        T.transforms.push(m), T.colors && T.colors.push(A);
      } else
        f.set(o, { id: o, transforms: [m], colors: [A] });
    }
  }
  getGeometry(t, e) {
    const i = t.GetGeometry(0, e), o = t.GetIndexArray(
      i.GetIndexData(),
      i.GetIndexDataSize()
    ), n = t.GetVertexArray(
      i.GetVertexData(),
      i.GetVertexDataSize()
    ), r = new Float32Array(n.length / 2), a = new Float32Array(n.length / 2);
    for (let E = 0; E < n.length; E += 6)
      r[E / 2] = n[E], r[E / 2 + 1] = n[E + 1], r[E / 2 + 2] = n[E + 2], a[E / 2] = n[E + 3], a[E / 2 + 1] = n[E + 4], a[E / 2 + 2] = n[E + 5];
    const c = new BufferGeometry(), h = new BufferAttribute(r, 3), d = new BufferAttribute(a, 3);
    return c.setAttribute("position", h), c.setAttribute("normal", d), c.setIndex(Array.from(o)), i.delete(), c;
  }
  async autoSetWasm() {
    const t = await fetch(
      `https://unpkg.com/openbim-components@${pi.release}/package.json`
    );
    if (!t.ok) {
      console.warn(
        "Couldn't get openbim-components package.json. Set wasm settings manually."
      );
      return;
    }
    const e = await t.json();
    if (!("web-ifc" in e.peerDependencies))
      console.warn(
        "Couldn't get web-ifc from peer dependencies in openbim-components. Set wasm settings manually."
      );
    else {
      const i = e.peerDependencies["web-ifc"];
      this.settings.wasm.path = `https://unpkg.com/web-ifc@${i}/`, this.settings.wasm.absolute = true;
    }
  }
};
I(Ge, "uuid", "a659add7-1418-4771-a0d6-7d4d438e4624");
var Ri = Ge;
var Bt = class Bt2 extends J {
  constructor(t) {
    super(t);
    I(this, "onDisposed", new D());
    I(this, "onRequestFile", new D());
    I(this, "ifcToExport", null);
    I(this, "onElementToPset", new D());
    I(this, "onPropToPset", new D());
    I(this, "onPsetRemoved", new D());
    I(this, "onDataChanged", new D());
    I(this, "wasm", {
      path: "/",
      absolute: false
    });
    I(this, "enabled", true);
    I(this, "attributeListeners", {});
    I(this, "selectedModel");
    I(this, "changeMap", {});
    this.components.add(Bt2.uuid, this);
  }
  dispose() {
    this.selectedModel = void 0, this.attributeListeners = {}, this.changeMap = {}, this.onElementToPset.reset(), this.onPropToPset.reset(), this.onPsetRemoved.reset(), this.onDataChanged.reset(), this.onDisposed.trigger(Bt2.uuid), this.onDisposed.reset();
  }
  increaseMaxID(t) {
    return t.ifcMetadata.maxExpressID++, t.ifcMetadata.maxExpressID;
  }
  static getIFCSchema(t) {
    const e = t.ifcMetadata.schema;
    if (!e)
      throw new Error("IFC Schema not found");
    return e;
  }
  newGUID(t) {
    const e = Bt2.getIFCSchema(t);
    return new web_ifc_api_exports[e].IfcGloballyUniqueId(ze.create());
  }
  async getOwnerHistory(t) {
    const e = await t.getAllPropertiesOfType(
      IFCOWNERHISTORY
    );
    if (!e)
      throw new Error("No OwnerHistory was found.");
    const i = Object.keys(e).map((r) => parseInt(r, 10)), o = e[i[0]], n = new Handle(o.expressID);
    return { ownerHistory: o, ownerHistoryHandle: n };
  }
  registerChange(t, ...e) {
    this.changeMap[t.uuid] || (this.changeMap[t.uuid] = /* @__PURE__ */ new Set());
    for (const i of e)
      this.changeMap[t.uuid].add(i), this.onDataChanged.trigger({ model: t, expressID: i });
  }
  async setData(t, ...e) {
    for (const i of e) {
      const o = i.expressID;
      o && (await t.setProperties(o, i), this.registerChange(t, o));
    }
  }
  async newPset(t, e, i) {
    const o = Bt2.getIFCSchema(t), { ownerHistoryHandle: n } = await this.getOwnerHistory(t), r = this.newGUID(t), a = new web_ifc_api_exports[o].IfcLabel(e), c = i ? new web_ifc_api_exports[o].IfcText(i) : null, h = new web_ifc_api_exports[o].IfcPropertySet(
      r,
      n,
      a,
      c,
      []
    );
    h.expressID = this.increaseMaxID(t);
    const d = this.newGUID(t), E = new web_ifc_api_exports[o].IfcRelDefinesByProperties(
      d,
      n,
      null,
      null,
      [],
      new Handle(h.expressID)
    );
    return E.expressID = this.increaseMaxID(t), await this.setData(t, h, E), { pset: h, rel: E };
  }
  async removePset(t, ...e) {
    for (const i of e) {
      const o = await t.getProperties(i);
      if ((o == null ? void 0 : o.type) !== IFCPROPERTYSET)
        continue;
      const n = await Kt.getPsetRel(t, i);
      if (n && (await t.setProperties(n, null), this.registerChange(t, n)), o) {
        for (const r of o.HasProperties)
          await t.setProperties(r.value, null);
        await t.setProperties(i, null), this.onPsetRemoved.trigger({ model: t, psetID: i }), this.registerChange(t, i);
      }
    }
  }
  async newSingleProperty(t, e, i, o) {
    const n = Bt2.getIFCSchema(t), r = new web_ifc_api_exports[n].IfcIdentifier(i), a = new web_ifc_api_exports[n][e](o), c = new web_ifc_api_exports[n].IfcPropertySingleValue(
      r,
      null,
      a,
      null
    );
    return c.expressID = this.increaseMaxID(t), await this.setData(t, c), c;
  }
  newSingleStringProperty(t, e, i, o) {
    return this.newSingleProperty(t, e, i, o);
  }
  newSingleNumericProperty(t, e, i, o) {
    return this.newSingleProperty(t, e, i, o);
  }
  newSingleBooleanProperty(t, e, i, o) {
    return this.newSingleProperty(t, e, i, o);
  }
  async removePsetProp(t, e, i) {
    const o = await t.getProperties(e), n = await t.getProperties(i);
    !o || !n || o.type === IFCPROPERTYSET && n && (o.HasProperties = o.HasProperties.filter((r) => r.value !== i), await t.setProperties(i, null), this.registerChange(t, e, i));
  }
  async addElementToPset(t, e, ...i) {
    const o = await Kt.getPsetRel(t, e);
    if (!o)
      return;
    const n = await t.getProperties(o);
    if (n) {
      for (const r of i) {
        const a = new Handle(r);
        n.RelatedObjects.push(a), this.onElementToPset.trigger({
          model: t,
          psetID: e,
          elementID: r
        });
      }
      this.registerChange(t, e);
    }
  }
  async addPropToPset(t, e, ...i) {
    const o = await t.getProperties(e);
    if (o) {
      for (const n of i) {
        if (o.HasProperties.includes(n))
          continue;
        const r = new Handle(n);
        o.HasProperties.push(r), this.onPropToPset.trigger({ model: t, psetID: e, propID: n });
      }
      this.registerChange(t, e);
    }
  }
  async saveToIfc(t, e) {
    const i = this.components.get(Ri), o = i.webIfc, n = await i.readIfcFile(e), r = this.changeMap[t.uuid] ?? [];
    for (const c of r) {
      const h = await t.getProperties(c);
      if (h)
        try {
          o.WriteLine(n, h);
        } catch {
        }
      else
        try {
          o.DeleteLine(n, c);
        } catch {
        }
    }
    const a = o.SaveModel(n);
    return i.webIfc.CloseModel(n), i.cleanUp(), a;
  }
  async setAttributeListener(t, e, i) {
    this.attributeListeners[t.uuid] || (this.attributeListeners[t.uuid] = {});
    const o = this.attributeListeners[t.uuid][e] ? this.attributeListeners[t.uuid][e][i] : null;
    if (o)
      return o;
    const n = await t.getProperties(e);
    if (!n)
      throw new Error(`Entity with expressID ${e} doesn't exists.`);
    const r = n[i];
    if (Array.isArray(r) || !r)
      throw new Error(
        `Attribute ${i} is array or null, and it can't have a listener.`
      );
    const a = r.value;
    if (a === void 0 || a == null)
      throw new Error(`Attribute ${i} has a badly defined handle.`);
    const c = new D();
    return Object.defineProperty(n[i], "value", {
      get() {
        return this._value;
      },
      async set(h) {
        this._value = h, c.trigger(h);
      }
    }), n[i].value = a, this.attributeListeners[t.uuid][e] || (this.attributeListeners[t.uuid][e] = {}), this.attributeListeners[t.uuid][e][i] = c, c;
  }
};
I(Bt, "uuid", "58c2d9f0-183c-48d6-a402-dfcf5b9a34df");
var gn = Bt;
var Ls = class Ls2 extends J {
  constructor(t) {
    super(t);
    I(this, "enabled", true);
    I(this, "list", {});
    I(this, "onDisposed", new D());
    I(this, "onFragmentsDisposed", (t2) => {
      const { groupID: e, fragmentIDs: i } = t2;
      for (const o in this.list) {
        const n = this.list[o], r = Object.keys(n);
        if (r.includes(e))
          delete n[e], Object.values(n).length === 0 && delete this.list[o];
        else
          for (const a of r) {
            const c = n[a];
            for (const h of i)
              delete c[h];
            Object.values(c).length === 0 && delete n[a];
          }
      }
    });
    t.add(Ls2.uuid, this), t.get(ut).onFragmentsDisposed.add(this.onFragmentsDisposed);
  }
  dispose() {
    this.list = {}, this.components.get(ut).onFragmentsDisposed.remove(this.onFragmentsDisposed), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  remove(t) {
    for (const e in this.list) {
      const i = this.list[e];
      for (const o in i) {
        const n = i[o];
        delete n[t];
      }
    }
  }
  find(t) {
    const e = this.components.get(ut);
    if (!t) {
      const r = {};
      for (const [a, c] of e.list)
        r[a] = new Set(c.ids);
      return r;
    }
    const i = Object.keys(t).length, o = {};
    for (const r in t) {
      const a = t[r];
      if (!this.list[r]) {
        console.warn(`Classification ${r} does not exist.`);
        continue;
      }
      for (const c of a) {
        const h = this.list[r][c];
        if (h)
          for (const d in h) {
            o[d] || (o[d] = /* @__PURE__ */ new Map());
            for (const E of h[d]) {
              const u = o[d].get(E);
              u === void 0 ? o[d].set(E, 1) : o[d].set(E, u + 1);
            }
          }
      }
    }
    const n = {};
    for (const r in o) {
      const a = o[r];
      for (const [c, h] of a) {
        if (h === void 0)
          throw new Error("Malformed fragments map!");
        h === i && (n[r] || (n[r] = /* @__PURE__ */ new Set()), n[r].add(c));
      }
    }
    return n;
  }
  byModel(t, e) {
    this.list.models || (this.list.models = {});
    const i = this.list.models;
    i[t] || (i[t] = {});
    const o = i[t];
    for (const [n, r] of e.data) {
      const a = r[0];
      for (const c of a) {
        const h = e.keyFragments.get(c);
        h && (o[h] || (o[h] = /* @__PURE__ */ new Set()), o[h].add(n));
      }
    }
  }
  async byPredefinedType(t) {
    var o;
    this.list.predefinedTypes || (this.list.predefinedTypes = {});
    const e = this.list.predefinedTypes, i = t.getAllPropertiesIDs();
    for (const n of i) {
      const r = await t.getProperties(n);
      if (!r)
        continue;
      const a = String((o = r.PredefinedType) == null ? void 0 : o.value).toUpperCase();
      e[a] || (e[a] = {});
      const c = e[a];
      for (const [h, d] of t.data) {
        const E = d[0];
        for (const u of E) {
          const p = t.keyFragments.get(u);
          if (!p)
            throw new Error("Fragment ID not found!");
          c[p] || (c[p] = /* @__PURE__ */ new Set()), c[p].add(r.expressID);
        }
      }
    }
  }
  byEntity(t) {
    this.list.entities || (this.list.entities = {});
    for (const [e, i] of t.data) {
      const n = i[1][1], r = Bn[n];
      this.saveItem(t, "entities", r, e);
    }
  }
  async byIfcRel(t, e, i) {
    Kt.isRel(e) && await Kt.getRelationMap(
      t,
      e,
      async (o, n) => {
        const { name: r } = await Kt.getEntityName(
          t,
          o
        );
        for (const a of n)
          this.saveItem(
            t,
            i,
            r ?? "NO REL NAME",
            a
          );
      }
    );
  }
  async bySpatialStructure(t) {
    var n;
    const e = this.components.get(We), i = e.relationMaps[t.uuid];
    if (!i)
      throw new Error(
        `Classifier: model relations of ${t.name || t.uuid} have to exists to group by spatial structure.`
      );
    const o = "spatialStructures";
    for (const [r] of i) {
      const a = e.getEntityRelations(
        t,
        r,
        "ContainsElements"
      ), c = await t.getProperties(r);
      if (!(a && c))
        continue;
      const h = (n = c.Name) == null ? void 0 : n.value;
      for (const d of a) {
        this.saveItem(t, o, h, d);
        const E = e.getEntityRelations(
          t,
          Number(d),
          "IsDecomposedBy"
        );
        if (E)
          for (const u of E)
            this.saveItem(t, o, h, u);
      }
    }
  }
  setColor(t, e, i = false) {
    const o = this.components.get(ut);
    for (const n in t) {
      const r = o.list.get(n);
      if (!r)
        continue;
      const a = t[n];
      r.setColor(e, a, i);
    }
  }
  resetColor(t) {
    const e = this.components.get(ut);
    for (const i in t) {
      const o = e.list.get(i);
      if (!o)
        continue;
      const n = t[i];
      o.resetColor(n);
    }
  }
  saveItem(t, e, i, o) {
    this.list[e] || (this.list[e] = {});
    const n = t.data.get(o);
    if (n)
      for (const r of n[0]) {
        const a = t.keyFragments.get(r);
        if (a) {
          const c = this.list[e];
          c[i] || (c[i] = {}), c[i][a] || (c[i][a] = /* @__PURE__ */ new Set()), c[i][a].add(o);
        }
      }
  }
};
I(Ls, "uuid", "e25a7f3c-46c4-4a14-9d3d-5115f24ebeb7");
var Ai = Ls;
var ys = class ys2 extends J {
  constructor(t) {
    super(t);
    I(this, "enabled", true);
    I(this, "height", 10);
    I(this, "groupName", "storeys");
    I(this, "onDisposed", new D());
    I(this, "list", /* @__PURE__ */ new Set());
    t.add(ys2.uuid, this);
  }
  dispose() {
    this.list.clear(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  set(t) {
    if (!this.enabled)
      return;
    const e = this.components.get(Ai), i = this.components.get(ut), o = t ? 1 : -1;
    let n = 0;
    const r = e.list[this.groupName], a = new Matrix4();
    for (const c in r) {
      a.elements[13] = n * o * this.height;
      for (const h in r[c]) {
        const d = i.list.get(h), E = c + h, u = this.list.has(E);
        if (!d || t && u || !t && !u)
          continue;
        t ? this.list.add(E) : this.list.delete(E);
        const p = r[c][h];
        d.applyTransform(p, a);
      }
      n++;
    }
  }
};
I(ys, "uuid", "d260618b-ce88-4c7d-826c-6debb91de3e2");
var Sn = ys;
var ws = class ws2 extends J {
  constructor(t) {
    super(t);
    I(this, "enabled", true);
    this.components.add(ws2.uuid, this);
  }
  set(t, e) {
    const i = this.components.get(ut);
    if (!e) {
      for (const o in i.list) {
        const n = i.list.get(o);
        n && (n.setVisibility(t), this.updateCulledVisibility(n));
      }
      return;
    }
    for (const o in e) {
      const n = e[o], r = i.list.get(o);
      r && (r.setVisibility(t, n), this.updateCulledVisibility(r));
    }
  }
  isolate(t) {
    this.set(false), this.set(true, t);
  }
  updateCulledVisibility(t) {
    const e = this.components.get(Ti);
    for (const [i, o] of e.list) {
      const n = o.colorMeshes.get(t.id);
      n && (n.count = t.mesh.count);
    }
  }
};
I(ws, "uuid", "dd9ccf2d-8a21-4821-b7f6-2949add16a29");
var _n = ws;
var qr = class extends yi {
  constructor() {
    super(...arguments);
    I(this, "minGeometrySize", 10);
    I(this, "minAssetsSize", 1e3);
  }
};
var zn = class extends yi {
  constructor() {
    super(...arguments);
    I(this, "propertiesSize", 100);
  }
};
var $r = class extends J {
  constructor() {
    super(...arguments);
    I(this, "onPropertiesStreamed", new $t());
    I(this, "onProgress", new $t());
    I(this, "onIndicesStreamed", new $t());
    I(this, "onDisposed", new D());
    I(this, "enabled", true);
    I(this, "settings", new zn());
    I(this, "webIfc", new IfcAPI2());
  }
  async dispose() {
    this.onIndicesStreamed.reset(), this.onPropertiesStreamed.reset(), this.webIfc = null, this.onDisposed.reset();
  }
  async streamFromBuffer(t) {
    const e = performance.now();
    await this.readIfcFile(t), await this.streamAllProperties(), this.cleanUp(), console.log(`Streaming the IFC took ${performance.now() - e} ms!`);
  }
  async streamFromCallBack(t) {
    const e = performance.now();
    await this.streamIfcFile(t), await this.streamAllProperties(), this.cleanUp(), console.log(`Streaming the IFC took ${performance.now() - e} ms!`);
  }
  async readIfcFile(t) {
    const { path: e, absolute: i, logLevel: o } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, i), await this.webIfc.Init(), o && this.webIfc.SetLogLevel(o), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  async streamIfcFile(t) {
    const { path: e, absolute: i, logLevel: o } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, i), await this.webIfc.Init(), o && this.webIfc.SetLogLevel(o), this.webIfc.OpenModelFromCallback(t, this.settings.webIfc);
  }
  async streamAllProperties() {
    const { propertiesSize: t } = this.settings, e = new Set(this.webIfc.GetIfcEntityList(0)), i = [
      IFCRELDEFINESBYPROPERTIES,
      IFCRELDEFINESBYTYPE,
      IFCRELASSOCIATESMATERIAL,
      IFCRELCONTAINEDINSPATIALSTRUCTURE,
      IFCRELASSOCIATESCLASSIFICATION,
      IFCRELASSIGNSTOGROUP
    ], o = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set([
      IFCPROJECT,
      IFCSITE,
      IFCBUILDING,
      IFCBUILDINGSTOREY,
      IFCSPACE
    ]);
    for (const h of n)
      e.add(h);
    let r = 0.01, a = 0;
    for (const h of e) {
      if (a++, Li.has(h))
        continue;
      const d = n.has(h), E = this.webIfc.GetLineIDsWithType(0, h), u = E.size();
      let p = 0;
      for (let m = 0; m < u - t; m += t) {
        const C = {};
        for (let R = 0; R < t; R++) {
          p++;
          const F = E.get(m + R);
          try {
            const f = this.webIfc.GetLine(0, F, d);
            i.includes(h) && this.getIndices(f, F, o), C[f.expressID] = f;
          } catch {
            console.log(`Could not get property: ${F}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type: h, data: C });
      }
      if (p !== u) {
        const m = {};
        for (let C = p; C < u; C++) {
          const R = E.get(C);
          try {
            const F = this.webIfc.GetLine(0, R, d);
            i.includes(h) && this.getIndices(F, R, o), m[F.expressID] = F;
          } catch {
            console.log(`Could not get property: ${R}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type: h, data: m });
      }
      const A = a / e.size;
      A > r && (r += 0.01, r = Math.max(r, A), await this.onProgress.trigger(Math.round(r * 100) / 100));
    }
    const c = [];
    for (const [h, d] of o)
      c.push([h, ...d]);
    await this.onIndicesStreamed.trigger(c);
  }
  getIndices(t, e, i) {
    const o = t.RelatedObjects || t.RelatedElements;
    if (!o) {
      console.log(`Related objects not found: ${e}`);
      return;
    }
    const n = t.RelatingType || t.RelatingMaterial || t.RelatingStructure || t.RelatingPropertyDefinition || t.RelatingGroup || t.RelatingClassification;
    if (!n) {
      console.log(`Relating object not found: ${e}`);
      return;
    }
    if (!Array.isArray(o) || n.value === void 0)
      return;
    const r = n.value;
    for (const a of o) {
      if (a.value === void 0 || a.value === null)
        continue;
      const c = a.value;
      i.has(c) || i.set(c, /* @__PURE__ */ new Set()), i.get(c).add(r);
    }
  }
  cleanUp() {
    this.webIfc = null, this.webIfc = new IfcAPI2();
  }
};
I($r, "uuid", "88d2c89c-ce32-47d7-8cb6-d51e4b311a0b");
var Ms = class Ms2 extends J {
  constructor(t) {
    super(t);
    I(this, "onGeometryStreamed", new D());
    I(this, "onAssetStreamed", new D());
    I(this, "onProgress", new D());
    I(this, "onIfcLoaded", new D());
    I(this, "onDisposed", new D());
    I(this, "settings", new qr());
    I(this, "enabled", true);
    I(this, "webIfc", new IfcAPI2());
    I(this, "_spatialTree", new Yn());
    I(this, "_metaData", new Gn());
    I(this, "_visitedGeometries", /* @__PURE__ */ new Map());
    I(this, "_streamSerializer", new Xi());
    I(this, "_geometries", /* @__PURE__ */ new Map());
    I(this, "_geometryCount", 0);
    I(this, "_civil", new Vn());
    I(this, "_groupSerializer", new Hi());
    I(this, "_assets", []);
    I(this, "_meshesWithHoles", /* @__PURE__ */ new Set());
    this.components.add(Ms2.uuid, this), this.settings.excludedCategories.add(IFCOPENINGELEMENT);
  }
  dispose() {
    this.onIfcLoaded.reset(), this.onGeometryStreamed.reset(), this.onAssetStreamed.reset(), this.webIfc = null, this.onDisposed.trigger(), this.onDisposed.reset();
  }
  async streamFromBuffer(t) {
    const e = performance.now();
    await this.readIfcFile(t), await this.streamAllGeometries(), this.cleanUp(), console.log(`Streaming the IFC took ${performance.now() - e} ms!`);
  }
  async streamFromCallBack(t) {
    const e = performance.now();
    await this.streamIfcFile(t), await this.streamAllGeometries(), this.cleanUp(), console.log(`Streaming the IFC took ${performance.now() - e} ms!`);
  }
  async readIfcFile(t) {
    const { path: e, absolute: i, logLevel: o } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, i), await this.webIfc.Init(), o && this.webIfc.SetLogLevel(o), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  async streamIfcFile(t) {
    const { path: e, absolute: i, logLevel: o } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, i), await this.webIfc.Init(), o && this.webIfc.SetLogLevel(o), this.webIfc.OpenModelFromCallback(t, this.settings.webIfc);
  }
  async streamAllGeometries() {
    const { minGeometrySize: t, minAssetsSize: e } = this.settings;
    this._spatialTree.setUp(this.webIfc);
    const i = this.webIfc.GetIfcEntityList(0), o = [[]], n = new Gi();
    n.ifcMetadata = {
      name: "",
      description: "",
      ...this._metaData.getNameInfo(this.webIfc),
      ...this._metaData.getDescriptionInfo(this.webIfc),
      schema: this.webIfc.GetModelSchema(0) || "IFC2X3",
      maxExpressID: this.webIfc.GetMaxExpressID(0)
    };
    let r = 0, a = 0;
    for (const m of i) {
      if (!this.webIfc.IsIfcElement(m) && m !== IFCSPACE || this.settings.excludedCategories.has(m))
        continue;
      const C = this.webIfc.GetLineIDsWithType(0, m), R = C.size();
      for (let F = 0; F < R; F++) {
        r > t && (r = 0, a++, o.push([]));
        const f = C.get(F);
        o[a].push(f);
        const T = this._spatialTree.itemsByFloor[f] || 0;
        n.data.set(f, [[], [T, m]]), r++;
      }
    }
    this._spatialTree.cleanUp();
    let c = 0.01, h = 0;
    for (const m of o) {
      h++, this.webIfc.StreamMeshes(0, m, (R) => {
        this.getMesh(this.webIfc, R, n);
      }), this._geometryCount > t && await this.streamGeometries(), this._assets.length > e && await this.streamAssets();
      const C = h / o.length;
      C > c && (c += 0.01, c = Math.max(c, C), this.onProgress.trigger(Math.round(c * 100) / 100));
    }
    this._geometryCount && await this.streamGeometries(), this._assets.length && await this.streamAssets();
    const { opaque: d, transparent: E } = n.geometryIDs;
    for (const [m, { index: C, uuid: R }] of this._visitedGeometries)
      n.keyFragments.set(C, R), (m > 1 ? d : E).set(m, C);
    const u = n.data.keys();
    for (const m of u) {
      const [C] = n.data.get(m);
      C.length || n.data.delete(m);
    }
    const p = this.webIfc.GetCoordinationMatrix(0);
    n.coordinationMatrix.fromArray(p), n.civilData = this._civil.read(this.webIfc);
    const A = this._groupSerializer.export(n);
    this.onIfcLoaded.trigger(A), n.dispose(true);
  }
  cleanUp() {
    this.webIfc = null, this.webIfc = new IfcAPI2(), this._visitedGeometries.clear(), this._geometries.clear(), this._assets = [], this._meshesWithHoles.clear();
  }
  getMesh(t, e, i) {
    const o = e.geometries.size(), n = e.expressID, r = { id: n, geometries: [] };
    for (let a = 0; a < o; a++) {
      const c = e.geometries.get(a), h = c.geometryExpressID, d = c.color.w === 1 ? 1 : -1, E = h * d;
      if (!this._visitedGeometries.has(E)) {
        this._visitedGeometries.has(h) || this.getGeometry(t, h);
        const T = this._visitedGeometries.size, O = MathUtils.generateUUID();
        this._visitedGeometries.set(E, { uuid: O, index: T });
      }
      const u = this._visitedGeometries.get(E);
      if (u === void 0)
        throw new Error("Error getting geometry data for streaming!");
      const p = i.data.get(n);
      if (!p)
        throw new Error("Data not found!");
      p[0].push(u.index);
      const { x: A, y: m, z: C, w: R } = c.color, F = [A, m, C, R], f = c.flatTransformation;
      r.geometries.push({ color: F, geometryID: h, transformation: f });
    }
    this._assets.push(r);
  }
  getGeometry(t, e) {
    const i = t.GetGeometry(0, e), o = t.GetIndexArray(
      i.GetIndexData(),
      i.GetIndexDataSize()
    ), n = t.GetVertexArray(
      i.GetVertexData(),
      i.GetVertexDataSize()
    ), r = new Float32Array(n.length / 2), a = new Float32Array(n.length / 2);
    for (let u = 0; u < n.length; u += 6)
      r[u / 2] = n[u], r[u / 2 + 1] = n[u + 1], r[u / 2 + 2] = n[u + 2], a[u / 2] = n[u + 3], a[u / 2 + 1] = n[u + 4], a[u / 2 + 2] = n[u + 5];
    const c = mr(r), h = new Float32Array(c.transformation.elements), d = [c.center.x, c.center.y, c.center.z];
    let E = false;
    for (let u = 0; u < r.length - 2; u += 3) {
      const p = r[u], A = r[u + 1], m = r[u + 2], C = a[u], R = a[u + 1], F = a[u + 2];
      if (Rr(d, [p, A, m], [C, R, F])) {
        E = true;
        break;
      }
    }
    this._geometries.set(e, {
      position: r,
      normal: a,
      index: o,
      boundingBox: h,
      hasHoles: E
    }), i.delete(), this._geometryCount++;
  }
  async streamAssets() {
    await this.onAssetStreamed.trigger(this._assets), this._assets = null, this._assets = [];
  }
  async streamGeometries() {
    let t = this._streamSerializer.export(this._geometries), e = {};
    for (const [i, { boundingBox: o, hasHoles: n }] of this._geometries)
      e[i] = { boundingBox: o, hasHoles: n };
    this.onGeometryStreamed.trigger({ data: e, buffer: t }), e = null, t = null, this._geometries.clear(), this._geometryCount = 0;
  }
};
I(Ms, "uuid", "d9999a00-e1f5-4d3f-8cfe-c56e08609764");
var Nn = Ms;
var Kr = class extends J {
  constructor() {
    super(...arguments);
    I(this, "onPropertiesStreamed", new $t());
    I(this, "onProgress", new $t());
    I(this, "onIndicesStreamed", new $t());
    I(this, "onDisposed", new D());
    I(this, "enabled", true);
    I(this, "settings", new zn());
    I(this, "webIfc", new IfcAPI2());
  }
  async dispose() {
    this.onIndicesStreamed.reset(), this.onPropertiesStreamed.reset(), this.webIfc = null, this.onDisposed.reset();
  }
  async streamFromBuffer(t) {
    const e = performance.now();
    await this.readIfcFile(t), await this.streamAllProperties(), this.cleanUp(), console.log(`Streaming the IFC took ${performance.now() - e} ms!`);
  }
  async streamFromCallBack(t) {
    const e = performance.now();
    await this.streamIfcFile(t), await this.streamAllProperties(), this.cleanUp(), console.log(`Streaming the IFC took ${performance.now() - e} ms!`);
  }
  async readIfcFile(t) {
    const { path: e, absolute: i, logLevel: o } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, i), await this.webIfc.Init(), o && this.webIfc.SetLogLevel(o), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  async streamIfcFile(t) {
    const { path: e, absolute: i, logLevel: o } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, i), await this.webIfc.Init(), o && this.webIfc.SetLogLevel(o), this.webIfc.OpenModelFromCallback(t, this.settings.webIfc);
  }
  async streamAllProperties() {
    const { propertiesSize: t } = this.settings, e = new Set(this.webIfc.GetIfcEntityList(0)), i = /* @__PURE__ */ new Set([
      IFCPROJECT,
      IFCSITE,
      IFCBUILDING,
      IFCBUILDINGSTOREY,
      IFCSPACE
    ]);
    for (const c of i)
      e.add(c);
    let o = 0.01, n = 0;
    for (const c of e) {
      if (n++, Li.has(c))
        continue;
      const h = i.has(c), d = this.webIfc.GetLineIDsWithType(0, c), E = d.size();
      let u = 0;
      for (let A = 0; A < E - t; A += t) {
        const m = {};
        for (let C = 0; C < t; C++) {
          u++;
          const R = d.get(A + C);
          try {
            const F = this.webIfc.GetLine(0, R, h);
            m[F.expressID] = F;
          } catch {
            console.log(`Could not get property: ${R}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type: c, data: m });
      }
      if (u !== E) {
        const A = {};
        for (let m = u; m < E; m++) {
          const C = d.get(m);
          try {
            const R = this.webIfc.GetLine(0, C, h);
            A[R.expressID] = R;
          } catch {
            console.log(`Could not get property: ${C}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type: c, data: A });
      }
      const p = n / e.size;
      p > o && (o += 0.01, o = Math.max(o, p), await this.onProgress.trigger(Math.round(o * 100) / 100));
    }
    const a = await this.components.get(We).processFromWebIfc(this.webIfc, 0);
    await this.onIndicesStreamed.trigger(a);
  }
  cleanUp() {
    this.webIfc = null, this.webIfc = new IfcAPI2();
  }
};
I(Kr, "uuid", "88d2c89c-ce32-47d7-8cb6-d51e4b311a0b");
var Ds = class Ds2 extends J {
  constructor(t) {
    super(t);
    I(this, "enabled", true);
    t.add(Ds2.uuid, this);
  }
  getFace(t, e, i) {
    if (!t.geometry.index)
      throw new Error("Geometry must be indexed!");
    const o = /* @__PURE__ */ new Map(), n = t.geometry.index.array, { plane: r } = this.getFaceData(
      e,
      i,
      t
    ), a = [];
    for (let E = 0; E < n.length / 3; E++) {
      const { plane: u, edges: p } = this.getFaceData(E, i, t);
      if (u.equals(r)) {
        a.push({ index: E, edges: p });
        for (const { id: A, points: m, distance: C } of p)
          o.set(A, { points: m, distance: C });
      }
    }
    let c = 0;
    const h = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Map();
    for (const { index: E, edges: u } of a) {
      const p = /* @__PURE__ */ new Map();
      for (const { id: T } of u)
        if (h.has(T)) {
          const O = h.get(T);
          p.set(T, O);
        }
      const A = u.map((T) => T.id);
      if (!p.size) {
        const T = c++;
        for (const { id: O } of u)
          h.set(O, T);
        d.set(T, {
          edges: new Set(A),
          indices: /* @__PURE__ */ new Set([E])
        });
        continue;
      }
      let m = null;
      const C = /* @__PURE__ */ new Set(), R = new Set(A);
      for (const [T, O] of p) {
        m === null ? m = O : O !== m && C.add(O), h.delete(T);
        const { edges: S } = d.get(O);
        S.delete(T), R.delete(T);
      }
      if (m === null)
        throw new Error("Error computing face!");
      const F = d.get(m), { indices: f } = F;
      f.add(E);
      for (const T of R) {
        h.set(T, m);
        const { edges: O } = F;
        O.add(T);
      }
      for (const T of C) {
        const O = d.get(T), { edges: S, indices: _ } = O, N = d.get(m), { edges: L, indices: M } = N;
        for (const y of S)
          L.add(y), h.set(y, m);
        for (const y of _)
          M.add(y);
        d.delete(T);
      }
    }
    for (const [E, { indices: u, edges: p }] of d)
      if (u.has(e)) {
        const A = [];
        for (const m of p) {
          const C = o.get(m);
          A.push(C);
        }
        return { edges: A, indices: u };
      }
    return null;
  }
  static distanceFromPointToLine(t, e, i, o = false) {
    const n = new Line3(), r = new Vector3();
    return n.set(e, i), n.closestPointToPoint(t, o, r), r.distanceTo(t);
  }
  getFaceData(t, e, i) {
    const o = this.getVerticesAndNormal(i, t, e), { p1: n, p2: r, p3: a, faceNormal: c } = o;
    this.round(n), this.round(r), this.round(a), this.round(c);
    const h = [
      { id: `${n.x}|${n.y}|${n.z}`, value: n },
      { id: `${r.x}|${r.y}|${r.z}`, value: r },
      { id: `${a.x}|${a.y}|${a.z}`, value: a }
    ];
    h.sort((F, f) => F.id < f.id ? -1 : F.id > f.id ? 1 : 0);
    const [
      { id: d, value: E },
      { id: u, value: p },
      { id: A, value: m }
    ] = h, C = [
      {
        id: `${d}|${u}`,
        distance: E.distanceTo(p),
        points: [E, p]
      },
      {
        id: `${u}|${A}`,
        distance: p.distanceTo(m),
        points: [p, m]
      },
      {
        id: `${d}|${A}`,
        distance: E.distanceTo(m),
        points: [E, m]
      }
    ], R = new Plane();
    return R.setFromNormalAndCoplanarPoint(c, n), R.constant = Math.round(R.constant * 10) / 10, { plane: R, edges: C };
  }
  getVerticesAndNormal(t, e, i) {
    if (!t.geometry.index)
      throw new Error("Geometry must be indexed!");
    const o = t.geometry.index.array, n = t.geometry.attributes.position.array, r = t.geometry.attributes.normal.array, a = o[e * 3] * 3, c = o[e * 3 + 1] * 3, h = o[e * 3 + 2] * 3, d = new Vector3(n[a], n[a + 1], n[a + 2]), E = new Vector3(n[c], n[c + 1], n[c + 2]), u = new Vector3(n[h], n[h + 1], n[h + 2]), p = new Vector3(r[a], r[a + 1], r[a + 2]), A = new Vector3(r[c], r[c + 1], r[c + 2]), m = new Vector3(r[h], r[h + 1], r[h + 2]), C = (p.x + A.x + m.x) / 3, R = (p.y + A.y + m.y) / 3, F = (p.z + A.z + m.z) / 3, f = new Vector3(C, R, F);
    if (i !== void 0 && t instanceof InstancedMesh) {
      const T = new Matrix4();
      t.getMatrixAt(i, T);
      const O = new Matrix4();
      O.extractRotation(T), f.applyMatrix4(O), d.applyMatrix4(T), E.applyMatrix4(T), u.applyMatrix4(T);
    }
    return { p1: d, p2: E, p3: u, faceNormal: f };
  }
  round(t) {
    t.x = Math.trunc(t.x * 1e3) / 1e3, t.y = Math.trunc(t.y * 1e3) / 1e3, t.z = Math.trunc(t.z * 1e3) / 1e3;
  }
};
I(Ds, "uuid", "267ca032-672f-4cb0-afa9-d24e904f39d6");
var Pn = Ds;

export {
  D,
  $t,
  _i,
  J,
  Ni2 as Ni,
  cr,
  lr,
  zt,
  hr,
  mr,
  Rr,
  nn,
  ze,
  sa,
  pi,
  He,
  Or,
  ia,
  na,
  ke,
  Ci,
  un,
  Pi,
  An,
  Yr,
  Vr,
  Gr,
  Ti,
  Fn,
  Hr,
  kr,
  Wr,
  Xr,
  oa,
  On,
  mi,
  ut,
  We,
  Qr,
  ra,
  Bn,
  Kt,
  Ri,
  gn,
  Ai,
  Sn,
  _n,
  qr,
  zn,
  $r,
  Nn,
  Kr,
  Pn
};
/*! Bundled license information:

@thatopen/components/dist/index.mjs:
  (*!
   * camera-controls
   * https://github.com/yomotsu/camera-controls
   * (c) 2017 @yomotsu
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=chunk-SDLHOFY7.js.map
