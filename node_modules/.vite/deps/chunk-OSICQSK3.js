import {
  BackSide,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  Clock,
  Color,
  ColorManagement,
  CylinderGeometry,
  DataTexture,
  DepthFormat,
  DepthTexture,
  DoubleSide,
  DynamicDrawUsage,
  EdgesGeometry,
  Euler,
  FILE_DESCRIPTION,
  FILE_NAME,
  Float32BufferAttribute,
  FloatType,
  FrontSide,
  Gi,
  Group,
  HalfFloatType,
  Handle,
  Hi,
  IFCBUILDING,
  IFCBUILDINGSTOREY,
  IFCELEMENTQUANTITY,
  IFCOPENINGELEMENT,
  IFCOWNERHISTORY,
  IFCPROJECT,
  IFCPROPERTYSET,
  IFCRELAGGREGATES,
  IFCRELASSIGNSTOGROUP,
  IFCRELASSOCIATESCLASSIFICATION,
  IFCRELASSOCIATESMATERIAL,
  IFCRELCONTAINEDINSPATIALSTRUCTURE,
  IFCRELDEFINESBYPROPERTIES,
  IFCRELDEFINESBYTEMPLATE,
  IFCRELDEFINESBYTYPE,
  IFCSITE,
  IFCSPACE,
  IFCUNITASSIGNMENT,
  IfcAPI2,
  InstancedBufferGeometry,
  InstancedInterleavedBuffer,
  InstancedMesh,
  InterleavedBufferAttribute,
  Js,
  Line,
  Line3,
  LineBasicMaterial,
  LineSegments,
  LinearFilter,
  LogLevel,
  MOUSE,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshLambertMaterial,
  NearestFilter,
  Ni,
  NoBlending,
  NoColorSpace,
  NoToneMapping,
  Object3D,
  OctahedronGeometry,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  Points,
  PointsMaterial,
  Quaternion,
  RGBAFormat,
  Ray,
  Raycaster,
  RedFormat,
  RepeatWrapping,
  Scene,
  ShaderLib,
  ShaderMaterial,
  ShapeUtils,
  Sphere,
  SphereGeometry,
  Spherical,
  TorusGeometry,
  Triangle,
  UniformsLib,
  UniformsUtils,
  UnsignedIntType,
  Vector2,
  Vector3,
  Vector4,
  WebGLMultipleRenderTargets,
  WebGLRenderTarget,
  WebGLRenderer,
  WireframeGeometry,
  Xi,
  ji,
  ki,
  web_ifc_api_exports
} from "./chunk-OGNR6M4R.js";

// ../node_modules/@thatopen/components-front/dist/index.js
var su = Object.defineProperty;
var iu = (u, t, e) => t in u ? su(u, t, { enumerable: true, configurable: true, writable: true, value: e }) : u[t] = e;
var T = (u, t, e) => (iu(u, typeof t != "symbol" ? t + "" : t, e), e);
var Au = Object.defineProperty;
var Ru = (u, t, e) => t in u ? Au(u, t, { enumerable: true, configurable: true, writable: true, value: e }) : u[t] = e;
var S = (u, t, e) => (Ru(u, typeof t != "symbol" ? t + "" : t, e), e);
var Dc = 0;
var Fu = 1;
var Pu = 2;
var Il = 2;
var _o = 1.25;
var yl = 1;
var Ir = 6 * 4 + 4 + 4;
var Wr = 65535;
var Mu = Math.pow(2, -24);
var Uo = Symbol("SKIP_GENERATION");
function Ou(u) {
  return u.index ? u.index.count : u.attributes.position.count;
}
function vs(u) {
  return Ou(u) / 3;
}
function Du(u, t = ArrayBuffer) {
  return u > 65535 ? new Uint32Array(new t(4 * u)) : new Uint16Array(new t(2 * u));
}
function Lu(u, t) {
  if (!u.index) {
    const e = u.attributes.position.count, n = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, s = Du(e, n);
    u.setIndex(new BufferAttribute(s, 1));
    for (let i = 0; i < e; i++)
      s[i] = i;
  }
}
function Lc(u) {
  const t = vs(u), e = u.drawRange, n = e.start / 3, s = (e.start + e.count) / 3, i = Math.max(0, n), r = Math.min(t, s) - i;
  return [{
    offset: Math.floor(i),
    count: Math.floor(r)
  }];
}
function Nc(u) {
  if (!u.groups || !u.groups.length)
    return Lc(u);
  const t = [], e = /* @__PURE__ */ new Set(), n = u.drawRange, s = n.start / 3, i = (n.start + n.count) / 3;
  for (const o of u.groups) {
    const l = o.start / 3, h = (o.start + o.count) / 3;
    e.add(Math.max(s, l)), e.add(Math.min(i, h));
  }
  const r = Array.from(e.values()).sort((o, l) => o - l);
  for (let o = 0; o < r.length - 1; o++) {
    const l = r[o], h = r[o + 1];
    t.push({
      offset: Math.floor(l),
      count: Math.floor(h - l)
    });
  }
  return t;
}
function Nu(u) {
  if (u.groups.length === 0)
    return false;
  const t = vs(u), e = Nc(u).sort((i, r) => i.offset - r.offset), n = e[e.length - 1];
  n.count = Math.min(t - n.offset, n.count);
  let s = 0;
  return e.forEach(({ count: i }) => s += i), t !== s;
}
function Ye(u, t, e) {
  return e.min.x = t[u], e.min.y = t[u + 1], e.min.z = t[u + 2], e.max.x = t[u + 3], e.max.y = t[u + 4], e.max.z = t[u + 5], e;
}
function _u(u) {
  u[0] = u[1] = u[2] = 1 / 0, u[3] = u[4] = u[5] = -1 / 0;
}
function wl(u) {
  let t = -1, e = -1 / 0;
  for (let n = 0; n < 3; n++) {
    const s = u[n + 3] - u[n];
    s > e && (e = s, t = n);
  }
  return t;
}
function Cl(u, t) {
  t.set(u);
}
function Tl(u, t, e) {
  let n, s;
  for (let i = 0; i < 3; i++) {
    const r = i + 3;
    n = u[i], s = t[i], e[i] = n < s ? n : s, n = u[r], s = t[r], e[r] = n > s ? n : s;
  }
}
function Vi(u, t, e) {
  for (let n = 0; n < 3; n++) {
    const s = t[u + 2 * n], i = t[u + 2 * n + 1], r = s - i, o = s + i;
    r < e[n] && (e[n] = r), o > e[n + 3] && (e[n + 3] = o);
  }
}
function ks(u) {
  const t = u[3] - u[0], e = u[4] - u[1], n = u[5] - u[2];
  return 2 * (t * e + e * n + n * t);
}
function Bo(u, t, e, n, s = null) {
  let i = 1 / 0, r = 1 / 0, o = 1 / 0, l = -1 / 0, h = -1 / 0, d = -1 / 0, m = 1 / 0, f = 1 / 0, g = 1 / 0, I = -1 / 0, y = -1 / 0, x = -1 / 0;
  const A = s !== null;
  for (let F = t * 6, P = (t + e) * 6; F < P; F += 6) {
    const b = u[F + 0], O = u[F + 1], k = b - O, Y = b + O;
    k < i && (i = k), Y > l && (l = Y), A && b < m && (m = b), A && b > I && (I = b);
    const H = u[F + 2], K = u[F + 3], Z = H - K, q = H + K;
    Z < r && (r = Z), q > h && (h = q), A && H < f && (f = H), A && H > y && (y = H);
    const ne = u[F + 4], se = u[F + 5], ue = ne - se, me = ne + se;
    ue < o && (o = ue), me > d && (d = me), A && ne < g && (g = ne), A && ne > x && (x = ne);
  }
  n[0] = i, n[1] = r, n[2] = o, n[3] = l, n[4] = h, n[5] = d, A && (s[0] = m, s[1] = f, s[2] = g, s[3] = I, s[4] = y, s[5] = x);
}
function Uu(u, t, e, n) {
  let s = 1 / 0, i = 1 / 0, r = 1 / 0, o = -1 / 0, l = -1 / 0, h = -1 / 0;
  for (let d = t * 6, m = (t + e) * 6; d < m; d += 6) {
    const f = u[d + 0];
    f < s && (s = f), f > o && (o = f);
    const g = u[d + 2];
    g < i && (i = g), g > l && (l = g);
    const I = u[d + 4];
    I < r && (r = I), I > h && (h = I);
  }
  n[0] = s, n[1] = i, n[2] = r, n[3] = o, n[4] = l, n[5] = h;
}
function Bu(u, t) {
  _u(t);
  const e = u.attributes.position, n = u.index ? u.index.array : null, s = vs(u), i = new Float32Array(s * 6), r = e.normalized, o = e.array, l = e.offset || 0;
  let h = 3;
  e.isInterleavedBufferAttribute && (h = e.data.stride);
  const d = ["getX", "getY", "getZ"];
  for (let m = 0; m < s; m++) {
    const f = m * 3, g = m * 6;
    let I = f + 0, y = f + 1, x = f + 2;
    n && (I = n[I], y = n[y], x = n[x]), r || (I = I * h + l, y = y * h + l, x = x * h + l);
    for (let A = 0; A < 3; A++) {
      let F, P, b;
      r ? (F = e[d[A]](I), P = e[d[A]](y), b = e[d[A]](x)) : (F = o[I + A], P = o[y + A], b = o[x + A]);
      let O = F;
      P < O && (O = P), b < O && (O = b);
      let k = F;
      P > k && (k = P), b > k && (k = b);
      const Y = (k - O) / 2, H = A * 2;
      i[g + H + 0] = O + Y, i[g + H + 1] = Y + (Math.abs(O) + Y) * Mu, O < t[A] && (t[A] = O), k > t[A + 3] && (t[A + 3] = k);
    }
  }
  return i;
}
var en = 32;
var ku = (u, t) => u.candidate - t.candidate;
var pn = new Array(en).fill().map(() => ({
  count: 0,
  bounds: new Float32Array(6),
  rightCacheBounds: new Float32Array(6),
  leftCacheBounds: new Float32Array(6),
  candidate: 0
}));
var Gi2 = new Float32Array(6);
function zu(u, t, e, n, s, i) {
  let r = -1, o = 0;
  if (i === Dc)
    r = wl(t), r !== -1 && (o = (t[r] + t[r + 3]) / 2);
  else if (i === Fu)
    r = wl(u), r !== -1 && (o = Vu(e, n, s, r));
  else if (i === Pu) {
    const l = ks(u);
    let h = _o * s;
    const d = n * 6, m = (n + s) * 6;
    for (let f = 0; f < 3; f++) {
      const g = t[f], I = (t[f + 3] - g) / en;
      if (s < en / 4) {
        const y = [...pn];
        y.length = s;
        let x = 0;
        for (let F = d; F < m; F += 6, x++) {
          const P = y[x];
          P.candidate = e[F + 2 * f], P.count = 0;
          const {
            bounds: b,
            leftCacheBounds: O,
            rightCacheBounds: k
          } = P;
          for (let Y = 0; Y < 3; Y++)
            k[Y] = 1 / 0, k[Y + 3] = -1 / 0, O[Y] = 1 / 0, O[Y + 3] = -1 / 0, b[Y] = 1 / 0, b[Y + 3] = -1 / 0;
          Vi(F, e, b);
        }
        y.sort(ku);
        let A = s;
        for (let F = 0; F < A; F++) {
          const P = y[F];
          for (; F + 1 < A && y[F + 1].candidate === P.candidate; )
            y.splice(F + 1, 1), A--;
        }
        for (let F = d; F < m; F += 6) {
          const P = e[F + 2 * f];
          for (let b = 0; b < A; b++) {
            const O = y[b];
            P >= O.candidate ? Vi(F, e, O.rightCacheBounds) : (Vi(F, e, O.leftCacheBounds), O.count++);
          }
        }
        for (let F = 0; F < A; F++) {
          const P = y[F], b = P.count, O = s - P.count, k = P.leftCacheBounds, Y = P.rightCacheBounds;
          let H = 0;
          b !== 0 && (H = ks(k) / l);
          let K = 0;
          O !== 0 && (K = ks(Y) / l);
          const Z = yl + _o * (H * b + K * O);
          Z < h && (r = f, h = Z, o = P.candidate);
        }
      } else {
        for (let A = 0; A < en; A++) {
          const F = pn[A];
          F.count = 0, F.candidate = g + I + A * I;
          const P = F.bounds;
          for (let b = 0; b < 3; b++)
            P[b] = 1 / 0, P[b + 3] = -1 / 0;
        }
        for (let A = d; A < m; A += 6) {
          let F = ~~((e[A + 2 * f] - g) / I);
          F >= en && (F = en - 1);
          const P = pn[F];
          P.count++, Vi(A, e, P.bounds);
        }
        const y = pn[en - 1];
        Cl(y.bounds, y.rightCacheBounds);
        for (let A = en - 2; A >= 0; A--) {
          const F = pn[A], P = pn[A + 1];
          Tl(F.bounds, P.rightCacheBounds, F.rightCacheBounds);
        }
        let x = 0;
        for (let A = 0; A < en - 1; A++) {
          const F = pn[A], P = F.count, b = F.bounds, O = pn[A + 1].rightCacheBounds;
          P !== 0 && (x === 0 ? Cl(b, Gi2) : Tl(b, Gi2, Gi2)), x += P;
          let k = 0, Y = 0;
          x !== 0 && (k = ks(Gi2) / l);
          const H = s - x;
          H !== 0 && (Y = ks(O) / l);
          const K = yl + _o * (k * x + Y * H);
          K < h && (r = f, h = K, o = F.candidate);
        }
      }
    }
  } else
    console.warn(`MeshBVH: Invalid build strategy value ${i} used.`);
  return { axis: r, pos: o };
}
function Vu(u, t, e, n) {
  let s = 0;
  for (let i = t, r = t + e; i < r; i++)
    s += u[i * 6 + n * 2];
  return s / e;
}
var Yi = class {
  constructor() {
  }
};
function Gu(u, t, e, n, s, i) {
  let r = n, o = n + s - 1;
  const l = i.pos, h = i.axis * 2;
  for (; ; ) {
    for (; r <= o && e[r * 6 + h] < l; )
      r++;
    for (; r <= o && e[o * 6 + h] >= l; )
      o--;
    if (r < o) {
      for (let d = 0; d < 3; d++) {
        let m = t[r * 3 + d];
        t[r * 3 + d] = t[o * 3 + d], t[o * 3 + d] = m;
      }
      for (let d = 0; d < 6; d++) {
        let m = e[r * 6 + d];
        e[r * 6 + d] = e[o * 6 + d], e[o * 6 + d] = m;
      }
      r++, o--;
    } else
      return r;
  }
}
function Yu(u, t, e, n, s, i) {
  let r = n, o = n + s - 1;
  const l = i.pos, h = i.axis * 2;
  for (; ; ) {
    for (; r <= o && e[r * 6 + h] < l; )
      r++;
    for (; r <= o && e[o * 6 + h] >= l; )
      o--;
    if (r < o) {
      let d = u[r];
      u[r] = u[o], u[o] = d;
      for (let m = 0; m < 6; m++) {
        let f = e[r * 6 + m];
        e[r * 6 + m] = e[o * 6 + m], e[o * 6 + m] = f;
      }
      r++, o--;
    } else
      return r;
  }
}
function Hu(u, t) {
  const e = (u.index ? u.index.count : u.attributes.position.count) / 3, n = e > 2 ** 16, s = n ? 4 : 2, i = t ? new SharedArrayBuffer(e * s) : new ArrayBuffer(e * s), r = n ? new Uint32Array(i) : new Uint16Array(i);
  for (let o = 0, l = r.length; o < l; o++)
    r[o] = o;
  return r;
}
function Wu(u, t) {
  const e = u.geometry, n = e.index ? e.index.array : null, s = t.maxDepth, i = t.verbose, r = t.maxLeafTris, o = t.strategy, l = t.onProgress, h = vs(e), d = u._indirectBuffer;
  let m = false;
  const f = new Float32Array(6), g = new Float32Array(6), I = Bu(e, f), y = t.indirect ? Yu : Gu, x = [], A = t.indirect ? Lc(e) : Nc(e);
  if (A.length === 1) {
    const b = A[0], O = new Yi();
    O.boundingData = f, Uu(I, b.offset, b.count, g), P(O, b.offset, b.count, g), x.push(O);
  } else
    for (let b of A) {
      const O = new Yi();
      O.boundingData = new Float32Array(6), Bo(I, b.offset, b.count, O.boundingData, g), P(O, b.offset, b.count, g), x.push(O);
    }
  return x;
  function F(b) {
    l && l(b / h);
  }
  function P(b, O, k, Y = null, H = 0) {
    if (!m && H >= s && (m = true, i && (console.warn(`MeshBVH: Max depth of ${s} reached when generating BVH. Consider increasing maxDepth.`), console.warn(e))), k <= r || H >= s)
      return F(O + k), b.offset = O, b.count = k, b;
    const K = zu(b.boundingData, Y, I, O, k, o);
    if (K.axis === -1)
      return F(O + k), b.offset = O, b.count = k, b;
    const Z = y(d, n, I, O, k, K);
    if (Z === O || Z === O + k)
      F(O + k), b.offset = O, b.count = k;
    else {
      b.splitAxis = K.axis;
      const q = new Yi(), ne = O, se = Z - O;
      b.left = q, q.boundingData = new Float32Array(6), Bo(I, ne, se, q.boundingData, g), P(q, ne, se, g, H + 1);
      const ue = new Yi(), me = Z, Ie = k - se;
      b.right = ue, ue.boundingData = new Float32Array(6), Bo(I, me, Ie, ue.boundingData, g), P(ue, me, Ie, g, H + 1);
    }
    return b;
  }
}
function Ku(u, t) {
  const e = u.geometry;
  t.indirect && (u._indirectBuffer = Hu(e, t.useSharedArrayBuffer), Nu(e) && !t.verbose && console.warn(
    'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
  )), u._indirectBuffer || Lu(e, t);
  const n = Wu(u, t);
  let s, i, r;
  const o = [], l = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  for (let m = 0; m < n.length; m++) {
    const f = n[m];
    let g = h(f);
    const I = new l(Ir * g);
    s = new Float32Array(I), i = new Uint32Array(I), r = new Uint16Array(I), d(0, f), o.push(I);
  }
  u._roots = o;
  return;
  function h(m) {
    return m.count ? 1 : 1 + h(m.left) + h(m.right);
  }
  function d(m, f) {
    const g = m / 4, I = m / 2, y = !!f.count, x = f.boundingData;
    for (let A = 0; A < 6; A++)
      s[g + A] = x[A];
    if (y) {
      const A = f.offset, F = f.count;
      return i[g + 6] = A, r[I + 14] = F, r[I + 15] = Wr, m + Ir;
    } else {
      const A = f.left, F = f.right, P = f.splitAxis;
      let b;
      if (b = d(m + Ir, A), b / 4 > Math.pow(2, 32))
        throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
      return i[g + 6] = b / 4, b = d(b, F), i[g + 7] = P, b;
    }
  }
}
var sn = class {
  constructor() {
    this.min = 1 / 0, this.max = -1 / 0;
  }
  setFromPointsField(t, e) {
    let n = 1 / 0, s = -1 / 0;
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i][e];
      n = o < n ? o : n, s = o > s ? o : s;
    }
    this.min = n, this.max = s;
  }
  setFromPoints(t, e) {
    let n = 1 / 0, s = -1 / 0;
    for (let i = 0, r = e.length; i < r; i++) {
      const o = e[i], l = t.dot(o);
      n = l < n ? l : n, s = l > s ? l : s;
    }
    this.min = n, this.max = s;
  }
  isSeparated(t) {
    return this.min > t.max || t.min > this.max;
  }
};
sn.prototype.setFromBox = function() {
  const u = new Vector3();
  return function(t, e) {
    const n = e.min, s = e.max;
    let i = 1 / 0, r = -1 / 0;
    for (let o = 0; o <= 1; o++)
      for (let l = 0; l <= 1; l++)
        for (let h = 0; h <= 1; h++) {
          u.x = n.x * o + s.x * (1 - o), u.y = n.y * l + s.y * (1 - l), u.z = n.z * h + s.z * (1 - h);
          const d = t.dot(u);
          i = Math.min(d, i), r = Math.max(d, r);
        }
    this.min = i, this.max = r;
  };
}();
var ju = function() {
  const u = new Vector3(), t = new Vector3(), e = new Vector3();
  return function(n, s, i) {
    const r = n.start, o = u, l = s.start, h = t;
    e.subVectors(r, l), u.subVectors(n.end, n.start), t.subVectors(s.end, s.start);
    const d = e.dot(h), m = h.dot(o), f = h.dot(h), g = e.dot(o), I = o.dot(o) * f - m * m;
    let y, x;
    I !== 0 ? y = (d * m - g * f) / I : y = 0, x = (d + y * m) / f, i.x = y, i.y = x;
  };
}();
var Pa = function() {
  const u = new Vector2(), t = new Vector3(), e = new Vector3();
  return function(n, s, i, r) {
    ju(n, s, u);
    let o = u.x, l = u.y;
    if (o >= 0 && o <= 1 && l >= 0 && l <= 1) {
      n.at(o, i), s.at(l, r);
      return;
    } else if (o >= 0 && o <= 1) {
      l < 0 ? s.at(0, r) : s.at(1, r), n.closestPointToPoint(r, true, i);
      return;
    } else if (l >= 0 && l <= 1) {
      o < 0 ? n.at(0, i) : n.at(1, i), s.closestPointToPoint(i, true, r);
      return;
    } else {
      let h;
      o < 0 ? h = n.start : h = n.end;
      let d;
      l < 0 ? d = s.start : d = s.end;
      const m = t, f = e;
      if (n.closestPointToPoint(d, true, t), s.closestPointToPoint(h, true, e), m.distanceToSquared(d) <= f.distanceToSquared(h)) {
        i.copy(m), r.copy(d);
        return;
      } else {
        i.copy(h), r.copy(f);
        return;
      }
    }
  };
}();
var Xu = function() {
  const u = new Vector3(), t = new Vector3(), e = new Plane(), n = new Line3();
  return function(s, i) {
    const { radius: r, center: o } = s, { a: l, b: h, c: d } = i;
    if (n.start = l, n.end = h, n.closestPointToPoint(o, true, u).distanceTo(o) <= r || (n.start = l, n.end = d, n.closestPointToPoint(o, true, u).distanceTo(o) <= r) || (n.start = h, n.end = d, n.closestPointToPoint(o, true, u).distanceTo(o) <= r))
      return true;
    const m = i.getPlane(e);
    if (Math.abs(m.distanceToPoint(o)) <= r) {
      const f = m.projectPoint(o, t);
      if (i.containsPoint(f))
        return true;
    }
    return false;
  };
}();
var Zu = 1e-15;
function ko(u) {
  return Math.abs(u) < Zu;
}
var Lt = class extends Triangle {
  constructor(...t) {
    super(...t), this.isExtendedTriangle = true, this.satAxes = new Array(4).fill().map(() => new Vector3()), this.satBounds = new Array(4).fill().map(() => new sn()), this.points = [this.a, this.b, this.c], this.sphere = new Sphere(), this.plane = new Plane(), this.needsUpdate = true;
  }
  intersectsSphere(t) {
    return Xu(t, this);
  }
  update() {
    const t = this.a, e = this.b, n = this.c, s = this.points, i = this.satAxes, r = this.satBounds, o = i[0], l = r[0];
    this.getNormal(o), l.setFromPoints(o, s);
    const h = i[1], d = r[1];
    h.subVectors(t, e), d.setFromPoints(h, s);
    const m = i[2], f = r[2];
    m.subVectors(e, n), f.setFromPoints(m, s);
    const g = i[3], I = r[3];
    g.subVectors(n, t), I.setFromPoints(g, s), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(o, t), this.needsUpdate = false;
  }
};
Lt.prototype.closestPointToSegment = function() {
  const u = new Vector3(), t = new Vector3(), e = new Line3();
  return function(n, s = null, i = null) {
    const { start: r, end: o } = n, l = this.points;
    let h, d = 1 / 0;
    for (let m = 0; m < 3; m++) {
      const f = (m + 1) % 3;
      e.start.copy(l[m]), e.end.copy(l[f]), Pa(e, n, u, t), h = u.distanceToSquared(t), h < d && (d = h, s && s.copy(u), i && i.copy(t));
    }
    return this.closestPointToPoint(r, u), h = r.distanceToSquared(u), h < d && (d = h, s && s.copy(u), i && i.copy(r)), this.closestPointToPoint(o, u), h = o.distanceToSquared(u), h < d && (d = h, s && s.copy(u), i && i.copy(o)), Math.sqrt(d);
  };
}();
Lt.prototype.intersectsTriangle = function() {
  const u = new Lt(), t = new Array(3), e = new Array(3), n = new sn(), s = new sn(), i = new Vector3(), r = new Vector3(), o = new Vector3(), l = new Vector3(), h = new Vector3(), d = new Line3(), m = new Line3(), f = new Line3(), g = new Vector3();
  function I(y, x, A) {
    const F = y.points;
    let P = 0, b = -1;
    for (let O = 0; O < 3; O++) {
      const { start: k, end: Y } = d;
      k.copy(F[O]), Y.copy(F[(O + 1) % 3]), d.delta(r);
      const H = ko(x.distanceToPoint(k));
      if (ko(x.normal.dot(r)) && H) {
        A.copy(d), P = 2;
        break;
      }
      const K = x.intersectLine(d, g);
      if (!K && H && g.copy(k), (K || H) && !ko(g.distanceTo(Y))) {
        if (P <= 1)
          (P === 1 ? A.start : A.end).copy(g), H && (b = P);
        else if (P >= 2) {
          (b === 1 ? A.start : A.end).copy(g), P = 2;
          break;
        }
        if (P++, P === 2 && b === -1)
          break;
      }
    }
    return P;
  }
  return function(y, x = null, A = false) {
    this.needsUpdate && this.update(), y.isExtendedTriangle ? y.needsUpdate && y.update() : (u.copy(y), u.update(), y = u);
    const F = this.plane, P = y.plane;
    if (Math.abs(F.normal.dot(P.normal)) > 1 - 1e-10) {
      const b = this.satBounds, O = this.satAxes;
      e[0] = y.a, e[1] = y.b, e[2] = y.c;
      for (let H = 0; H < 4; H++) {
        const K = b[H], Z = O[H];
        if (n.setFromPoints(Z, e), K.isSeparated(n))
          return false;
      }
      const k = y.satBounds, Y = y.satAxes;
      t[0] = this.a, t[1] = this.b, t[2] = this.c;
      for (let H = 0; H < 4; H++) {
        const K = k[H], Z = Y[H];
        if (n.setFromPoints(Z, t), K.isSeparated(n))
          return false;
      }
      for (let H = 0; H < 4; H++) {
        const K = O[H];
        for (let Z = 0; Z < 4; Z++) {
          const q = Y[Z];
          if (i.crossVectors(K, q), n.setFromPoints(i, t), s.setFromPoints(i, e), n.isSeparated(s))
            return false;
        }
      }
      return x && (A || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), x.start.set(0, 0, 0), x.end.set(0, 0, 0)), true;
    } else {
      const b = I(this, P, m);
      if (b === 1 && y.containsPoint(m.end))
        return x && (x.start.copy(m.end), x.end.copy(m.end)), true;
      if (b !== 2)
        return false;
      const O = I(y, F, f);
      if (O === 1 && this.containsPoint(f.end))
        return x && (x.start.copy(f.end), x.end.copy(f.end)), true;
      if (O !== 2)
        return false;
      if (m.delta(o), f.delta(l), o.dot(l) < 0) {
        let ne = f.start;
        f.start = f.end, f.end = ne;
      }
      const k = m.start.dot(o), Y = m.end.dot(o), H = f.start.dot(o), K = f.end.dot(o), Z = Y < H, q = k < K;
      return k !== K && H !== Y && Z === q ? false : (x && (h.subVectors(m.start, f.start), h.dot(o) > 0 ? x.start.copy(m.start) : x.start.copy(f.start), h.subVectors(m.end, f.end), h.dot(o) < 0 ? x.end.copy(m.end) : x.end.copy(f.end)), true);
    }
  };
}();
Lt.prototype.distanceToPoint = function() {
  const u = new Vector3();
  return function(t) {
    return this.closestPointToPoint(t, u), t.distanceTo(u);
  };
}();
Lt.prototype.distanceToTriangle = function() {
  const u = new Vector3(), t = new Vector3(), e = ["a", "b", "c"], n = new Line3(), s = new Line3();
  return function(i, r = null, o = null) {
    const l = r || o ? n : null;
    if (this.intersectsTriangle(i, l))
      return (r || o) && (r && l.getCenter(r), o && l.getCenter(o)), 0;
    let h = 1 / 0;
    for (let d = 0; d < 3; d++) {
      let m;
      const f = e[d], g = i[f];
      this.closestPointToPoint(g, u), m = g.distanceToSquared(u), m < h && (h = m, r && r.copy(u), o && o.copy(g));
      const I = this[f];
      i.closestPointToPoint(I, u), m = I.distanceToSquared(u), m < h && (h = m, r && r.copy(I), o && o.copy(u));
    }
    for (let d = 0; d < 3; d++) {
      const m = e[d], f = e[(d + 1) % 3];
      n.set(this[m], this[f]);
      for (let g = 0; g < 3; g++) {
        const I = e[g], y = e[(g + 1) % 3];
        s.set(i[I], i[y]), Pa(n, s, u, t);
        const x = u.distanceToSquared(t);
        x < h && (h = x, r && r.copy(u), o && o.copy(t));
      }
    }
    return Math.sqrt(h);
  };
}();
var ht = class {
  constructor(t, e, n) {
    this.isOrientedBox = true, this.min = new Vector3(), this.max = new Vector3(), this.matrix = new Matrix4(), this.invMatrix = new Matrix4(), this.points = new Array(8).fill().map(() => new Vector3()), this.satAxes = new Array(3).fill().map(() => new Vector3()), this.satBounds = new Array(3).fill().map(() => new sn()), this.alignedSatBounds = new Array(3).fill().map(() => new sn()), this.needsUpdate = false, t && this.min.copy(t), e && this.max.copy(e), n && this.matrix.copy(n);
  }
  set(t, e, n) {
    this.min.copy(t), this.max.copy(e), this.matrix.copy(n), this.needsUpdate = true;
  }
  copy(t) {
    this.min.copy(t.min), this.max.copy(t.max), this.matrix.copy(t.matrix), this.needsUpdate = true;
  }
};
ht.prototype.update = /* @__PURE__ */ function() {
  return function() {
    const u = this.matrix, t = this.min, e = this.max, n = this.points;
    for (let l = 0; l <= 1; l++)
      for (let h = 0; h <= 1; h++)
        for (let d = 0; d <= 1; d++) {
          const m = 1 * l | 2 * h | 4 * d, f = n[m];
          f.x = l ? e.x : t.x, f.y = h ? e.y : t.y, f.z = d ? e.z : t.z, f.applyMatrix4(u);
        }
    const s = this.satBounds, i = this.satAxes, r = n[0];
    for (let l = 0; l < 3; l++) {
      const h = i[l], d = s[l], m = 1 << l, f = n[m];
      h.subVectors(r, f), d.setFromPoints(h, n);
    }
    const o = this.alignedSatBounds;
    o[0].setFromPointsField(n, "x"), o[1].setFromPointsField(n, "y"), o[2].setFromPointsField(n, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = false;
  };
}();
ht.prototype.intersectsBox = function() {
  const u = new sn();
  return function(t) {
    this.needsUpdate && this.update();
    const e = t.min, n = t.max, s = this.satBounds, i = this.satAxes, r = this.alignedSatBounds;
    if (u.min = e.x, u.max = n.x, r[0].isSeparated(u) || (u.min = e.y, u.max = n.y, r[1].isSeparated(u)) || (u.min = e.z, u.max = n.z, r[2].isSeparated(u)))
      return false;
    for (let o = 0; o < 3; o++) {
      const l = i[o], h = s[o];
      if (u.setFromBox(l, t), h.isSeparated(u))
        return false;
    }
    return true;
  };
}();
ht.prototype.intersectsTriangle = function() {
  const u = new Lt(), t = new Array(3), e = new sn(), n = new sn(), s = new Vector3();
  return function(i) {
    this.needsUpdate && this.update(), i.isExtendedTriangle ? i.needsUpdate && i.update() : (u.copy(i), u.update(), i = u);
    const r = this.satBounds, o = this.satAxes;
    t[0] = i.a, t[1] = i.b, t[2] = i.c;
    for (let m = 0; m < 3; m++) {
      const f = r[m], g = o[m];
      if (e.setFromPoints(g, t), f.isSeparated(e))
        return false;
    }
    const l = i.satBounds, h = i.satAxes, d = this.points;
    for (let m = 0; m < 3; m++) {
      const f = l[m], g = h[m];
      if (e.setFromPoints(g, d), f.isSeparated(e))
        return false;
    }
    for (let m = 0; m < 3; m++) {
      const f = o[m];
      for (let g = 0; g < 4; g++) {
        const I = h[g];
        if (s.crossVectors(f, I), e.setFromPoints(s, t), n.setFromPoints(s, d), e.isSeparated(n))
          return false;
      }
    }
    return true;
  };
}();
ht.prototype.closestPointToPoint = /* @__PURE__ */ function() {
  return function(u, t) {
    return this.needsUpdate && this.update(), t.copy(u).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), t;
  };
}();
ht.prototype.distanceToPoint = function() {
  const u = new Vector3();
  return function(t) {
    return this.closestPointToPoint(t, u), t.distanceTo(u);
  };
}();
ht.prototype.distanceToBox = function() {
  const u = ["x", "y", "z"], t = new Array(12).fill().map(() => new Line3()), e = new Array(12).fill().map(() => new Line3()), n = new Vector3(), s = new Vector3();
  return function(i, r = 0, o = null, l = null) {
    if (this.needsUpdate && this.update(), this.intersectsBox(i))
      return (o || l) && (i.getCenter(s), this.closestPointToPoint(s, n), i.closestPointToPoint(n, s), o && o.copy(n), l && l.copy(s)), 0;
    const h = r * r, d = i.min, m = i.max, f = this.points;
    let g = 1 / 0;
    for (let y = 0; y < 8; y++) {
      const x = f[y];
      s.copy(x).clamp(d, m);
      const A = x.distanceToSquared(s);
      if (A < g && (g = A, o && o.copy(x), l && l.copy(s), A < h))
        return Math.sqrt(A);
    }
    let I = 0;
    for (let y = 0; y < 3; y++)
      for (let x = 0; x <= 1; x++)
        for (let A = 0; A <= 1; A++) {
          const F = (y + 1) % 3, P = (y + 2) % 3, b = x << F | A << P, O = 1 << y | x << F | A << P, k = f[b], Y = f[O];
          t[I].set(k, Y);
          const H = u[y], K = u[F], Z = u[P], q = e[I], ne = q.start, se = q.end;
          ne[H] = d[H], ne[K] = x ? d[K] : m[K], ne[Z] = A ? d[Z] : m[K], se[H] = m[H], se[K] = x ? d[K] : m[K], se[Z] = A ? d[Z] : m[K], I++;
        }
    for (let y = 0; y <= 1; y++)
      for (let x = 0; x <= 1; x++)
        for (let A = 0; A <= 1; A++) {
          s.x = y ? m.x : d.x, s.y = x ? m.y : d.y, s.z = A ? m.z : d.z, this.closestPointToPoint(s, n);
          const F = s.distanceToSquared(n);
          if (F < g && (g = F, o && o.copy(n), l && l.copy(s), F < h))
            return Math.sqrt(F);
        }
    for (let y = 0; y < 12; y++) {
      const x = t[y];
      for (let A = 0; A < 12; A++) {
        const F = e[A];
        Pa(x, F, n, s);
        const P = n.distanceToSquared(s);
        if (P < g && (g = P, o && o.copy(n), l && l.copy(s), P < h))
          return Math.sqrt(P);
      }
    }
    return Math.sqrt(g);
  };
}();
var Ma = class {
  constructor(t) {
    this._getNewPrimitive = t, this._primitives = [];
  }
  getPrimitive() {
    const t = this._primitives;
    return t.length === 0 ? this._getNewPrimitive() : t.pop();
  }
  releasePrimitive(t) {
    this._primitives.push(t);
  }
};
var Qu = class extends Ma {
  constructor() {
    super(() => new Lt());
  }
};
var wt = new Qu();
function gt(u, t) {
  return t[u + 15] === 65535;
}
function Et(u, t) {
  return t[u + 6];
}
function Ct(u, t) {
  return t[u + 14];
}
function Tt(u) {
  return u + 8;
}
function bt(u, t) {
  return t[u + 6];
}
function _c(u, t) {
  return t[u + 7];
}
var qu = class {
  constructor() {
    this.float32Array = null, this.uint16Array = null, this.uint32Array = null;
    const t = [];
    let e = null;
    this.setBuffer = (n) => {
      e && t.push(e), e = n, this.float32Array = new Float32Array(n), this.uint16Array = new Uint16Array(n), this.uint32Array = new Uint32Array(n);
    }, this.clearBuffer = () => {
      e = null, this.float32Array = null, this.uint16Array = null, this.uint32Array = null, t.length !== 0 && this.setBuffer(t.pop());
    };
  }
};
var ke = new qu();
var In;
var fs;
var Zn = [];
var Hi2 = new Ma(() => new Box3());
function Ju(u, t, e, n, s, i) {
  In = Hi2.getPrimitive(), fs = Hi2.getPrimitive(), Zn.push(In, fs), ke.setBuffer(u._roots[t]);
  const r = aa(0, u.geometry, e, n, s, i);
  ke.clearBuffer(), Hi2.releasePrimitive(In), Hi2.releasePrimitive(fs), Zn.pop(), Zn.pop();
  const o = Zn.length;
  return o > 0 && (fs = Zn[o - 1], In = Zn[o - 2]), r;
}
function aa(u, t, e, n, s = null, i = 0, r = 0) {
  const { float32Array: o, uint16Array: l, uint32Array: h } = ke;
  let d = u * 2;
  if (gt(d, l)) {
    const m = Et(u, h), f = Ct(d, l);
    return Ye(u, o, In), n(m, f, false, r, i + u, In);
  } else {
    let m = function(q) {
      const { uint16Array: ne, uint32Array: se } = ke;
      let ue = q * 2;
      for (; !gt(ue, ne); )
        q = Tt(q), ue = q * 2;
      return Et(q, se);
    }, f = function(q) {
      const { uint16Array: ne, uint32Array: se } = ke;
      let ue = q * 2;
      for (; !gt(ue, ne); )
        q = bt(q, se), ue = q * 2;
      return Et(q, se) + Ct(ue, ne);
    };
    const g = Tt(u), I = bt(u, h);
    let y = g, x = I, A, F, P, b;
    if (s && (P = In, b = fs, Ye(y, o, P), Ye(x, o, b), A = s(P), F = s(b), F < A)) {
      y = I, x = g;
      const q = A;
      A = F, F = q, P = b;
    }
    P || (P = In, Ye(y, o, P));
    const O = gt(y * 2, l), k = e(P, O, A, r + 1, i + y);
    let Y;
    if (k === Il) {
      const q = m(y), ne = f(y) - q;
      Y = n(q, ne, true, r + 1, i + y, P);
    } else
      Y = k && aa(
        y,
        t,
        e,
        n,
        s,
        i,
        r + 1
      );
    if (Y)
      return true;
    b = fs, Ye(x, o, b);
    const H = gt(x * 2, l), K = e(b, H, F, r + 1, i + x);
    let Z;
    if (K === Il) {
      const q = m(x), ne = f(x) - q;
      Z = n(q, ne, true, r + 1, i + x, b);
    } else
      Z = K && aa(
        x,
        t,
        e,
        n,
        s,
        i,
        r + 1
      );
    return !!Z;
  }
}
var zs = new Vector3();
var zo = new Vector3();
function $u(u, t, e = {}, n = 0, s = 1 / 0) {
  const i = n * n, r = s * s;
  let o = 1 / 0, l = null;
  if (u.shapecast(
    {
      boundsTraverseOrder: (d) => (zs.copy(t).clamp(d.min, d.max), zs.distanceToSquared(t)),
      intersectsBounds: (d, m, f) => f < o && f < r,
      intersectsTriangle: (d, m) => {
        d.closestPointToPoint(t, zs);
        const f = t.distanceToSquared(zs);
        return f < o && (zo.copy(zs), o = f, l = m), f < i;
      }
    }
  ), o === 1 / 0)
    return null;
  const h = Math.sqrt(o);
  return e.point ? e.point.copy(zo) : e.point = zo.clone(), e.distance = h, e.faceIndex = l, e;
}
var Qn = new Vector3();
var qn = new Vector3();
var Jn = new Vector3();
var Wi = new Vector2();
var Ki = new Vector2();
var ji2 = new Vector2();
var bl = new Vector3();
var xl = new Vector3();
var Sl = new Vector3();
var Xi2 = new Vector3();
function ed(u, t, e, n, s, i) {
  let r;
  return i === BackSide ? r = u.intersectTriangle(n, e, t, true, s) : r = u.intersectTriangle(t, e, n, i !== DoubleSide, s), r === null ? null : {
    distance: u.origin.distanceTo(s),
    point: s.clone()
  };
}
function td(u, t, e, n, s, i, r, o, l) {
  Qn.fromBufferAttribute(t, i), qn.fromBufferAttribute(t, r), Jn.fromBufferAttribute(t, o);
  const h = ed(u, Qn, qn, Jn, Xi2, l);
  if (h) {
    n && (Wi.fromBufferAttribute(n, i), Ki.fromBufferAttribute(n, r), ji2.fromBufferAttribute(n, o), h.uv = Triangle.getInterpolation(Xi2, Qn, qn, Jn, Wi, Ki, ji2, new Vector2())), s && (Wi.fromBufferAttribute(s, i), Ki.fromBufferAttribute(s, r), ji2.fromBufferAttribute(s, o), h.uv1 = Triangle.getInterpolation(Xi2, Qn, qn, Jn, Wi, Ki, ji2, new Vector2())), e && (bl.fromBufferAttribute(e, i), xl.fromBufferAttribute(e, r), Sl.fromBufferAttribute(e, o), h.normal = Triangle.getInterpolation(Xi2, Qn, qn, Jn, bl, xl, Sl, new Vector3()), h.normal.dot(u.direction) > 0 && h.normal.multiplyScalar(-1));
    const d = {
      a: i,
      b: r,
      c: o,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(Qn, qn, Jn, d.normal), h.face = d, h.faceIndex = i;
  }
  return h;
}
function Kr(u, t, e, n, s) {
  const i = n * 3;
  let r = i + 0, o = i + 1, l = i + 2;
  const h = u.index;
  u.index && (r = h.getX(r), o = h.getX(o), l = h.getX(l));
  const { position: d, normal: m, uv: f, uv1: g } = u.attributes, I = td(e, d, m, f, g, r, o, l, t);
  return I ? (I.faceIndex = n, s && s.push(I), I) : null;
}
function Qe(u, t, e, n) {
  const s = u.a, i = u.b, r = u.c;
  let o = t, l = t + 1, h = t + 2;
  e && (o = e.getX(o), l = e.getX(l), h = e.getX(h)), s.x = n.getX(o), s.y = n.getY(o), s.z = n.getZ(o), i.x = n.getX(l), i.y = n.getY(l), i.z = n.getZ(l), r.x = n.getX(h), r.y = n.getY(h), r.z = n.getZ(h);
}
function nd(u, t, e, n, s, i) {
  const { geometry: r, _indirectBuffer: o } = u;
  for (let l = n, h = n + s; l < h; l++)
    Kr(r, t, e, l, i);
}
function sd(u, t, e, n, s) {
  const { geometry: i, _indirectBuffer: r } = u;
  let o = 1 / 0, l = null;
  for (let h = n, d = n + s; h < d; h++) {
    let m;
    m = Kr(i, t, e, h), m && m.distance < o && (l = m, o = m.distance);
  }
  return l;
}
function id(u, t, e, n, s, i, r) {
  const { geometry: o } = e, { index: l } = o, h = o.attributes.position;
  for (let d = u, m = t + u; d < m; d++) {
    let f;
    if (f = d, Qe(r, f * 3, l, h), r.needsUpdate = true, n(r, f, s, i))
      return true;
  }
  return false;
}
function rd(u, t = null) {
  t && Array.isArray(t) && (t = new Set(t));
  const e = u.geometry, n = e.index ? e.index.array : null, s = e.attributes.position;
  let i, r, o, l, h = 0;
  const d = u._roots;
  for (let f = 0, g = d.length; f < g; f++)
    i = d[f], r = new Uint32Array(i), o = new Uint16Array(i), l = new Float32Array(i), m(0, h), h += i.byteLength;
  function m(f, g, I = false) {
    const y = f * 2;
    if (o[y + 15] === Wr) {
      const x = r[f + 6], A = o[y + 14];
      let F = 1 / 0, P = 1 / 0, b = 1 / 0, O = -1 / 0, k = -1 / 0, Y = -1 / 0;
      for (let H = 3 * x, K = 3 * (x + A); H < K; H++) {
        let Z = n[H];
        const q = s.getX(Z), ne = s.getY(Z), se = s.getZ(Z);
        q < F && (F = q), q > O && (O = q), ne < P && (P = ne), ne > k && (k = ne), se < b && (b = se), se > Y && (Y = se);
      }
      return l[f + 0] !== F || l[f + 1] !== P || l[f + 2] !== b || l[f + 3] !== O || l[f + 4] !== k || l[f + 5] !== Y ? (l[f + 0] = F, l[f + 1] = P, l[f + 2] = b, l[f + 3] = O, l[f + 4] = k, l[f + 5] = Y, true) : false;
    } else {
      const x = f + 8, A = r[f + 6], F = x + g, P = A + g;
      let b = I, O = false, k = false;
      t ? b || (O = t.has(F), k = t.has(P), b = !O && !k) : (O = true, k = true);
      const Y = b || O, H = b || k;
      let K = false;
      Y && (K = m(x, g, b));
      let Z = false;
      H && (Z = m(A, g, b));
      const q = K || Z;
      if (q)
        for (let ne = 0; ne < 3; ne++) {
          const se = x + ne, ue = A + ne, me = l[se], Ie = l[se + 3], Ee = l[ue], de = l[ue + 3];
          l[f + ne] = me < Ee ? me : Ee, l[f + ne + 3] = Ie > de ? Ie : de;
        }
      return q;
    }
  }
}
var Al = new Box3();
function Cn(u, t, e, n) {
  return Ye(u, t, Al), e.intersectBox(Al, n);
}
function od(u, t, e, n, s, i) {
  const { geometry: r, _indirectBuffer: o } = u;
  for (let l = n, h = n + s; l < h; l++) {
    let d = o ? o[l] : l;
    Kr(r, t, e, d, i);
  }
}
function ad(u, t, e, n, s) {
  const { geometry: i, _indirectBuffer: r } = u;
  let o = 1 / 0, l = null;
  for (let h = n, d = n + s; h < d; h++) {
    let m;
    m = Kr(i, t, e, r ? r[h] : h), m && m.distance < o && (l = m, o = m.distance);
  }
  return l;
}
function ld(u, t, e, n, s, i, r) {
  const { geometry: o } = e, { index: l } = o, h = o.attributes.position;
  for (let d = u, m = t + u; d < m; d++) {
    let f;
    if (f = e.resolveTriangleIndex(d), Qe(r, f * 3, l, h), r.needsUpdate = true, n(r, f, s, i))
      return true;
  }
  return false;
}
var Rl = new Vector3();
function cd(u, t, e, n, s) {
  ke.setBuffer(u._roots[t]), la(0, u, e, n, s), ke.clearBuffer();
}
function la(u, t, e, n, s) {
  const { float32Array: i, uint16Array: r, uint32Array: o } = ke, l = u * 2;
  if (gt(l, r)) {
    const h = Et(u, o), d = Ct(l, r);
    nd(t, e, n, h, d, s);
  } else {
    const h = Tt(u);
    Cn(h, i, n, Rl) && la(h, t, e, n, s);
    const d = bt(u, o);
    Cn(d, i, n, Rl) && la(d, t, e, n, s);
  }
}
var Fl = new Vector3();
var hd = ["x", "y", "z"];
function ud(u, t, e, n) {
  ke.setBuffer(u._roots[t]);
  const s = ca(0, u, e, n);
  return ke.clearBuffer(), s;
}
function ca(u, t, e, n) {
  const { float32Array: s, uint16Array: i, uint32Array: r } = ke;
  let o = u * 2;
  if (gt(o, i)) {
    const l = Et(u, r), h = Ct(o, i);
    return sd(t, e, n, l, h);
  } else {
    const l = _c(u, r), h = hd[l], d = n.direction[h] >= 0;
    let m, f;
    d ? (m = Tt(u), f = bt(u, r)) : (m = bt(u, r), f = Tt(u));
    const g = Cn(m, s, n, Fl) ? ca(m, t, e, n) : null;
    if (g) {
      const y = g.point[h];
      if (d ? y <= s[f + l] : (
        // min bounding data
        y >= s[f + l + 3]
      ))
        return g;
    }
    const I = Cn(f, s, n, Fl) ? ca(f, t, e, n) : null;
    return g && I ? g.distance <= I.distance ? g : I : g || I || null;
  }
}
var Zi = new Box3();
var $n = new Lt();
var es = new Lt();
var Vs = new Matrix4();
var Pl = new ht();
var Qi = new ht();
function dd(u, t, e, n) {
  ke.setBuffer(u._roots[t]);
  const s = ha(0, u, e, n);
  return ke.clearBuffer(), s;
}
function ha(u, t, e, n, s = null) {
  const { float32Array: i, uint16Array: r, uint32Array: o } = ke;
  let l = u * 2;
  if (s === null && (e.boundingBox || e.computeBoundingBox(), Pl.set(e.boundingBox.min, e.boundingBox.max, n), s = Pl), gt(l, r)) {
    const h = t.geometry, d = h.index, m = h.attributes.position, f = e.index, g = e.attributes.position, I = Et(u, o), y = Ct(l, r);
    if (Vs.copy(n).invert(), e.boundsTree)
      return Ye(u, i, Qi), Qi.matrix.copy(Vs), Qi.needsUpdate = true, e.boundsTree.shapecast({
        intersectsBounds: (x) => Qi.intersectsBox(x),
        intersectsTriangle: (x) => {
          x.a.applyMatrix4(n), x.b.applyMatrix4(n), x.c.applyMatrix4(n), x.needsUpdate = true;
          for (let A = I * 3, F = (y + I) * 3; A < F; A += 3)
            if (Qe(es, A, d, m), es.needsUpdate = true, x.intersectsTriangle(es))
              return true;
          return false;
        }
      });
    for (let x = I * 3, A = (y + I) * 3; x < A; x += 3) {
      Qe($n, x, d, m), $n.a.applyMatrix4(Vs), $n.b.applyMatrix4(Vs), $n.c.applyMatrix4(Vs), $n.needsUpdate = true;
      for (let F = 0, P = f.count; F < P; F += 3)
        if (Qe(es, F, f, g), es.needsUpdate = true, $n.intersectsTriangle(es))
          return true;
    }
  } else {
    const h = u + 8, d = o[u + 6];
    return Ye(h, i, Zi), !!(s.intersectsBox(Zi) && ha(h, t, e, n, s) || (Ye(d, i, Zi), s.intersectsBox(Zi) && ha(d, t, e, n, s)));
  }
}
var qi = new Matrix4();
var Vo = new ht();
var Gs = new ht();
var fd = new Vector3();
var pd = new Vector3();
var md = new Vector3();
var gd = new Vector3();
function Ed(u, t, e, n = {}, s = {}, i = 0, r = 1 / 0) {
  t.boundingBox || t.computeBoundingBox(), Vo.set(t.boundingBox.min, t.boundingBox.max, e), Vo.needsUpdate = true;
  const o = u.geometry, l = o.attributes.position, h = o.index, d = t.attributes.position, m = t.index, f = wt.getPrimitive(), g = wt.getPrimitive();
  let I = fd, y = pd, x = null, A = null;
  s && (x = md, A = gd);
  let F = 1 / 0, P = null, b = null;
  return qi.copy(e).invert(), Gs.matrix.copy(qi), u.shapecast(
    {
      boundsTraverseOrder: (O) => Vo.distanceToBox(O),
      intersectsBounds: (O, k, Y) => Y < F && Y < r ? (k && (Gs.min.copy(O.min), Gs.max.copy(O.max), Gs.needsUpdate = true), true) : false,
      intersectsRange: (O, k) => {
        if (t.boundsTree)
          return t.boundsTree.shapecast({
            boundsTraverseOrder: (Y) => Gs.distanceToBox(Y),
            intersectsBounds: (Y, H, K) => K < F && K < r,
            intersectsRange: (Y, H) => {
              for (let K = Y, Z = Y + H; K < Z; K++) {
                Qe(g, 3 * K, m, d), g.a.applyMatrix4(e), g.b.applyMatrix4(e), g.c.applyMatrix4(e), g.needsUpdate = true;
                for (let q = O, ne = O + k; q < ne; q++) {
                  Qe(f, 3 * q, h, l), f.needsUpdate = true;
                  const se = f.distanceToTriangle(g, I, x);
                  if (se < F && (y.copy(I), A && A.copy(x), F = se, P = q, b = K), se < i)
                    return true;
                }
              }
            }
          });
        {
          const Y = vs(t);
          for (let H = 0, K = Y; H < K; H++) {
            Qe(g, 3 * H, m, d), g.a.applyMatrix4(e), g.b.applyMatrix4(e), g.c.applyMatrix4(e), g.needsUpdate = true;
            for (let Z = O, q = O + k; Z < q; Z++) {
              Qe(f, 3 * Z, h, l), f.needsUpdate = true;
              const ne = f.distanceToTriangle(g, I, x);
              if (ne < F && (y.copy(I), A && A.copy(x), F = ne, P = Z, b = H), ne < i)
                return true;
            }
          }
        }
      }
    }
  ), wt.releasePrimitive(f), wt.releasePrimitive(g), F === 1 / 0 ? null : (n.point ? n.point.copy(y) : n.point = y.clone(), n.distance = F, n.faceIndex = P, s && (s.point ? s.point.copy(A) : s.point = A.clone(), s.point.applyMatrix4(qi), y.applyMatrix4(qi), s.distance = y.sub(s.point).length(), s.faceIndex = b), n);
}
function vd(u, t = null) {
  t && Array.isArray(t) && (t = new Set(t));
  const e = u.geometry, n = e.index ? e.index.array : null, s = e.attributes.position;
  let i, r, o, l, h = 0;
  const d = u._roots;
  for (let f = 0, g = d.length; f < g; f++)
    i = d[f], r = new Uint32Array(i), o = new Uint16Array(i), l = new Float32Array(i), m(0, h), h += i.byteLength;
  function m(f, g, I = false) {
    const y = f * 2;
    if (o[y + 15] === Wr) {
      const x = r[f + 6], A = o[y + 14];
      let F = 1 / 0, P = 1 / 0, b = 1 / 0, O = -1 / 0, k = -1 / 0, Y = -1 / 0;
      for (let H = x, K = x + A; H < K; H++) {
        const Z = 3 * u.resolveTriangleIndex(H);
        for (let q = 0; q < 3; q++) {
          let ne = Z + q;
          ne = n ? n[ne] : ne;
          const se = s.getX(ne), ue = s.getY(ne), me = s.getZ(ne);
          se < F && (F = se), se > O && (O = se), ue < P && (P = ue), ue > k && (k = ue), me < b && (b = me), me > Y && (Y = me);
        }
      }
      return l[f + 0] !== F || l[f + 1] !== P || l[f + 2] !== b || l[f + 3] !== O || l[f + 4] !== k || l[f + 5] !== Y ? (l[f + 0] = F, l[f + 1] = P, l[f + 2] = b, l[f + 3] = O, l[f + 4] = k, l[f + 5] = Y, true) : false;
    } else {
      const x = f + 8, A = r[f + 6], F = x + g, P = A + g;
      let b = I, O = false, k = false;
      t ? b || (O = t.has(F), k = t.has(P), b = !O && !k) : (O = true, k = true);
      const Y = b || O, H = b || k;
      let K = false;
      Y && (K = m(x, g, b));
      let Z = false;
      H && (Z = m(A, g, b));
      const q = K || Z;
      if (q)
        for (let ne = 0; ne < 3; ne++) {
          const se = x + ne, ue = A + ne, me = l[se], Ie = l[se + 3], Ee = l[ue], de = l[ue + 3];
          l[f + ne] = me < Ee ? me : Ee, l[f + ne + 3] = Ie > de ? Ie : de;
        }
      return q;
    }
  }
}
var Ml = new Vector3();
function Id(u, t, e, n, s) {
  ke.setBuffer(u._roots[t]), ua(0, u, e, n, s), ke.clearBuffer();
}
function ua(u, t, e, n, s) {
  const { float32Array: i, uint16Array: r, uint32Array: o } = ke, l = u * 2;
  if (gt(l, r)) {
    const h = Et(u, o), d = Ct(l, r);
    od(t, e, n, h, d, s);
  } else {
    const h = Tt(u);
    Cn(h, i, n, Ml) && ua(h, t, e, n, s);
    const d = bt(u, o);
    Cn(d, i, n, Ml) && ua(d, t, e, n, s);
  }
}
var Ol = new Vector3();
var yd = ["x", "y", "z"];
function wd(u, t, e, n) {
  ke.setBuffer(u._roots[t]);
  const s = da(0, u, e, n);
  return ke.clearBuffer(), s;
}
function da(u, t, e, n) {
  const { float32Array: s, uint16Array: i, uint32Array: r } = ke;
  let o = u * 2;
  if (gt(o, i)) {
    const l = Et(u, r), h = Ct(o, i);
    return ad(t, e, n, l, h);
  } else {
    const l = _c(u, r), h = yd[l], d = n.direction[h] >= 0;
    let m, f;
    d ? (m = Tt(u), f = bt(u, r)) : (m = bt(u, r), f = Tt(u));
    const g = Cn(m, s, n, Ol) ? da(m, t, e, n) : null;
    if (g) {
      const y = g.point[h];
      if (d ? y <= s[f + l] : (
        // min bounding data
        y >= s[f + l + 3]
      ))
        return g;
    }
    const I = Cn(f, s, n, Ol) ? da(f, t, e, n) : null;
    return g && I ? g.distance <= I.distance ? g : I : g || I || null;
  }
}
var Ji = new Box3();
var ts = new Lt();
var ns = new Lt();
var Ys = new Matrix4();
var Dl = new ht();
var $i = new ht();
function Cd(u, t, e, n) {
  ke.setBuffer(u._roots[t]);
  const s = fa(0, u, e, n);
  return ke.clearBuffer(), s;
}
function fa(u, t, e, n, s = null) {
  const { float32Array: i, uint16Array: r, uint32Array: o } = ke;
  let l = u * 2;
  if (s === null && (e.boundingBox || e.computeBoundingBox(), Dl.set(e.boundingBox.min, e.boundingBox.max, n), s = Dl), gt(l, r)) {
    const h = t.geometry, d = h.index, m = h.attributes.position, f = e.index, g = e.attributes.position, I = Et(u, o), y = Ct(l, r);
    if (Ys.copy(n).invert(), e.boundsTree)
      return Ye(u, i, $i), $i.matrix.copy(Ys), $i.needsUpdate = true, e.boundsTree.shapecast({
        intersectsBounds: (x) => $i.intersectsBox(x),
        intersectsTriangle: (x) => {
          x.a.applyMatrix4(n), x.b.applyMatrix4(n), x.c.applyMatrix4(n), x.needsUpdate = true;
          for (let A = I, F = y + I; A < F; A++)
            if (Qe(ns, 3 * t.resolveTriangleIndex(A), d, m), ns.needsUpdate = true, x.intersectsTriangle(ns))
              return true;
          return false;
        }
      });
    for (let x = I, A = y + I; x < A; x++) {
      const F = t.resolveTriangleIndex(x);
      Qe(ts, 3 * F, d, m), ts.a.applyMatrix4(Ys), ts.b.applyMatrix4(Ys), ts.c.applyMatrix4(Ys), ts.needsUpdate = true;
      for (let P = 0, b = f.count; P < b; P += 3)
        if (Qe(ns, P, f, g), ns.needsUpdate = true, ts.intersectsTriangle(ns))
          return true;
    }
  } else {
    const h = u + 8, d = o[u + 6];
    return Ye(h, i, Ji), !!(s.intersectsBox(Ji) && fa(h, t, e, n, s) || (Ye(d, i, Ji), s.intersectsBox(Ji) && fa(d, t, e, n, s)));
  }
}
var er = new Matrix4();
var Go = new ht();
var Hs = new ht();
var Td = new Vector3();
var bd = new Vector3();
var xd = new Vector3();
var Sd = new Vector3();
function Ad(u, t, e, n = {}, s = {}, i = 0, r = 1 / 0) {
  t.boundingBox || t.computeBoundingBox(), Go.set(t.boundingBox.min, t.boundingBox.max, e), Go.needsUpdate = true;
  const o = u.geometry, l = o.attributes.position, h = o.index, d = t.attributes.position, m = t.index, f = wt.getPrimitive(), g = wt.getPrimitive();
  let I = Td, y = bd, x = null, A = null;
  s && (x = xd, A = Sd);
  let F = 1 / 0, P = null, b = null;
  return er.copy(e).invert(), Hs.matrix.copy(er), u.shapecast(
    {
      boundsTraverseOrder: (O) => Go.distanceToBox(O),
      intersectsBounds: (O, k, Y) => Y < F && Y < r ? (k && (Hs.min.copy(O.min), Hs.max.copy(O.max), Hs.needsUpdate = true), true) : false,
      intersectsRange: (O, k) => {
        if (t.boundsTree) {
          const Y = t.boundsTree;
          return Y.shapecast({
            boundsTraverseOrder: (H) => Hs.distanceToBox(H),
            intersectsBounds: (H, K, Z) => Z < F && Z < r,
            intersectsRange: (H, K) => {
              for (let Z = H, q = H + K; Z < q; Z++) {
                const ne = Y.resolveTriangleIndex(Z);
                Qe(g, 3 * ne, m, d), g.a.applyMatrix4(e), g.b.applyMatrix4(e), g.c.applyMatrix4(e), g.needsUpdate = true;
                for (let se = O, ue = O + k; se < ue; se++) {
                  const me = u.resolveTriangleIndex(se);
                  Qe(f, 3 * me, h, l), f.needsUpdate = true;
                  const Ie = f.distanceToTriangle(g, I, x);
                  if (Ie < F && (y.copy(I), A && A.copy(x), F = Ie, P = se, b = Z), Ie < i)
                    return true;
                }
              }
            }
          });
        } else {
          const Y = vs(t);
          for (let H = 0, K = Y; H < K; H++) {
            Qe(g, 3 * H, m, d), g.a.applyMatrix4(e), g.b.applyMatrix4(e), g.c.applyMatrix4(e), g.needsUpdate = true;
            for (let Z = O, q = O + k; Z < q; Z++) {
              const ne = u.resolveTriangleIndex(Z);
              Qe(f, 3 * ne, h, l), f.needsUpdate = true;
              const se = f.distanceToTriangle(g, I, x);
              if (se < F && (y.copy(I), A && A.copy(x), F = se, P = Z, b = H), se < i)
                return true;
            }
          }
        }
      }
    }
  ), wt.releasePrimitive(f), wt.releasePrimitive(g), F === 1 / 0 ? null : (n.point ? n.point.copy(y) : n.point = y.clone(), n.distance = F, n.faceIndex = P, s && (s.point ? s.point.copy(A) : s.point = A.clone(), s.point.applyMatrix4(er), y.applyMatrix4(er), s.distance = y.sub(s.point).length(), s.faceIndex = b), n);
}
function Rd() {
  return typeof SharedArrayBuffer < "u";
}
var ei = new ke.constructor();
var br = new ke.constructor();
var En = new Ma(() => new Box3());
var ss = new Box3();
var is = new Box3();
var Yo = new Box3();
var Ho = new Box3();
var Wo = false;
function Fd(u, t, e, n) {
  if (Wo)
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  Wo = true;
  const s = u._roots, i = t._roots;
  let r, o = 0, l = 0;
  const h = new Matrix4().copy(e).invert();
  for (let d = 0, m = s.length; d < m; d++) {
    ei.setBuffer(s[d]), l = 0;
    const f = En.getPrimitive();
    Ye(0, ei.float32Array, f), f.applyMatrix4(h);
    for (let g = 0, I = i.length; g < I && (br.setBuffer(i[d]), r = Ft(
      0,
      0,
      e,
      h,
      n,
      o,
      l,
      0,
      0,
      f
    ), br.clearBuffer(), l += i[g].length, !r); g++)
      ;
    if (En.releasePrimitive(f), ei.clearBuffer(), o += s[d].length, r)
      break;
  }
  return Wo = false, r;
}
function Ft(u, t, e, n, s, i = 0, r = 0, o = 0, l = 0, h = null, d = false) {
  let m, f;
  d ? (m = br, f = ei) : (m = ei, f = br);
  const g = m.float32Array, I = m.uint32Array, y = m.uint16Array, x = f.float32Array, A = f.uint32Array, F = f.uint16Array, P = u * 2, b = t * 2, O = gt(P, y), k = gt(b, F);
  let Y = false;
  if (k && O)
    d ? Y = s(
      Et(t, A),
      Ct(t * 2, F),
      Et(u, I),
      Ct(u * 2, y),
      l,
      r + t,
      o,
      i + u
    ) : Y = s(
      Et(u, I),
      Ct(u * 2, y),
      Et(t, A),
      Ct(t * 2, F),
      o,
      i + u,
      l,
      r + t
    );
  else if (k) {
    const H = En.getPrimitive();
    Ye(t, x, H), H.applyMatrix4(e);
    const K = Tt(u), Z = bt(u, I);
    Ye(K, g, ss), Ye(Z, g, is);
    const q = H.intersectsBox(ss), ne = H.intersectsBox(is);
    Y = q && Ft(
      t,
      K,
      n,
      e,
      s,
      r,
      i,
      l,
      o + 1,
      H,
      !d
    ) || ne && Ft(
      t,
      Z,
      n,
      e,
      s,
      r,
      i,
      l,
      o + 1,
      H,
      !d
    ), En.releasePrimitive(H);
  } else {
    const H = Tt(t), K = bt(t, A);
    Ye(H, x, Yo), Ye(K, x, Ho);
    const Z = h.intersectsBox(Yo), q = h.intersectsBox(Ho);
    if (Z && q)
      Y = Ft(
        u,
        H,
        e,
        n,
        s,
        i,
        r,
        o,
        l + 1,
        h,
        d
      ) || Ft(
        u,
        K,
        e,
        n,
        s,
        i,
        r,
        o,
        l + 1,
        h,
        d
      );
    else if (Z)
      if (O)
        Y = Ft(
          u,
          H,
          e,
          n,
          s,
          i,
          r,
          o,
          l + 1,
          h,
          d
        );
      else {
        const ne = En.getPrimitive();
        ne.copy(Yo).applyMatrix4(e);
        const se = Tt(u), ue = bt(u, I);
        Ye(se, g, ss), Ye(ue, g, is);
        const me = ne.intersectsBox(ss), Ie = ne.intersectsBox(is);
        Y = me && Ft(
          H,
          se,
          n,
          e,
          s,
          r,
          i,
          l,
          o + 1,
          ne,
          !d
        ) || Ie && Ft(
          H,
          ue,
          n,
          e,
          s,
          r,
          i,
          l,
          o + 1,
          ne,
          !d
        ), En.releasePrimitive(ne);
      }
    else if (q)
      if (O)
        Y = Ft(
          u,
          K,
          e,
          n,
          s,
          i,
          r,
          o,
          l + 1,
          h,
          d
        );
      else {
        const ne = En.getPrimitive();
        ne.copy(Ho).applyMatrix4(e);
        const se = Tt(u), ue = bt(u, I);
        Ye(se, g, ss), Ye(ue, g, is);
        const me = ne.intersectsBox(ss), Ie = ne.intersectsBox(is);
        Y = me && Ft(
          K,
          se,
          n,
          e,
          s,
          r,
          i,
          l,
          o + 1,
          ne,
          !d
        ) || Ie && Ft(
          K,
          ue,
          n,
          e,
          s,
          r,
          i,
          l,
          o + 1,
          ne,
          !d
        ), En.releasePrimitive(ne);
      }
  }
  return Y;
}
var tr = new ht();
var Ll = new Box3();
var Oa = class _Oa {
  static serialize(t, e = {}) {
    e = {
      cloneBuffers: true,
      ...e
    };
    const n = t.geometry, s = t._roots, i = t._indirectBuffer, r = n.getIndex();
    let o;
    return e.cloneBuffers ? o = {
      roots: s.map((l) => l.slice()),
      index: r.array.slice(),
      indirectBuffer: i ? i.slice() : null
    } : o = {
      roots: s,
      index: r.array,
      indirectBuffer: i
    }, o;
  }
  static deserialize(t, e, n = {}) {
    n = {
      setIndex: true,
      indirect: !!t.indirectBuffer,
      ...n
    };
    const { index: s, roots: i, indirectBuffer: r } = t, o = new _Oa(e, { ...n, [Uo]: true });
    if (o._roots = i, o._indirectBuffer = r || null, n.setIndex) {
      const l = e.getIndex();
      if (l === null) {
        const h = new BufferAttribute(t.index, 1, false);
        e.setIndex(h);
      } else
        l.array !== s && (l.array.set(s), l.needsUpdate = true);
    }
    return o;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(t, e = {}) {
    if (t.isBufferGeometry) {
      if (t.index && t.index.isInterleavedBufferAttribute)
        throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    } else
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    if (e = Object.assign({
      strategy: Dc,
      maxDepth: 40,
      maxLeafTris: 10,
      verbose: true,
      useSharedArrayBuffer: false,
      setBoundingBox: true,
      onProgress: null,
      indirect: false,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [Uo]: false
    }, e), e.useSharedArrayBuffer && !Rd())
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    this.geometry = t, this._roots = null, this._indirectBuffer = null, e[Uo] || (Ku(this, e), !t.boundingBox && e.setBoundingBox && (t.boundingBox = this.getBoundingBox(new Box3())));
    const { _indirectBuffer: n } = this;
    this.resolveTriangleIndex = e.indirect ? (s) => n[s] : (s) => s;
  }
  refit(t = null) {
    return (this.indirect ? vd : rd)(this, t);
  }
  traverse(t, e = 0) {
    const n = this._roots[e], s = new Uint32Array(n), i = new Uint16Array(n);
    r(0);
    function r(o, l = 0) {
      const h = o * 2, d = i[h + 15] === Wr;
      if (d) {
        const m = s[o + 6], f = i[h + 14];
        t(l, d, new Float32Array(n, o * 4, 6), m, f);
      } else {
        const m = o + Ir / 4, f = s[o + 6], g = s[o + 7];
        t(l, d, new Float32Array(n, o * 4, 6), g) || (r(m, l + 1), r(f, l + 1));
      }
    }
  }
  /* Core Cast Functions */
  raycast(t, e = FrontSide) {
    const n = this._roots, s = this.geometry, i = [], r = e.isMaterial, o = Array.isArray(e), l = s.groups, h = r ? e.side : e, d = this.indirect ? Id : cd;
    for (let m = 0, f = n.length; m < f; m++) {
      const g = o ? e[l[m].materialIndex].side : h, I = i.length;
      if (d(this, m, g, t, i), o) {
        const y = l[m].materialIndex;
        for (let x = I, A = i.length; x < A; x++)
          i[x].face.materialIndex = y;
      }
    }
    return i;
  }
  raycastFirst(t, e = FrontSide) {
    const n = this._roots, s = this.geometry, i = e.isMaterial, r = Array.isArray(e);
    let o = null;
    const l = s.groups, h = i ? e.side : e, d = this.indirect ? wd : ud;
    for (let m = 0, f = n.length; m < f; m++) {
      const g = r ? e[l[m].materialIndex].side : h, I = d(this, m, g, t);
      I != null && (o == null || I.distance < o.distance) && (o = I, r && (I.face.materialIndex = l[m].materialIndex));
    }
    return o;
  }
  intersectsGeometry(t, e) {
    let n = false;
    const s = this._roots, i = this.indirect ? Cd : dd;
    for (let r = 0, o = s.length; r < o && (n = i(this, r, t, e), !n); r++)
      ;
    return n;
  }
  shapecast(t) {
    const e = wt.getPrimitive(), n = this.indirect ? ld : id;
    let {
      boundsTraverseOrder: s,
      intersectsBounds: i,
      intersectsRange: r,
      intersectsTriangle: o
    } = t;
    if (r && o) {
      const m = r;
      r = (f, g, I, y, x) => m(f, g, I, y, x) ? true : n(f, g, this, o, I, y, e);
    } else
      r || (o ? r = (m, f, g, I) => n(m, f, this, o, g, I, e) : r = (m, f, g) => g);
    let l = false, h = 0;
    const d = this._roots;
    for (let m = 0, f = d.length; m < f; m++) {
      const g = d[m];
      if (l = Ju(this, m, i, r, s, h), l)
        break;
      h += g.byteLength;
    }
    return wt.releasePrimitive(e), l;
  }
  bvhcast(t, e, n) {
    let {
      intersectsRanges: s,
      intersectsTriangles: i
    } = n;
    const r = wt.getPrimitive(), o = this.geometry.index, l = this.geometry.attributes.position, h = this.indirect ? (I) => {
      const y = this.resolveTriangleIndex(I);
      Qe(r, y * 3, o, l);
    } : (I) => {
      Qe(r, I * 3, o, l);
    }, d = wt.getPrimitive(), m = t.geometry.index, f = t.geometry.attributes.position, g = t.indirect ? (I) => {
      const y = t.resolveTriangleIndex(I);
      Qe(d, y * 3, m, f);
    } : (I) => {
      Qe(d, I * 3, m, f);
    };
    if (i) {
      const I = (y, x, A, F, P, b, O, k) => {
        for (let Y = A, H = A + F; Y < H; Y++) {
          g(Y), d.a.applyMatrix4(e), d.b.applyMatrix4(e), d.c.applyMatrix4(e), d.needsUpdate = true;
          for (let K = y, Z = y + x; K < Z; K++)
            if (h(K), r.needsUpdate = true, i(r, d, K, Y, P, b, O, k))
              return true;
        }
        return false;
      };
      if (s) {
        const y = s;
        s = function(x, A, F, P, b, O, k, Y) {
          return y(x, A, F, P, b, O, k, Y) ? true : I(x, A, F, P, b, O, k, Y);
        };
      } else
        s = I;
    }
    return Fd(this, t, e, s);
  }
  /* Derived Cast Functions */
  intersectsBox(t, e) {
    return tr.set(t.min, t.max, e), tr.needsUpdate = true, this.shapecast(
      {
        intersectsBounds: (n) => tr.intersectsBox(n),
        intersectsTriangle: (n) => tr.intersectsTriangle(n)
      }
    );
  }
  intersectsSphere(t) {
    return this.shapecast(
      {
        intersectsBounds: (e) => t.intersectsBox(e),
        intersectsTriangle: (e) => e.intersectsSphere(t)
      }
    );
  }
  closestPointToGeometry(t, e, n = {}, s = {}, i = 0, r = 1 / 0) {
    return (this.indirect ? Ad : Ed)(
      this,
      t,
      e,
      n,
      s,
      i,
      r
    );
  }
  closestPointToPoint(t, e = {}, n = 0, s = 1 / 0) {
    return $u(
      this,
      t,
      e,
      n,
      s
    );
  }
  getBoundingBox(t) {
    return t.makeEmpty(), this._roots.forEach((e) => {
      Ye(0, new Float32Array(e), Ll), t.union(Ll);
    }), t;
  }
};
function Nl(u, t, e) {
  return u === null || (u.point.applyMatrix4(t.matrixWorld), u.distance = u.point.distanceTo(e.ray.origin), u.object = t, u.distance < e.near || u.distance > e.far) ? null : u;
}
var Ko = new Ray();
var _l = new Matrix4();
var Pd = Mesh.prototype.raycast;
function Md(u, t) {
  if (this.geometry.boundsTree) {
    if (this.material === void 0)
      return;
    _l.copy(this.matrixWorld).invert(), Ko.copy(u.ray).applyMatrix4(_l);
    const e = this.geometry.boundsTree;
    if (u.firstHitOnly === true) {
      const n = Nl(e.raycastFirst(Ko, this.material), this, u);
      n && t.push(n);
    } else {
      const n = e.raycast(Ko, this.material);
      for (let s = 0, i = n.length; s < i; s++) {
        const r = Nl(n[s], this, u);
        r && t.push(r);
      }
    }
  } else
    Pd.call(this, u, t);
}
function Od(u) {
  return this.boundsTree = new Oa(this, u), this.boundsTree;
}
function Dd() {
  this.boundsTree = null;
}
var $ = class {
  constructor() {
    S(this, "trigger", (t) => {
      const e = this.handlers.slice(0);
      for (const n of e)
        n(t);
    }), S(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(t) {
    this.handlers.push(t);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(t) {
    this.handlers = this.handlers.filter((e) => e !== t);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
};
var yn = class {
  constructor() {
    S(this, "trigger", async (t) => {
      const e = this.handlers.slice(0);
      for (const n of e)
        await n(t);
    }), S(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(t) {
    this.handlers.push(t);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(t) {
    this.handlers = this.handlers.filter((e) => e !== t);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
};
var Da = class {
  constructor(t) {
    S(this, "isDisposeable", () => "dispose" in this && "onDisposed" in this), S(this, "isResizeable", () => "resize" in this && "getSize" in this), S(this, "isUpdateable", () => "onAfterUpdate" in this && "onBeforeUpdate" in this && "update" in this), S(this, "isHideable", () => "visible" in this), S(this, "isConfigurable", () => "setup" in this && "config" in this && "onSetup" in this), this.components = t;
  }
};
var Re = class extends Da {
};
var Uc = class extends Da {
  constructor(t) {
    super(t), S(this, "worlds", /* @__PURE__ */ new Map()), S(this, "onWorldChanged", new $()), S(this, "currentWorld", null), this.onWorldChanged.add(({ world: e, action: n }) => {
      n === "removed" && this.worlds.delete(e.uuid);
    });
  }
};
var Ld = class extends Uc {
  constructor() {
    super(...arguments), S(this, "hasCameraControls", () => "controls" in this);
  }
};
var Nd = class extends Uc {
  constructor() {
    super(...arguments), S(this, "onAfterUpdate", new $()), S(this, "onBeforeUpdate", new $()), S(this, "onDisposed", new $()), S(this, "onResize", new $()), S(this, "onClippingPlanesUpdated", new $()), S(this, "clippingPlanes", []);
  }
  /**
   * Forces the update of the clipping planes and all components that depend
   * on them that are subscribed to `onClippingPlanesUpdated`.
   */
  updateClippingPlanes() {
    this.onClippingPlanesUpdated.trigger();
  }
  /**
   * Adds or removes a
   * [clipping plane](https://threejs.org/docs/#api/en/renderers/WebGLRenderer.clippingPlanes)
   * to the renderer.
   */
  setPlane(t, e, n) {
    e.isLocal = n;
    const s = this.clippingPlanes.indexOf(e);
    t && s === -1 ? this.clippingPlanes.push(e) : !t && s > -1 && this.clippingPlanes.splice(s, 1), this.three.clippingPlanes = this.clippingPlanes.filter(
      (i) => !i.isLocal
    );
  }
};
var Bc = class pa extends Re {
  constructor(t) {
    super(t), S(this, "_disposedComponents", /* @__PURE__ */ new Set()), S(this, "enabled", true), t.add(pa.uuid, this);
  }
  /**
   * {@link Component.uuid}.
   * @return the list of UUIDs of deleted components.
   */
  get() {
    return this._disposedComponents;
  }
  /**
   * Removes a mesh, its geometry and its materials from memory. If you are
   * using any of these in other parts of the application, make sure that you
   * remove them from the mesh before disposing it.
   *
   * @param object - the [object](https://threejs.org/docs/#api/en/core/Object3D)
   * to remove.
   *
   * @param materials - whether to dispose the materials of the mesh.
   *
   * @param recursive - whether to recursively dispose the children of the mesh.
   */
  destroy(t, e = true, n = true) {
    t.removeFromParent();
    const s = t;
    s.dispose && s.dispose(), this.disposeGeometryAndMaterials(t, e), n && s.children && s.children.length && this.disposeChildren(s), t.children.length = 0;
  }
  /**
   * Disposes a geometry from memory.
   *
   * @param geometry - the
   * [geometry](https://threejs.org/docs/#api/en/core/BufferGeometry)
   * to remove.
   */
  disposeGeometry(t) {
    const e = t;
    e.boundsTree && e.disposeBoundsTree(), t.dispose();
  }
  disposeGeometryAndMaterials(t, e) {
    const n = t;
    n.geometry && this.disposeGeometry(n.geometry), e && n.material && pa.disposeMaterial(n), n.material = [], n.geometry = null;
  }
  disposeChildren(t) {
    for (const e of t.children)
      this.destroy(e);
  }
  static disposeMaterial(t) {
    if (t.material)
      if (Array.isArray(t.material))
        for (const e of t.material)
          e.dispose();
      else
        t.material.dispose();
  }
};
S(Bc, "uuid", "76e9cd8e-ad8f-4753-9ef6-cbc60f7247fe");
var rn = Bc;
var yr = 0;
var _d = 1;
var Ud = new Vector3();
var Ul = new Line3();
var jo = new Plane();
var Bl = new Vector3();
var nr = new Triangle();
var Bd = class {
  constructor() {
    this.tolerance = -1, this.faces = [], this.newFaces = [], this.assigned = new kl(), this.unassigned = new kl(), this.vertices = [];
  }
  setFromPoints(t) {
    if (t.length >= 4) {
      this.makeEmpty();
      for (let e = 0, n = t.length; e < n; e++)
        this.vertices.push(new kd(t[e]));
      this.compute();
    }
    return this;
  }
  setFromObject(t) {
    const e = [];
    return t.updateMatrixWorld(true), t.traverse(function(n) {
      const s = n.geometry;
      if (s !== void 0) {
        const i = s.attributes.position;
        if (i !== void 0)
          for (let r = 0, o = i.count; r < o; r++) {
            const l = new Vector3();
            l.fromBufferAttribute(i, r).applyMatrix4(n.matrixWorld), e.push(l);
          }
      }
    }), this.setFromPoints(e);
  }
  containsPoint(t) {
    const e = this.faces;
    for (let n = 0, s = e.length; n < s; n++)
      if (e[n].distanceToPoint(t) > this.tolerance)
        return false;
    return true;
  }
  intersectRay(t, e) {
    const n = this.faces;
    let s = -1 / 0, i = 1 / 0;
    for (let r = 0, o = n.length; r < o; r++) {
      const l = n[r], h = l.distanceToPoint(t.origin), d = l.normal.dot(t.direction);
      if (h > 0 && d >= 0)
        return null;
      const m = d !== 0 ? -h / d : 0;
      if (!(m <= 0) && (d > 0 ? i = Math.min(m, i) : s = Math.max(m, s), s > i))
        return null;
    }
    return s !== -1 / 0 ? t.at(s, e) : t.at(i, e), e;
  }
  intersectsRay(t) {
    return this.intersectRay(t, Ud) !== null;
  }
  makeEmpty() {
    return this.faces = [], this.vertices = [], this;
  }
  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face
  addVertexToFace(t, e) {
    return t.face = e, e.outside === null ? this.assigned.append(t) : this.assigned.insertBefore(e.outside, t), e.outside = t, this;
  }
  // Removes a vertex from the 'assigned' list of vertices and from the given face
  removeVertexFromFace(t, e) {
    return t === e.outside && (t.next !== null && t.next.face === e ? e.outside = t.next : e.outside = null), this.assigned.remove(t), this;
  }
  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list
  removeAllVerticesFromFace(t) {
    if (t.outside !== null) {
      const e = t.outside;
      let n = t.outside;
      for (; n.next !== null && n.next.face === t; )
        n = n.next;
      return this.assigned.removeSubList(e, n), e.prev = n.next = null, t.outside = null, e;
    }
  }
  // Removes all the visible vertices that 'face' is able to see
  deleteFaceVertices(t, e) {
    const n = this.removeAllVerticesFromFace(t);
    if (n !== void 0)
      if (e === void 0)
        this.unassigned.appendChain(n);
      else {
        let s = n;
        do {
          const i = s.next;
          e.distanceToPoint(s.point) > this.tolerance ? this.addVertexToFace(s, e) : this.unassigned.append(s), s = i;
        } while (s !== null);
      }
    return this;
  }
  // Reassigns as many vertices as possible from the unassigned list to the new faces
  resolveUnassignedPoints(t) {
    if (this.unassigned.isEmpty() === false) {
      let e = this.unassigned.first();
      do {
        const n = e.next;
        let s = this.tolerance, i = null;
        for (let r = 0; r < t.length; r++) {
          const o = t[r];
          if (o.mark === yr) {
            const l = o.distanceToPoint(e.point);
            if (l > s && (s = l, i = o), s > 1e3 * this.tolerance)
              break;
          }
        }
        i !== null && this.addVertexToFace(e, i), e = n;
      } while (e !== null);
    }
    return this;
  }
  // Computes the extremes of a simplex which will be the initial hull
  computeExtremes() {
    const t = new Vector3(), e = new Vector3(), n = [], s = [];
    for (let i = 0; i < 3; i++)
      n[i] = s[i] = this.vertices[0];
    t.copy(this.vertices[0].point), e.copy(this.vertices[0].point);
    for (let i = 0, r = this.vertices.length; i < r; i++) {
      const o = this.vertices[i], l = o.point;
      for (let h = 0; h < 3; h++)
        l.getComponent(h) < t.getComponent(h) && (t.setComponent(h, l.getComponent(h)), n[h] = o);
      for (let h = 0; h < 3; h++)
        l.getComponent(h) > e.getComponent(h) && (e.setComponent(h, l.getComponent(h)), s[h] = o);
    }
    return this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(t.x), Math.abs(e.x)) + Math.max(Math.abs(t.y), Math.abs(e.y)) + Math.max(Math.abs(t.z), Math.abs(e.z))), { min: n, max: s };
  }
  // Computes the initial simplex assigning to its faces all the points
  // that are candidates to form part of the hull
  computeInitialHull() {
    const t = this.vertices, e = this.computeExtremes(), n = e.min, s = e.max;
    let i = 0, r = 0;
    for (let f = 0; f < 3; f++) {
      const g = s[f].point.getComponent(f) - n[f].point.getComponent(f);
      g > i && (i = g, r = f);
    }
    const o = n[r], l = s[r];
    let h, d;
    i = 0, Ul.set(o.point, l.point);
    for (let f = 0, g = this.vertices.length; f < g; f++) {
      const I = t[f];
      if (I !== o && I !== l) {
        Ul.closestPointToPoint(I.point, true, Bl);
        const y = Bl.distanceToSquared(I.point);
        y > i && (i = y, h = I);
      }
    }
    i = -1, jo.setFromCoplanarPoints(o.point, l.point, h.point);
    for (let f = 0, g = this.vertices.length; f < g; f++) {
      const I = t[f];
      if (I !== o && I !== l && I !== h) {
        const y = Math.abs(jo.distanceToPoint(I.point));
        y > i && (i = y, d = I);
      }
    }
    const m = [];
    if (jo.distanceToPoint(d.point) < 0) {
      m.push(
        Mt.create(o, l, h),
        Mt.create(d, l, o),
        Mt.create(d, h, l),
        Mt.create(d, o, h)
      );
      for (let f = 0; f < 3; f++) {
        const g = (f + 1) % 3;
        m[f + 1].getEdge(2).setTwin(m[0].getEdge(g)), m[f + 1].getEdge(1).setTwin(m[g + 1].getEdge(0));
      }
    } else {
      m.push(
        Mt.create(o, h, l),
        Mt.create(d, o, l),
        Mt.create(d, l, h),
        Mt.create(d, h, o)
      );
      for (let f = 0; f < 3; f++) {
        const g = (f + 1) % 3;
        m[f + 1].getEdge(2).setTwin(m[0].getEdge((3 - f) % 3)), m[f + 1].getEdge(0).setTwin(m[g + 1].getEdge(1));
      }
    }
    for (let f = 0; f < 4; f++)
      this.faces.push(m[f]);
    for (let f = 0, g = t.length; f < g; f++) {
      const I = t[f];
      if (I !== o && I !== l && I !== h && I !== d) {
        i = this.tolerance;
        let y = null;
        for (let x = 0; x < 4; x++) {
          const A = this.faces[x].distanceToPoint(I.point);
          A > i && (i = A, y = this.faces[x]);
        }
        y !== null && this.addVertexToFace(I, y);
      }
    }
    return this;
  }
  // Removes inactive faces
  reindexFaces() {
    const t = [];
    for (let e = 0; e < this.faces.length; e++) {
      const n = this.faces[e];
      n.mark === yr && t.push(n);
    }
    return this.faces = t, this;
  }
  // Finds the next vertex to create faces with the current hull
  nextVertexToAdd() {
    if (this.assigned.isEmpty() === false) {
      let t, e = 0;
      const n = this.assigned.first().face;
      let s = n.outside;
      do {
        const i = n.distanceToPoint(s.point);
        i > e && (e = i, t = s), s = s.next;
      } while (s !== null && s.face === n);
      return t;
    }
  }
  // Computes a chain of half edges in CCW order called the 'horizon'.
  // For an edge to be part of the horizon it must join a face that can see
  // 'eyePoint' and a face that cannot see 'eyePoint'.
  computeHorizon(t, e, n, s) {
    this.deleteFaceVertices(n), n.mark = _d;
    let i;
    e === null ? i = e = n.getEdge(0) : i = e.next;
    do {
      const r = i.twin, o = r.face;
      o.mark === yr && (o.distanceToPoint(t) > this.tolerance ? this.computeHorizon(t, r, o, s) : s.push(i)), i = i.next;
    } while (i !== e);
    return this;
  }
  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order
  addAdjoiningFace(t, e) {
    const n = Mt.create(t, e.tail(), e.head());
    return this.faces.push(n), n.getEdge(-1).setTwin(e.twin), n.getEdge(0);
  }
  //  Adds 'horizon.length' faces to the hull, each face will be linked with the
  //  horizon opposite face and the face on the left/right
  addNewFaces(t, e) {
    this.newFaces = [];
    let n = null, s = null;
    for (let i = 0; i < e.length; i++) {
      const r = e[i], o = this.addAdjoiningFace(t, r);
      n === null ? n = o : o.next.setTwin(s), this.newFaces.push(o.face), s = o;
    }
    return n.next.setTwin(s), this;
  }
  // Adds a vertex to the hull
  addVertexToHull(t) {
    const e = [];
    return this.unassigned.clear(), this.removeVertexFromFace(t, t.face), this.computeHorizon(t.point, null, t.face, e), this.addNewFaces(t, e), this.resolveUnassignedPoints(this.newFaces), this;
  }
  cleanup() {
    return this.assigned.clear(), this.unassigned.clear(), this.newFaces = [], this;
  }
  compute() {
    let t;
    for (this.computeInitialHull(); (t = this.nextVertexToAdd()) !== void 0; )
      this.addVertexToHull(t);
    return this.reindexFaces(), this.cleanup(), this;
  }
};
var Mt = class _Mt {
  constructor() {
    this.normal = new Vector3(), this.midpoint = new Vector3(), this.area = 0, this.constant = 0, this.outside = null, this.mark = yr, this.edge = null;
  }
  static create(t, e, n) {
    const s = new _Mt(), i = new Xo(t, s), r = new Xo(e, s), o = new Xo(n, s);
    return i.next = o.prev = r, r.next = i.prev = o, o.next = r.prev = i, s.edge = i, s.compute();
  }
  getEdge(t) {
    let e = this.edge;
    for (; t > 0; )
      e = e.next, t--;
    for (; t < 0; )
      e = e.prev, t++;
    return e;
  }
  compute() {
    const t = this.edge.tail(), e = this.edge.head(), n = this.edge.next.head();
    return nr.set(t.point, e.point, n.point), nr.getNormal(this.normal), nr.getMidpoint(this.midpoint), this.area = nr.getArea(), this.constant = this.normal.dot(this.midpoint), this;
  }
  distanceToPoint(t) {
    return this.normal.dot(t) - this.constant;
  }
};
var Xo = class {
  constructor(t, e) {
    this.vertex = t, this.prev = null, this.next = null, this.twin = null, this.face = e;
  }
  head() {
    return this.vertex;
  }
  tail() {
    return this.prev ? this.prev.vertex : null;
  }
  length() {
    const t = this.head(), e = this.tail();
    return e !== null ? e.point.distanceTo(t.point) : -1;
  }
  lengthSquared() {
    const t = this.head(), e = this.tail();
    return e !== null ? e.point.distanceToSquared(t.point) : -1;
  }
  setTwin(t) {
    return this.twin = t, t.twin = this, this;
  }
};
var kd = class {
  constructor(t) {
    this.point = t, this.prev = null, this.next = null, this.face = null;
  }
};
var kl = class {
  constructor() {
    this.head = null, this.tail = null;
  }
  first() {
    return this.head;
  }
  last() {
    return this.tail;
  }
  clear() {
    return this.head = this.tail = null, this;
  }
  // Inserts a vertex before the target vertex
  insertBefore(t, e) {
    return e.prev = t.prev, e.next = t, e.prev === null ? this.head = e : e.prev.next = e, t.prev = e, this;
  }
  // Inserts a vertex after the target vertex
  insertAfter(t, e) {
    return e.prev = t, e.next = t.next, e.next === null ? this.tail = e : e.next.prev = e, t.next = e, this;
  }
  // Appends a vertex to the end of the linked list
  append(t) {
    return this.head === null ? this.head = t : this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t, this;
  }
  // Appends a chain of vertices where 'vertex' is the head.
  appendChain(t) {
    for (this.head === null ? this.head = t : this.tail.next = t, t.prev = this.tail; t.next !== null; )
      t = t.next;
    return this.tail = t, this;
  }
  // Removes a vertex from the linked list
  remove(t) {
    return t.prev === null ? this.head = t.next : t.prev.next = t.next, t.next === null ? this.tail = t.prev : t.next.prev = t.prev, this;
  }
  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b
  removeSubList(t, e) {
    return t.prev === null ? this.head = e.next : t.prev.next = e.next, e.next === null ? this.tail = t.prev : e.next.prev = t.prev, this;
  }
  isEmpty() {
    return this.head === null;
  }
};
var ma = [2, 2, 1];
var ga = [1, 0, 0];
function Wt(u, t) {
  return u * 3 + t;
}
function zd(u) {
  const t = u.elements;
  let e = 0;
  for (let n = 0; n < 9; n++)
    e += t[n] * t[n];
  return Math.sqrt(e);
}
function Vd(u) {
  const t = u.elements;
  let e = 0;
  for (let n = 0; n < 3; n++) {
    const s = t[Wt(ma[n], ga[n])];
    e += 2 * s * s;
  }
  return Math.sqrt(e);
}
function Gd(u, t) {
  let e = 0, n = 1;
  const s = u.elements;
  for (let h = 0; h < 3; h++) {
    const d = Math.abs(s[Wt(ma[h], ga[h])]);
    d > e && (e = d, n = h);
  }
  let i = 1, r = 0;
  const o = ga[n], l = ma[n];
  if (Math.abs(s[Wt(l, o)]) > Number.EPSILON) {
    const h = s[Wt(l, l)], d = s[Wt(o, o)], m = s[Wt(l, o)], f = (h - d) / 2 / m;
    let g;
    f < 0 ? g = -1 / (-f + Math.sqrt(1 + f * f)) : g = 1 / (f + Math.sqrt(1 + f * f)), i = 1 / Math.sqrt(1 + g * g), r = g * i;
  }
  return t.identity(), t.elements[Wt(o, o)] = i, t.elements[Wt(l, l)] = i, t.elements[Wt(l, o)] = r, t.elements[Wt(o, l)] = -r, t;
}
function Yd(u, t) {
  let e = 0, n = 0;
  const s = 10;
  t.unitary.identity(), t.diagonal.copy(u);
  const i = t.unitary, r = t.diagonal, o = new Matrix3(), l = new Matrix3(), h = Number.EPSILON * zd(r);
  for (; n < s && Vd(r) > h; )
    Gd(r, o), l.copy(o).transpose(), r.multiply(o), r.premultiply(l), i.multiply(o), ++e > 2 && (n++, e = 0);
  return t;
}
function Hd(u) {
  const t = [];
  for (let je = 0; je < u.length - 2; je += 3) {
    const pe = u[je], Ge = u[je + 1], St = u[je + 2];
    t.push(new Vector3(pe, Ge, St));
  }
  const e = new Bd();
  e.setFromPoints(t);
  const n = {
    unitary: new Matrix3(),
    diagonal: new Matrix3()
  }, s = e.faces, i = [], r = [];
  for (let je = 0, pe = s.length; je < pe; je++) {
    const Ge = s[je];
    let St = Ge.edge;
    i.length = 0;
    do
      i.push(St), St = St.next;
    while (St !== Ge.edge);
    const Oe = i.length - 2;
    for (let _t = 1, qr = Oe; _t <= qr; _t++) {
      const At = i[0].vertex, ws = i[_t + 0].vertex, Cs = i[_t + 1].vertex;
      r.push(At.point.x, At.point.y, At.point.z), r.push(ws.point.x, ws.point.y, ws.point.z), r.push(Cs.point.x, Cs.point.y, Cs.point.z);
    }
  }
  const o = new Vector3(), l = new Vector3(), h = new Vector3(), d = new Vector3(), m = new Vector3(), f = new Vector3(), g = new Vector3(), I = new Vector3();
  let y = 0, x = 0, A = 0, F = 0, P = 0, b = 0, O = 0;
  for (let je = 0, pe = r.length; je < pe; je += 9) {
    o.fromArray(r, je), l.fromArray(r, je + 3), h.fromArray(r, je + 6), g.set(0, 0, 0), g.add(o).add(l).add(h).divideScalar(3), d.subVectors(l, o), m.subVectors(h, o);
    const Ge = f.crossVectors(d, m).length() / 2;
    I.add(f.copy(g).multiplyScalar(Ge)), y += Ge, x += (9 * g.x * g.x + o.x * o.x + l.x * l.x + h.x * h.x) * (Ge / 12), A += (9 * g.x * g.y + o.x * o.y + l.x * l.y + h.x * h.y) * (Ge / 12), F += (9 * g.x * g.z + o.x * o.z + l.x * l.z + h.x * h.z) * (Ge / 12), P += (9 * g.y * g.y + o.y * o.y + l.y * l.y + h.y * h.y) * (Ge / 12), b += (9 * g.y * g.z + o.y * o.z + l.y * l.z + h.y * h.z) * (Ge / 12), O += (9 * g.z * g.z + o.z * o.z + l.z * l.z + h.z * h.z) * (Ge / 12);
  }
  I.divideScalar(y), x /= y, A /= y, F /= y, P /= y, b /= y, O /= y, x -= I.x * I.x, A -= I.x * I.y, F -= I.x * I.z, P -= I.y * I.y, b -= I.y * I.z, O -= I.z * I.z;
  const k = new Matrix3();
  k.elements[0] = x, k.elements[1] = A, k.elements[2] = F, k.elements[3] = A, k.elements[4] = P, k.elements[5] = b, k.elements[6] = F, k.elements[7] = b, k.elements[8] = O, Yd(k, n);
  const Y = n.unitary, H = new Vector3(), K = new Vector3(), Z = new Vector3();
  Y.extractBasis(H, K, Z);
  let q = -1 / 0, ne = -1 / 0, se = -1 / 0, ue = 1 / 0, me = 1 / 0, Ie = 1 / 0;
  for (let je = 0, pe = t.length; je < pe; je++) {
    const Ge = t[je];
    q = Math.max(H.dot(Ge), q), ne = Math.max(K.dot(Ge), ne), se = Math.max(Z.dot(Ge), se), ue = Math.min(H.dot(Ge), ue), me = Math.min(K.dot(Ge), me), Ie = Math.min(Z.dot(Ge), Ie);
  }
  H.multiplyScalar(0.5 * (ue + q)), K.multiplyScalar(0.5 * (me + ne)), Z.multiplyScalar(0.5 * (Ie + se));
  const Ee = new Vector3(), de = new Vector3(), Le = new Matrix3();
  Ee.add(H).add(K).add(Z), de.x = q - ue, de.y = ne - me, de.z = se - Ie, de.multiplyScalar(0.5), Le.copy(Y);
  const { x: we, y: Ke, z: Nt } = de, vt = new Matrix4();
  vt.makeScale(we * 2, Ke * 2, Nt * 2);
  const ys = new Matrix4();
  ys.makeTranslation(-we, -Ke, -Nt);
  const Tn = new Matrix4();
  Tn.makeTranslation(Ee.x, Ee.y, Ee.z);
  const Zt = new Matrix4();
  Zt.setFromMatrix3(Le);
  const Qt = new Matrix4();
  return Qt.multiply(Tn), Qt.multiply(Zt), Qt.multiply(ys), Qt.multiply(vt), { center: Ee, halfSizes: de, rotation: Le, transformation: Qt };
}
function Wd(u, t, e) {
  const n = [
    u[0] - t[0],
    u[1] - t[1],
    u[2] - t[2]
  ];
  return e[0] * n[0] + e[1] * n[1] + e[2] * n[2] > 0;
}
var zl = class {
  static isTransparent(t) {
    return t.transparent && t.opacity < 1;
  }
};
var Ea = class $e {
  // Copied from three.js source
  // Original source: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
  static create() {
    const t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, s = Math.random() * 4294967295 | 0;
    return `${$e._lut[t & 255] + $e._lut[t >> 8 & 255] + $e._lut[t >> 16 & 255] + $e._lut[t >> 24 & 255]}-${$e._lut[e & 255]}${$e._lut[e >> 8 & 255]}-${$e._lut[e >> 16 & 15 | 64]}${$e._lut[e >> 24 & 255]}-${$e._lut[n & 63 | 128]}${$e._lut[n >> 8 & 255]}-${$e._lut[n >> 16 & 255]}${$e._lut[n >> 24 & 255]}${$e._lut[s & 255]}${$e._lut[s >> 8 & 255]}${$e._lut[s >> 16 & 255]}${$e._lut[s >> 24 & 255]}`.toLowerCase();
  }
  static validate(t) {
    if (!$e._pattern.test(t))
      throw new Error(
        `${t} is not a valid UUID v4.

- If you're the tool creator, you can take one from https://www.uuidgenerator.net/.

- If you're using a platform tool, verify the uuid isn't misspelled or contact the tool creator.`
      );
  }
};
S(Ea, "_pattern", /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/), // prettier-ignore
S(Ea, "_lut", [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff"
]);
var La = Ea;
var Kd = class extends Re {
  constructor(t, e) {
    super(t), S(this, "onVertexFound", new $()), S(this, "onVertexLost", new $()), S(this, "components"), S(this, "_pickedPoint", null), S(this, "_config"), S(this, "_enabled", false), S(this, "_workingPlane", null), this.components = t, this.config = {
      snapDistance: 0.25,
      showOnlyVertex: false,
      ...e
    }, this.enabled = false;
  }
  set enabled(t) {
    this._enabled = t, t || (this._pickedPoint = null);
  }
  get enabled() {
    return this._enabled;
  }
  set workingPlane(t) {
    this._workingPlane = t;
  }
  get workingPlane() {
    return this._workingPlane;
  }
  set config(t) {
    this._config = { ...this._config, ...t };
  }
  get config() {
    return this._config;
  }
  dispose() {
    this.onVertexFound.reset(), this.onVertexLost.reset(), this.components = null;
  }
  get(t) {
    if (!this.enabled)
      return this._pickedPoint;
    const e = this.components.get(Dt).get(t).castRay();
    if (!e)
      return this._pickedPoint !== null && (this.onVertexLost.trigger(), this._pickedPoint = null), this._pickedPoint;
    const n = this.getClosestVertex(e);
    return n ? !this.workingPlane || Math.abs(this.workingPlane.distanceToPoint(n)) < 1e-3 ? ((this._pickedPoint === null || !this._pickedPoint.equals(n)) && (this._pickedPoint = n.clone(), this.onVertexFound.trigger(this._pickedPoint)), this._pickedPoint) : (this._pickedPoint = null, this._pickedPoint) : (this._pickedPoint !== null && (this.onVertexLost.trigger(), this._pickedPoint = null), this._pickedPoint);
  }
  getClosestVertex(t) {
    let e = new Vector3(), n = false, s = Number.MAX_SAFE_INTEGER;
    const i = this.getVertices(t);
    if (i === null)
      return null;
    for (const r of i) {
      if (!r)
        continue;
      const o = t.point.distanceTo(r);
      o > s || o > this._config.snapDistance || (n = true, e = r, s = t.point.distanceTo(r));
    }
    return n ? e : this.config.showOnlyVertex ? null : t.point;
  }
  getVertices(t) {
    const e = t.object;
    if (!t.face || !e)
      return null;
    const n = e.geometry, s = new Matrix4(), { instanceId: i } = t, r = i !== void 0, o = e instanceof InstancedMesh;
    return o && r && e.getMatrixAt(i, s), [
      this.getVertex(t.face.a, n),
      this.getVertex(t.face.b, n),
      this.getVertex(t.face.c, n)
    ].map((l) => (l && (o && r && l.applyMatrix4(s), l.applyMatrix4(e.matrixWorld)), l));
  }
  getVertex(t, e) {
    if (t === void 0)
      return null;
    const n = e.attributes.position;
    return new Vector3(
      n.getX(t),
      n.getY(t),
      n.getZ(t)
    );
  }
};
var kc = class zc {
  constructor() {
    S(this, "onDisposed", new $()), S(this, "list", /* @__PURE__ */ new Map()), S(this, "enabled", false), S(this, "_clock"), S(this, "update", () => {
      if (!this.enabled)
        return;
      const t = this._clock.getDelta();
      for (const [e, n] of this.list)
        n.enabled && n.isUpdateable() && n.update(t);
      requestAnimationFrame(this.update);
    }), this._clock = new Clock(), zc.setupBVH();
  }
  add(t, e) {
    if (this.list.has(t))
      throw new Error(
        "You're trying to add a component that already exists in the components intance. Use Components.get() instead."
      );
    La.validate(t), this.list.set(t, e);
  }
  /**
   * Retrieves a component. If it already exists in this app, it returns the instance of the component. If it
   * doesn't exist, it will instance it automatically.
   *
   * @param Component - The component to get or create.
   */
  get(t) {
    const e = t.uuid;
    if (!this.list.has(e)) {
      const n = new t(this);
      return this.list.has(e) || this.add(e, n), n;
    }
    return this.list.get(e);
  }
  /**
   * Initializes the library. It should be called at the start of the app after
   * initializing the scene, the renderer and the
   * camera. Additionally, if any component that need a raycaster is
   * used, the {@link raycaster} will need to be initialized.
   */
  init() {
    this.enabled = true, this._clock.start(), this.update();
  }
  /**
   * Disposes the memory of all the components and tools of this instance of
   * the library. A memory leak will be created if:
   *
   * - An instance of the library ends up out of scope and this function isn't
   * called. This is especially relevant in Single Page Applications (React,
   * Angular, Vue, etc).
   *
   * - Any of the objects of this instance (meshes, geometries, etc) is
   * referenced by a reference type (object or array).
   *
   * You can learn more about how Three.js handles memory leaks
   * [here](https://threejs.org/docs/#manual/en/introduction/How-to-dispose-of-objects).
   *
   */
  dispose() {
    this.enabled = false;
    for (const [t, e] of this.list)
      e.enabled = false, e.isDisposeable() && e.dispose();
    this._clock.stop(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  static setupBVH() {
    BufferGeometry.prototype.computeBoundsTree = Od, BufferGeometry.prototype.disposeBoundsTree = Dd, Mesh.prototype.raycast = Md;
  }
};
S(kc, "release", "1.4.21");
var jd = kc;
var Xd = class {
  constructor(t) {
    S(this, "_event"), S(this, "_position", new Vector2()), S(this, "onDisposed", new $()), S(this, "updateMouseInfo", (e) => {
      this._event = e;
    }), this.dom = t, this.setupEvents(true);
  }
  /**
   * The real position of the mouse of the Three.js canvas.
   */
  get position() {
    if (this._event) {
      const t = this.dom.getBoundingClientRect();
      this._position.x = this.getPositionX(t, this._event), this._position.y = this.getPositionY(t, this._event);
    }
    return this._position;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  getPositionY(t, e) {
    return -((e.clientY - t.top) / (t.bottom - t.top)) * 2 + 1;
  }
  getPositionX(t, e) {
    return (e.clientX - t.left) / (t.right - t.left) * 2 - 1;
  }
  setupEvents(t) {
    t ? this.dom.addEventListener("mousemove", this.updateMouseInfo) : this.dom.removeEventListener("mousemove", this.updateMouseInfo);
  }
};
var Zd = class {
  constructor(t, e) {
    S(this, "enabled", true), S(this, "components"), S(this, "onDisposed", new $()), S(this, "mouse"), S(this, "three", new Raycaster()), S(this, "world");
    const n = e.renderer;
    if (!n)
      throw new Error("A renderer is needed for the raycaster to work!");
    this.world = e, this.mouse = new Xd(n.three.domElement), this.components = t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.mouse.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Throws a ray from the camera to the mouse or touch event point and returns
   * the first item found. This also takes into account the clipping planes
   * used by the renderer.
   *
   * @param items - the [meshes](https://threejs.org/docs/#api/en/objects/Mesh)
   * to query. If not provided, it will query all the meshes stored in
   * {@link Components.meshes}.
   */
  castRay(t = Array.from(this.world.meshes)) {
    if (!this.world)
      throw new Error("A world is needed to cast rays!");
    const e = this.world.camera.three;
    return this.three.setFromCamera(this.mouse.position, e), this.intersect(t);
  }
  castRayFromVector(t, e, n = Array.from(this.world.meshes)) {
    return this.three.set(t, e), this.intersect(n);
  }
  intersect(t = Array.from(this.world.meshes)) {
    const e = this.three.intersectObjects(t), n = this.filterClippingPlanes(e);
    return n.length > 0 ? n[0] : null;
  }
  filterClippingPlanes(t) {
    if (!this.world.renderer)
      throw new Error("Renderer not found!");
    const e = this.world.renderer.three;
    if (!e.clippingPlanes)
      return t;
    const n = e.clippingPlanes;
    return t.length <= 0 || !n || (n == null ? void 0 : n.length) <= 0 ? t : t.filter(
      (s) => n.every((i) => i.distanceToPoint(s.point) > 0)
    );
  }
};
var Vc = class Gc extends Re {
  constructor(t) {
    super(t), S(this, "enabled", true), S(this, "list", /* @__PURE__ */ new Map()), S(this, "onDisposed", new $()), t.add(Gc.uuid, this);
  }
  get(t) {
    if (this.list.has(t.uuid))
      return this.list.get(t.uuid);
    const e = new Zd(this.components, t);
    return this.list.set(t.uuid, e), t.onDisposed.add(() => {
      this.delete(t);
    }), e;
  }
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
};
S(Vc, "uuid", "d5d8bdf0-db25-4952-b951-b643af207ace");
var Dt = Vc;
var Qd = class extends Da {
  constructor(t) {
    super(t), S(this, "meshes", /* @__PURE__ */ new Set()), S(this, "onAfterUpdate", new $()), S(this, "onBeforeUpdate", new $()), S(this, "isDisposing", false), S(this, "enabled", true), S(this, "uuid", La.create()), S(this, "name"), S(this, "onDisposed", new $()), S(this, "_scene"), S(this, "_camera"), S(this, "_renderer", null);
  }
  get scene() {
    if (!this._scene)
      throw new Error("No scene initialized!");
    return this._scene;
  }
  set scene(t) {
    this._scene = t, t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" });
  }
  get camera() {
    if (!this._camera)
      throw new Error("No camera initialized!");
    return this._camera;
  }
  set camera(t) {
    this._camera = t, t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" });
  }
  get renderer() {
    return this._renderer;
  }
  set renderer(t) {
    this._renderer = t, t && (t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" }));
  }
  update(t) {
    this.enabled && (!this._scene || !this._camera || (this.scene.currentWorld = this, this.camera.currentWorld = this, this.renderer && (this.renderer.currentWorld = this), this.onBeforeUpdate.trigger(), this.scene.isUpdateable() && this.scene.update(t), this.camera.isUpdateable() && this.camera.update(t), this.renderer && this.renderer.update(t), this.onAfterUpdate.trigger()));
  }
  dispose(t = true) {
    if (this.enabled = false, this.isDisposing = true, this.scene.onWorldChanged.trigger({ world: this, action: "removed" }), this.camera.onWorldChanged.trigger({ world: this, action: "removed" }), this.renderer && this.renderer.onWorldChanged.trigger({ world: this, action: "removed" }), t) {
      const e = this.components.get(rn);
      this.scene.dispose(), this.camera.isDisposeable() && this.camera.dispose(), this.renderer && this.renderer.dispose();
      for (const n of this.meshes)
        e.destroy(n);
      this.meshes.clear();
    }
    this._scene = null, this._camera = null, this._renderer = null, this.onDisposed.trigger();
  }
};
var qd = class extends Nd {
  constructor(t, e, n) {
    super(t), S(this, "enabled", true), S(this, "container"), S(this, "three"), S(this, "_canvas"), S(this, "_parameters"), S(this, "_resizeObserver", null), S(this, "onContainerUpdated", new $()), S(this, "_resizing", false), S(this, "resize", (r) => {
      if (this._resizing)
        return;
      this._resizing = true, this.onContainerUpdated.trigger();
      const o = r ? r.x : this.container.clientWidth, l = r ? r.y : this.container.clientHeight;
      this.three.setSize(o, l), this.onResize.trigger(new Vector2(o, l)), this._resizing = false;
    }), S(this, "resizeEvent", () => {
      this.resize();
    }), S(this, "onContextLost", (r) => {
      r.preventDefault(), this.enabled = false;
    }), S(this, "onContextBack", () => {
      this.three.setRenderTarget(null), this.three.dispose(), this.three = new WebGLRenderer({
        canvas: this._canvas,
        antialias: true,
        alpha: true,
        ...this._parameters
      }), this.enabled = true;
    }), this.container = e, this._parameters = n, this.three = new WebGLRenderer({
      antialias: true,
      alpha: true,
      ...n
    }), this.three.setPixelRatio(Math.min(window.devicePixelRatio, 2)), this.setupRenderer(), this.setupEvents(true), this.resize(), this._canvas = this.three.domElement;
    const s = this.three.getContext(), { canvas: i } = s;
    i.addEventListener("webglcontextlost", this.onContextLost, false), i.addEventListener("webglcontextrestored", this.onContextBack, false);
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled || !this.currentWorld)
      return;
    this.onBeforeUpdate.trigger(this);
    const t = this.currentWorld.scene.three, e = this.currentWorld.camera.three;
    this.three.render(t, e), this.onAfterUpdate.trigger(this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false, this.setupEvents(false), this.three.domElement.remove(), this.three.dispose(), this.onResize.reset(), this.onAfterUpdate.reset(), this.onBeforeUpdate.reset(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /** {@link Resizeable.getSize}. */
  getSize() {
    return new Vector2(
      this.three.domElement.clientWidth,
      this.three.domElement.clientHeight
    );
  }
  setupEvents(t) {
    const e = this.three.domElement.parentElement;
    if (!e)
      throw new Error("This renderer needs to have an HTML container!");
    this._resizeObserver && (this._resizeObserver.disconnect(), this._resizeObserver = null), window.removeEventListener("resize", this.resizeEvent), t && (this._resizeObserver = new ResizeObserver(this.resizeEvent), this._resizeObserver.observe(e), window.addEventListener("resize", this.resizeEvent));
  }
  setupRenderer() {
    this.three.localClippingEnabled = true, this.container && this.container.appendChild(this.three.domElement), this.onContainerUpdated.trigger();
  }
};
var ye = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
};
var J = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  OFFSET: 4,
  DOLLY: 8,
  ZOOM: 16,
  TOUCH_ROTATE: 32,
  TOUCH_TRUCK: 64,
  TOUCH_OFFSET: 128,
  TOUCH_DOLLY: 256,
  TOUCH_ZOOM: 512,
  TOUCH_DOLLY_TRUCK: 1024,
  TOUCH_DOLLY_OFFSET: 2048,
  TOUCH_DOLLY_ROTATE: 4096,
  TOUCH_ZOOM_TRUCK: 8192,
  TOUCH_ZOOM_OFFSET: 16384,
  TOUCH_ZOOM_ROTATE: 32768
});
var rs = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function Dn(u) {
  return u.isPerspectiveCamera;
}
function gn(u) {
  return u.isOrthographicCamera;
}
var os = Math.PI * 2;
var Vl = Math.PI / 2;
var Yc = 1e-5;
var Ws = Math.PI / 180;
function Pt(u, t, e) {
  return Math.max(t, Math.min(e, u));
}
function Ue(u, t = Yc) {
  return Math.abs(u) < t;
}
function De(u, t, e = Yc) {
  return Ue(u - t, e);
}
function Gl(u, t) {
  return Math.round(u / t) * t;
}
function Ks(u) {
  return isFinite(u) ? u : u < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function js(u) {
  return Math.abs(u) < Number.MAX_VALUE ? u : u * (1 / 0);
}
function sr(u, t, e, n, s = 1 / 0, i) {
  n = Math.max(1e-4, n);
  const r = 2 / n, o = r * i, l = 1 / (1 + o + 0.48 * o * o + 0.235 * o * o * o);
  let h = u - t;
  const d = t, m = s * n;
  h = Pt(h, -m, m), t = u - h;
  const f = (e.value + r * h) * i;
  e.value = (e.value - r * f) * l;
  let g = t + (h + f) * l;
  return d - u > 0 == g > d && (g = d, e.value = (g - d) / i), g;
}
function Yl(u, t, e, n, s = 1 / 0, i, r) {
  n = Math.max(1e-4, n);
  const o = 2 / n, l = o * i, h = 1 / (1 + l + 0.48 * l * l + 0.235 * l * l * l);
  let d = t.x, m = t.y, f = t.z, g = u.x - d, I = u.y - m, y = u.z - f;
  const x = d, A = m, F = f, P = s * n, b = P * P, O = g * g + I * I + y * y;
  if (O > b) {
    const me = Math.sqrt(O);
    g = g / me * P, I = I / me * P, y = y / me * P;
  }
  d = u.x - g, m = u.y - I, f = u.z - y;
  const k = (e.x + o * g) * i, Y = (e.y + o * I) * i, H = (e.z + o * y) * i;
  e.x = (e.x - o * k) * h, e.y = (e.y - o * Y) * h, e.z = (e.z - o * H) * h, r.x = d + (g + k) * h, r.y = m + (I + Y) * h, r.z = f + (y + H) * h;
  const K = x - u.x, Z = A - u.y, q = F - u.z, ne = r.x - x, se = r.y - A, ue = r.z - F;
  return K * ne + Z * se + q * ue > 0 && (r.x = x, r.y = A, r.z = F, e.x = (r.x - x) / i, e.y = (r.y - A) / i, e.z = (r.z - F) / i), r;
}
function Zo(u, t) {
  t.set(0, 0), u.forEach((e) => {
    t.x += e.clientX, t.y += e.clientY;
  }), t.x /= u.length, t.y /= u.length;
}
function Qo(u, t) {
  return gn(u) ? (console.warn(`${t} is not supported in OrthographicCamera`), true) : false;
}
var Jd = class {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(t, e) {
    const n = this._listeners;
    n[t] === void 0 && (n[t] = []), n[t].indexOf(e) === -1 && n[t].push(e);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(t, e) {
    const n = this._listeners;
    return n[t] !== void 0 && n[t].indexOf(e) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(t, e) {
    const n = this._listeners[t];
    if (n !== void 0) {
      const s = n.indexOf(e);
      s !== -1 && n.splice(s, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(t) {
    if (!t) {
      this._listeners = {};
      return;
    }
    Array.isArray(this._listeners[t]) && (this._listeners[t].length = 0);
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(t) {
    const e = this._listeners[t.type];
    if (e !== void 0) {
      t.target = this;
      const n = e.slice(0);
      for (let s = 0, i = n.length; s < i; s++)
        n[s].call(this, t);
    }
  }
};
var $d = "2.7.3";
var ir = 1 / 8;
var Hc = typeof window < "u";
var ef = Hc && /Mac/.test(navigator.platform);
var tf = !(Hc && "PointerEvent" in window);
var ve;
var Hl;
var rr;
var qo;
var dt;
var be;
var Pe;
var as;
var Xs;
var zt;
var Vt;
var Ln;
var Wl;
var Kl;
var yt;
var Zs;
var ls;
var jl;
var Jo;
var Xl;
var $o;
var ea;
var or;
var oi = class _oi extends Jd {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(t) {
    ve = t.THREE, Hl = Object.freeze(new ve.Vector3(0, 0, 0)), rr = Object.freeze(new ve.Vector3(0, 1, 0)), qo = Object.freeze(new ve.Vector3(0, 0, 1)), dt = new ve.Vector2(), be = new ve.Vector3(), Pe = new ve.Vector3(), as = new ve.Vector3(), Xs = new ve.Vector3(), zt = new ve.Vector3(), Vt = new ve.Vector3(), Ln = new ve.Vector3(), Wl = new ve.Vector3(), Kl = new ve.Vector3(), yt = new ve.Spherical(), Zs = new ve.Spherical(), ls = new ve.Box3(), jl = new ve.Box3(), Jo = new ve.Sphere(), Xl = new ve.Quaternion(), $o = new ve.Quaternion(), ea = new ve.Matrix4(), or = new ve.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return J;
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(t, e) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = false, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = false, this.truckSpeed = 2, this.dollyToCursor = false, this.dragToOffset = false, this.verticalDragToForward = false, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = true, this._state = J.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = true, this._boundaryEnclosesCamera = false, this._needsUpdate = true, this._updatedLastTime = false, this._elementRect = new DOMRect(), this._isDragging = false, this._dragNeedsUpdate = true, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._isUserControllingOffset = false, this._isUserControllingZoom = false, this._lastDollyDirection = rs.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new ve.Vector3(), this._focalOffsetVelocity = new ve.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (b, O, k) => {
      let Y, H;
      if (Dn(this._camera)) {
        const K = be.copy(this._camera.position).sub(this._target), Z = this._camera.getEffectiveFOV() * Ws, q = K.length() * Math.tan(Z * 0.5);
        Y = this.truckSpeed * b * q / this._elementRect.height, H = this.truckSpeed * O * q / this._elementRect.height;
      } else if (gn(this._camera)) {
        const K = this._camera;
        Y = b * (K.right - K.left) / K.zoom / this._elementRect.width, H = O * (K.top - K.bottom) / K.zoom / this._elementRect.height;
      } else
        return;
      this.verticalDragToForward ? (k ? this.setFocalOffset(this._focalOffsetEnd.x + Y, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) : this.truck(Y, 0, true), this.forward(-H, true)) : k ? this.setFocalOffset(this._focalOffsetEnd.x + Y, this._focalOffsetEnd.y + H, this._focalOffsetEnd.z, true) : this.truck(Y, H, true);
    }, this._rotateInternal = (b, O) => {
      const k = os * this.azimuthRotateSpeed * b / this._elementRect.height, Y = os * this.polarRotateSpeed * O / this._elementRect.height;
      this.rotate(k, Y, true);
    }, this._dollyInternal = (b, O, k) => {
      const Y = Math.pow(0.95, -b * this.dollySpeed), H = this._sphericalEnd.radius, K = this._sphericalEnd.radius * Y, Z = Pt(K, this.minDistance, this.maxDistance), q = Z - K;
      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(K, true) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(q, true), this._dollyToNoClamp(Z, true)) : this._dollyToNoClamp(Z, true), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? K : Z) - H, this._dollyControlCoord.set(O, k)), this._lastDollyDirection = Math.sign(-b);
    }, this._zoomInternal = (b, O, k) => {
      const Y = Math.pow(0.95, b * this.dollySpeed), H = this._zoom, K = this._zoom * Y;
      this.zoomTo(K, true), this.dollyToCursor && (this._changedZoom += K - H, this._dollyControlCoord.set(O, k));
    }, typeof ve > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = t, this._yAxisUpSpace = new ve.Quaternion().setFromUnitVectors(this._camera.up, rr), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = J.NONE, this._target = new ve.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new ve.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new ve.Spherical().setFromVector3(be.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [
      new ve.Vector3(),
      new ve.Vector3(),
      new ve.Vector3(),
      new ve.Vector3()
    ], this._updateNearPlaneCorners(), this._boundary = new ve.Box3(new ve.Vector3(-1 / 0, -1 / 0, -1 / 0), new ve.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new ve.Vector2(), this.mouseButtons = {
      left: J.ROTATE,
      middle: J.DOLLY,
      right: J.TRUCK,
      wheel: Dn(this._camera) ? J.DOLLY : gn(this._camera) ? J.ZOOM : J.NONE
    }, this.touches = {
      one: J.TOUCH_ROTATE,
      two: Dn(this._camera) ? J.TOUCH_DOLLY_TRUCK : gn(this._camera) ? J.TOUCH_ZOOM_TRUCK : J.NONE,
      three: J.TOUCH_TRUCK
    };
    const n = new ve.Vector2(), s = new ve.Vector2(), i = new ve.Vector2(), r = (b) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const Y = this._domElement.getBoundingClientRect(), H = b.clientX / Y.width, K = b.clientY / Y.height;
        if (H < this._interactiveArea.left || H > this._interactiveArea.right || K < this._interactiveArea.top || K > this._interactiveArea.bottom)
          return;
      }
      const O = b.pointerType !== "mouse" ? null : (b.buttons & ye.LEFT) === ye.LEFT ? ye.LEFT : (b.buttons & ye.MIDDLE) === ye.MIDDLE ? ye.MIDDLE : (b.buttons & ye.RIGHT) === ye.RIGHT ? ye.RIGHT : null;
      if (O !== null) {
        const Y = this._findPointerByMouseButton(O);
        Y && this._disposePointer(Y);
      }
      if ((b.buttons & ye.LEFT) === ye.LEFT && this._lockedPointer)
        return;
      const k = {
        pointerId: b.pointerId,
        clientX: b.clientX,
        clientY: b.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: O
      };
      this._activePointers.push(k), this._domElement.ownerDocument.removeEventListener("pointermove", l, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", d), this._domElement.ownerDocument.addEventListener("pointermove", l, { passive: false }), this._domElement.ownerDocument.addEventListener("pointerup", d), this._isDragging = true, y(b);
    }, o = (b) => {
      if (!this._enabled || !this._domElement || this._lockedPointer)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const Y = this._domElement.getBoundingClientRect(), H = b.clientX / Y.width, K = b.clientY / Y.height;
        if (H < this._interactiveArea.left || H > this._interactiveArea.right || K < this._interactiveArea.top || K > this._interactiveArea.bottom)
          return;
      }
      const O = (b.buttons & ye.LEFT) === ye.LEFT ? ye.LEFT : (b.buttons & ye.MIDDLE) === ye.MIDDLE ? ye.MIDDLE : (b.buttons & ye.RIGHT) === ye.RIGHT ? ye.RIGHT : null;
      if (O !== null) {
        const Y = this._findPointerByMouseButton(O);
        Y && this._disposePointer(Y);
      }
      const k = {
        pointerId: 1,
        clientX: b.clientX,
        clientY: b.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: (b.buttons & ye.LEFT) === ye.LEFT ? ye.LEFT : (b.buttons & ye.MIDDLE) === ye.LEFT ? ye.MIDDLE : (b.buttons & ye.RIGHT) === ye.LEFT ? ye.RIGHT : null
      };
      this._activePointers.push(k), this._domElement.ownerDocument.removeEventListener("mousemove", h), this._domElement.ownerDocument.removeEventListener("mouseup", m), this._domElement.ownerDocument.addEventListener("mousemove", h), this._domElement.ownerDocument.addEventListener("mouseup", m), this._isDragging = true, y(b);
    }, l = (b) => {
      b.cancelable && b.preventDefault();
      const O = b.pointerId, k = this._lockedPointer || this._findPointerById(O);
      if (k) {
        if (k.clientX = b.clientX, k.clientY = b.clientY, k.deltaX = b.movementX, k.deltaY = b.movementY, this._state = 0, b.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          (!this._isDragging && this._lockedPointer || this._isDragging && (b.buttons & ye.LEFT) === ye.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (b.buttons & ye.MIDDLE) === ye.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (b.buttons & ye.RIGHT) === ye.RIGHT && (this._state = this._state | this.mouseButtons.right);
        x();
      }
    }, h = (b) => {
      const O = this._lockedPointer || this._findPointerById(1);
      O && (O.clientX = b.clientX, O.clientY = b.clientY, O.deltaX = b.movementX, O.deltaY = b.movementY, this._state = 0, (this._lockedPointer || (b.buttons & ye.LEFT) === ye.LEFT) && (this._state = this._state | this.mouseButtons.left), (b.buttons & ye.MIDDLE) === ye.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (b.buttons & ye.RIGHT) === ye.RIGHT && (this._state = this._state | this.mouseButtons.right), x());
    }, d = (b) => {
      const O = this._findPointerById(b.pointerId);
      if (!(O && O === this._lockedPointer)) {
        if (O && this._disposePointer(O), b.pointerType === "touch")
          switch (this._activePointers.length) {
            case 0:
              this._state = J.NONE;
              break;
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          this._state = J.NONE;
        A();
      }
    }, m = () => {
      const b = this._findPointerById(1);
      b && b === this._lockedPointer || (b && this._disposePointer(b), this._state = J.NONE, A());
    };
    let f = -1;
    const g = (b) => {
      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === J.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const K = this._domElement.getBoundingClientRect(), Z = b.clientX / K.width, q = b.clientY / K.height;
        if (Z < this._interactiveArea.left || Z > this._interactiveArea.right || q < this._interactiveArea.top || q > this._interactiveArea.bottom)
          return;
      }
      if (b.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === J.ROTATE || this.mouseButtons.wheel === J.TRUCK) {
        const K = performance.now();
        f - K < 1e3 && this._getClientRect(this._elementRect), f = K;
      }
      const O = ef ? -1 : -3, k = b.deltaMode === 1 ? b.deltaY / O : b.deltaY / (O * 10), Y = this.dollyToCursor ? (b.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, H = this.dollyToCursor ? (b.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case J.ROTATE: {
          this._rotateInternal(b.deltaX, b.deltaY), this._isUserControllingRotate = true;
          break;
        }
        case J.TRUCK: {
          this._truckInternal(b.deltaX, b.deltaY, false), this._isUserControllingTruck = true;
          break;
        }
        case J.OFFSET: {
          this._truckInternal(b.deltaX, b.deltaY, true), this._isUserControllingOffset = true;
          break;
        }
        case J.DOLLY: {
          this._dollyInternal(-k, Y, H), this._isUserControllingDolly = true;
          break;
        }
        case J.ZOOM: {
          this._zoomInternal(-k, Y, H), this._isUserControllingZoom = true;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    }, I = (b) => {
      if (!(!this._domElement || !this._enabled)) {
        if (this.mouseButtons.right === _oi.ACTION.NONE) {
          const O = b instanceof PointerEvent ? b.pointerId : 0, k = this._findPointerById(O);
          k && this._disposePointer(k), this._domElement.ownerDocument.removeEventListener("pointermove", l, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", d), this._domElement.ownerDocument.removeEventListener("mousemove", h), this._domElement.ownerDocument.removeEventListener("mouseup", m);
          return;
        }
        b.preventDefault();
      }
    }, y = (b) => {
      if (this._enabled) {
        if (Zo(this._activePointers, dt), this._getClientRect(this._elementRect), n.copy(dt), s.copy(dt), this._activePointers.length >= 2) {
          const O = dt.x - this._activePointers[1].clientX, k = dt.y - this._activePointers[1].clientY, Y = Math.sqrt(O * O + k * k);
          i.set(0, Y);
          const H = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, K = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
          s.set(H, K);
        }
        if (this._state = 0, !b)
          this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
        else if ("pointerType" in b && b.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          !this._lockedPointer && (b.buttons & ye.LEFT) === ye.LEFT && (this._state = this._state | this.mouseButtons.left), (b.buttons & ye.MIDDLE) === ye.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (b.buttons & ye.RIGHT) === ye.RIGHT && (this._state = this._state | this.mouseButtons.right);
        ((this._state & J.ROTATE) === J.ROTATE || (this._state & J.TOUCH_ROTATE) === J.TOUCH_ROTATE || (this._state & J.TOUCH_DOLLY_ROTATE) === J.TOUCH_DOLLY_ROTATE || (this._state & J.TOUCH_ZOOM_ROTATE) === J.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & J.TRUCK) === J.TRUCK || (this._state & J.TOUCH_TRUCK) === J.TOUCH_TRUCK || (this._state & J.TOUCH_DOLLY_TRUCK) === J.TOUCH_DOLLY_TRUCK || (this._state & J.TOUCH_ZOOM_TRUCK) === J.TOUCH_ZOOM_TRUCK) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & J.DOLLY) === J.DOLLY || (this._state & J.TOUCH_DOLLY) === J.TOUCH_DOLLY || (this._state & J.TOUCH_DOLLY_TRUCK) === J.TOUCH_DOLLY_TRUCK || (this._state & J.TOUCH_DOLLY_OFFSET) === J.TOUCH_DOLLY_OFFSET || (this._state & J.TOUCH_DOLLY_ROTATE) === J.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & J.ZOOM) === J.ZOOM || (this._state & J.TOUCH_ZOOM) === J.TOUCH_ZOOM || (this._state & J.TOUCH_ZOOM_TRUCK) === J.TOUCH_ZOOM_TRUCK || (this._state & J.TOUCH_ZOOM_OFFSET) === J.TOUCH_ZOOM_OFFSET || (this._state & J.TOUCH_ZOOM_ROTATE) === J.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & J.OFFSET) === J.OFFSET || (this._state & J.TOUCH_OFFSET) === J.TOUCH_OFFSET || (this._state & J.TOUCH_DOLLY_OFFSET) === J.TOUCH_DOLLY_OFFSET || (this._state & J.TOUCH_ZOOM_OFFSET) === J.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
      }
    }, x = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = false, Zo(this._activePointers, dt);
      const b = this._domElement && document.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, O = b ? -b.deltaX : s.x - dt.x, k = b ? -b.deltaY : s.y - dt.y;
      if (s.copy(dt), ((this._state & J.ROTATE) === J.ROTATE || (this._state & J.TOUCH_ROTATE) === J.TOUCH_ROTATE || (this._state & J.TOUCH_DOLLY_ROTATE) === J.TOUCH_DOLLY_ROTATE || (this._state & J.TOUCH_ZOOM_ROTATE) === J.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(O, k), this._isUserControllingRotate = true), (this._state & J.DOLLY) === J.DOLLY || (this._state & J.ZOOM) === J.ZOOM) {
        const Y = this.dollyToCursor ? (n.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, H = this.dollyToCursor ? (n.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, K = this.dollyDragInverted ? -1 : 1;
        (this._state & J.DOLLY) === J.DOLLY ? (this._dollyInternal(K * k * ir, Y, H), this._isUserControllingDolly = true) : (this._zoomInternal(K * k * ir, Y, H), this._isUserControllingZoom = true);
      }
      if ((this._state & J.TOUCH_DOLLY) === J.TOUCH_DOLLY || (this._state & J.TOUCH_ZOOM) === J.TOUCH_ZOOM || (this._state & J.TOUCH_DOLLY_TRUCK) === J.TOUCH_DOLLY_TRUCK || (this._state & J.TOUCH_ZOOM_TRUCK) === J.TOUCH_ZOOM_TRUCK || (this._state & J.TOUCH_DOLLY_OFFSET) === J.TOUCH_DOLLY_OFFSET || (this._state & J.TOUCH_ZOOM_OFFSET) === J.TOUCH_ZOOM_OFFSET || (this._state & J.TOUCH_DOLLY_ROTATE) === J.TOUCH_DOLLY_ROTATE || (this._state & J.TOUCH_ZOOM_ROTATE) === J.TOUCH_ZOOM_ROTATE) {
        const Y = dt.x - this._activePointers[1].clientX, H = dt.y - this._activePointers[1].clientY, K = Math.sqrt(Y * Y + H * H), Z = i.y - K;
        i.set(0, K);
        const q = this.dollyToCursor ? (s.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, ne = this.dollyToCursor ? (s.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & J.TOUCH_DOLLY) === J.TOUCH_DOLLY || (this._state & J.TOUCH_DOLLY_ROTATE) === J.TOUCH_DOLLY_ROTATE || (this._state & J.TOUCH_DOLLY_TRUCK) === J.TOUCH_DOLLY_TRUCK || (this._state & J.TOUCH_DOLLY_OFFSET) === J.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(Z * ir, q, ne), this._isUserControllingDolly = true) : (this._zoomInternal(Z * ir, q, ne), this._isUserControllingZoom = true);
      }
      ((this._state & J.TRUCK) === J.TRUCK || (this._state & J.TOUCH_TRUCK) === J.TOUCH_TRUCK || (this._state & J.TOUCH_DOLLY_TRUCK) === J.TOUCH_DOLLY_TRUCK || (this._state & J.TOUCH_ZOOM_TRUCK) === J.TOUCH_ZOOM_TRUCK) && (this._truckInternal(O, k, false), this._isUserControllingTruck = true), ((this._state & J.OFFSET) === J.OFFSET || (this._state & J.TOUCH_OFFSET) === J.TOUCH_OFFSET || (this._state & J.TOUCH_DOLLY_OFFSET) === J.TOUCH_DOLLY_OFFSET || (this._state & J.TOUCH_ZOOM_OFFSET) === J.TOUCH_ZOOM_OFFSET) && (this._truckInternal(O, k, true), this._isUserControllingOffset = true), this.dispatchEvent({ type: "control" });
    }, A = () => {
      Zo(this._activePointers, dt), s.copy(dt), this._dragNeedsUpdate = false, (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = false), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", l, { passive: false }), this._domElement.ownerDocument.removeEventListener("mousemove", h), this._domElement.ownerDocument.removeEventListener("pointerup", d), this._domElement.ownerDocument.removeEventListener("mouseup", m), this.dispatchEvent({ type: "controlend" }));
    };
    this.lockPointer = () => {
      !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", l, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", d), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", F), this._domElement.ownerDocument.addEventListener("pointerlockerror", P), this._domElement.ownerDocument.addEventListener("pointermove", l, { passive: false }), this._domElement.ownerDocument.addEventListener("pointerup", d), y());
    }, this.unlockPointer = () => {
      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), document.exitPointerLock(), this.cancel(), this._domElement && (this._domElement.ownerDocument.removeEventListener("pointerlockchange", F), this._domElement.ownerDocument.removeEventListener("pointerlockerror", P));
    };
    const F = () => {
      this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer();
    }, P = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (b) => {
      this._domElement = b, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", r), tf && this._domElement.addEventListener("mousedown", o), this._domElement.addEventListener("pointercancel", d), this._domElement.addEventListener("wheel", g, { passive: false }), this._domElement.addEventListener("contextmenu", I);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", r), this._domElement.removeEventListener("mousedown", o), this._domElement.removeEventListener("pointercancel", d), this._domElement.removeEventListener("wheel", g, { passive: false }), this._domElement.removeEventListener("contextmenu", I), this._domElement.ownerDocument.removeEventListener("pointermove", l, { passive: false }), this._domElement.ownerDocument.removeEventListener("mousemove", h), this._domElement.ownerDocument.removeEventListener("pointerup", d), this._domElement.ownerDocument.removeEventListener("mouseup", m), this._domElement.ownerDocument.removeEventListener("pointerlockchange", F), this._domElement.ownerDocument.removeEventListener("pointerlockerror", P));
    }, this.cancel = () => {
      this._state !== J.NONE && (this._state = J.NONE, this._activePointers.length = 0, A());
    }, e && this.connect(e), this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(t) {
    this._camera = t, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    this._enabled = t, this._domElement && (t ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(t) {
    this._spherical.radius === t && this._sphericalEnd.radius === t || (this._spherical.radius = t, this._sphericalEnd.radius = t, this._needsUpdate = true);
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(t) {
    this._spherical.theta === t && this._sphericalEnd.theta === t || (this._spherical.theta = t, this._sphericalEnd.theta = t, this._needsUpdate = true);
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(t) {
    this._spherical.phi === t && this._sphericalEnd.phi === t || (this._spherical.phi = t, this._sphericalEnd.phi = t, this._needsUpdate = true);
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(t) {
    this._boundaryEnclosesCamera = t, this._needsUpdate = true;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(t) {
    this._interactiveArea.width = Pt(t.width, 0, 1), this._interactiveArea.height = Pt(t.height, 0, 1), this._interactiveArea.x = Pt(t.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = Pt(t.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. ¹ |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera. ¹ |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` ². |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(t, e) {
    super.addEventListener(t, e);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(t, e) {
    super.removeEventListener(t, e);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(t, e, n = false) {
    return this.rotateTo(this._sphericalEnd.theta + t, this._sphericalEnd.phi + e, n);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(t, e = false) {
    return this.rotateTo(t, this._sphericalEnd.phi, e);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(t, e = false) {
    return this.rotateTo(this._sphericalEnd.theta, t, e);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0º
   *         \
   * 90º -----+----- -90º
   *           \
   *           180º
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0º                     |
   * | left      | 90º (`Math.PI / 2`)    |
   * | right     | -90º (`- Math.PI / 2`) |
   * | back      | 180º (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180º
   *      |
   *      90º
   *      |
   *      0º
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180º (`Math.PI`)       |
   * | horizontal from view | 90º (`Math.PI / 2`)    |
   * | bottom/floor         | 0º                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(t, e, n = false) {
    this._isUserControllingRotate = false;
    const s = Pt(t, this.minAzimuthAngle, this.maxAzimuthAngle), i = Pt(e, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = s, this._sphericalEnd.phi = i, this._sphericalEnd.makeSafe(), this._needsUpdate = true, n || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    const r = !n || De(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && De(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(t, e = false) {
    return this.dollyTo(this._sphericalEnd.radius - t, e);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(t, e = false) {
    return this._isUserControllingDolly = false, this._lastDollyDirection = rs.NONE, this._changedDolly = 0, this._dollyToNoClamp(Pt(t, this.minDistance, this.maxDistance), e);
  }
  _dollyToNoClamp(t, e = false) {
    const n = this._sphericalEnd.radius;
    if (this.colliderMeshes.length >= 1) {
      const i = this._collisionTest(), r = De(i, this._spherical.radius);
      if (!(n > t) && r)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(t, i);
    } else
      this._sphericalEnd.radius = t;
    this._needsUpdate = true, e || (this._spherical.radius = this._sphericalEnd.radius);
    const s = !e || De(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(s);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(t, e = false) {
    this._targetEnd.add(this._getCameraDirection(Xs).multiplyScalar(t)), e || this._target.copy(this._targetEnd);
    const n = !e || De(this._target.x, this._targetEnd.x, this.restThreshold) && De(this._target.y, this._targetEnd.y, this.restThreshold) && De(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(t, e = false) {
    return this.zoomTo(this._zoomEnd + t, e);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(t, e = false) {
    this._isUserControllingZoom = false, this._zoomEnd = Pt(t, this.minZoom, this.maxZoom), this._needsUpdate = true, e || (this._zoom = this._zoomEnd);
    const n = !e || De(this._zoom, this._zoomEnd, this.restThreshold);
    return this._changedZoom = 0, this._createOnRestPromise(n);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(t, e, n = false) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(t, e, n);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(t, e, n = false) {
    this._camera.updateMatrix(), zt.setFromMatrixColumn(this._camera.matrix, 0), Vt.setFromMatrixColumn(this._camera.matrix, 1), zt.multiplyScalar(t), Vt.multiplyScalar(-e);
    const s = be.copy(zt).add(Vt), i = Pe.copy(this._targetEnd).add(s);
    return this.moveTo(i.x, i.y, i.z, n);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(t, e = false) {
    be.setFromMatrixColumn(this._camera.matrix, 0), be.crossVectors(this._camera.up, be), be.multiplyScalar(t);
    const n = Pe.copy(this._targetEnd).add(be);
    return this.moveTo(n.x, n.y, n.z, e);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(t, e = false) {
    return be.copy(this._camera.up).multiplyScalar(t), this.moveTo(this._targetEnd.x + be.x, this._targetEnd.y + be.y, this._targetEnd.z + be.z, e);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(t, e, n, s = false) {
    this._isUserControllingTruck = false;
    const i = be.set(t, e, n).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, i, this.boundaryFriction), this._needsUpdate = true, s || this._target.copy(this._targetEnd);
    const r = !s || De(this._target.x, this._targetEnd.x, this.restThreshold) && De(this._target.y, this._targetEnd.y, this.restThreshold) && De(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(t, e, n, s = false) {
    const i = be.set(t, e, n).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius);
    return this.setPosition(i.x, i.y, i.z, s);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(t, e, { cover: n = false, paddingLeft: s = 0, paddingRight: i = 0, paddingBottom: r = 0, paddingTop: o = 0 } = {}) {
    const l = [], h = t.isBox3 ? ls.copy(t) : ls.setFromObject(t);
    h.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    const d = Gl(this._sphericalEnd.theta, Vl), m = Gl(this._sphericalEnd.phi, Vl);
    l.push(this.rotateTo(d, m, e));
    const f = be.setFromSpherical(this._sphericalEnd).normalize(), g = Xl.setFromUnitVectors(f, qo), I = De(Math.abs(f.y), 1);
    I && g.multiply($o.setFromAxisAngle(rr, d)), g.multiply(this._yAxisUpSpaceInverse);
    const y = jl.makeEmpty();
    Pe.copy(h.min).applyQuaternion(g), y.expandByPoint(Pe), Pe.copy(h.min).setX(h.max.x).applyQuaternion(g), y.expandByPoint(Pe), Pe.copy(h.min).setY(h.max.y).applyQuaternion(g), y.expandByPoint(Pe), Pe.copy(h.max).setZ(h.min.z).applyQuaternion(g), y.expandByPoint(Pe), Pe.copy(h.min).setZ(h.max.z).applyQuaternion(g), y.expandByPoint(Pe), Pe.copy(h.max).setY(h.min.y).applyQuaternion(g), y.expandByPoint(Pe), Pe.copy(h.max).setX(h.min.x).applyQuaternion(g), y.expandByPoint(Pe), Pe.copy(h.max).applyQuaternion(g), y.expandByPoint(Pe), y.min.x -= s, y.min.y -= r, y.max.x += i, y.max.y += o, g.setFromUnitVectors(qo, f), I && g.premultiply($o.invert()), g.premultiply(this._yAxisUpSpace);
    const x = y.getSize(be), A = y.getCenter(Pe).applyQuaternion(g);
    if (Dn(this._camera)) {
      const F = this.getDistanceToFitBox(x.x, x.y, x.z, n);
      l.push(this.moveTo(A.x, A.y, A.z, e)), l.push(this.dollyTo(F, e)), l.push(this.setFocalOffset(0, 0, 0, e));
    } else if (gn(this._camera)) {
      const F = this._camera, P = F.right - F.left, b = F.top - F.bottom, O = n ? Math.max(P / x.x, b / x.y) : Math.min(P / x.x, b / x.y);
      l.push(this.moveTo(A.x, A.y, A.z, e)), l.push(this.zoomTo(O, e)), l.push(this.setFocalOffset(0, 0, 0, e));
    }
    return Promise.all(l);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(t, e) {
    const n = [], s = t instanceof ve.Sphere ? Jo.copy(t) : _oi.createBoundingSphere(t, Jo);
    if (n.push(this.moveTo(s.center.x, s.center.y, s.center.z, e)), Dn(this._camera)) {
      const i = this.getDistanceToFitSphere(s.radius);
      n.push(this.dollyTo(i, e));
    } else if (gn(this._camera)) {
      const i = this._camera.right - this._camera.left, r = this._camera.top - this._camera.bottom, o = 2 * s.radius, l = Math.min(i / o, r / o);
      n.push(this.zoomTo(l, e));
    }
    return n.push(this.setFocalOffset(0, 0, 0, e)), Promise.all(n);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(t, e, n, s, i, r, o = false) {
    this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._lastDollyDirection = rs.NONE, this._changedDolly = 0;
    const l = Pe.set(s, i, r), h = be.set(t, e, n);
    this._targetEnd.copy(l), this._sphericalEnd.setFromVector3(h.sub(l).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = true, o || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const d = !o || De(this._target.x, this._targetEnd.x, this.restThreshold) && De(this._target.y, this._targetEnd.y, this.restThreshold) && De(this._target.z, this._targetEnd.z, this.restThreshold) && De(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && De(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && De(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(d);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(t, e, n, s, i, r, o, l, h, d, m, f, g, I = false) {
    this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._lastDollyDirection = rs.NONE, this._changedDolly = 0;
    const y = be.set(s, i, r), x = Pe.set(t, e, n);
    yt.setFromVector3(x.sub(y).applyQuaternion(this._yAxisUpSpace));
    const A = as.set(d, m, f), F = Pe.set(o, l, h);
    Zs.setFromVector3(F.sub(A).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(y.lerp(A, g));
    const P = Zs.theta - yt.theta, b = Zs.phi - yt.phi, O = Zs.radius - yt.radius;
    this._sphericalEnd.set(yt.radius + O * g, yt.phi + b * g, yt.theta + P * g), this.normalizeRotations(), this._needsUpdate = true, I || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const k = !I || De(this._target.x, this._targetEnd.x, this.restThreshold) && De(this._target.y, this._targetEnd.y, this.restThreshold) && De(this._target.z, this._targetEnd.z, this.restThreshold) && De(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && De(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && De(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(k);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(t, e, n, s = false) {
    return this.setLookAt(t, e, n, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, s);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(t, e, n, s = false) {
    const i = this.getPosition(be), r = this.setLookAt(i.x, i.y, i.z, t, e, n, s);
    return this._sphericalEnd.phi = Pt(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), r;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(t, e, n, s = false) {
    this._isUserControllingOffset = false, this._focalOffsetEnd.set(t, e, n), this._needsUpdate = true, s || this._focalOffset.copy(this._focalOffsetEnd);
    const i = !s || De(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && De(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && De(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(i);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(t, e, n) {
    this._camera.updateMatrixWorld(), zt.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), Vt.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), Ln.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const s = be.set(t, e, n), i = s.distanceTo(this._camera.position), r = s.sub(this._camera.position);
    zt.multiplyScalar(r.x), Vt.multiplyScalar(r.y), Ln.multiplyScalar(r.z), be.copy(zt).add(Vt).add(Ln), be.z = be.z + i, this.dollyTo(i, false), this.setFocalOffset(-be.x, be.y, -be.z, false), this.moveTo(t, e, n, false);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(t) {
    if (!t) {
      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = true;
      return;
    }
    this._boundary.copy(t), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = true;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(t, e, n, s) {
    if (t === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new ve.Vector4(), typeof t == "number" ? this._viewport.set(t, e, n, s) : this._viewport.copy(t);
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(t, e, n, s = false) {
    if (Qo(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const i = t / e, r = this._camera.getEffectiveFOV() * Ws, o = this._camera.aspect;
    return ((s ? i > o : i < o) ? e : t / o) * 0.5 / Math.tan(r * 0.5) + n * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(t) {
    if (Qo(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const e = this._camera.getEffectiveFOV() * Ws, n = Math.atan(Math.tan(e * 0.5) * this._camera.aspect) * 2, s = 1 < this._camera.aspect ? e : n;
    return t / Math.sin(s * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(t, e = true) {
    return (t && t.isVector3 ? t : new ve.Vector3()).copy(e ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(t, e = true) {
    return (t && t.isVector3 ? t : new ve.Vector3()).setFromSpherical(e ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(e ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(t, e = true) {
    return (t && t instanceof ve.Spherical ? t : new ve.Spherical()).copy(e ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(t, e = true) {
    return (t && t.isVector3 ? t : new ve.Vector3()).copy(e ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % os, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += os), this._spherical.theta += os * Math.round((this._sphericalEnd.theta - this._spherical.theta) / os);
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(t = false) {
    if (!De(this._camera.up.x, this._cameraUp0.x) || !De(this._camera.up.y, this._cameraUp0.y) || !De(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const n = this.getPosition(be);
      this.updateCameraUp(), this.setPosition(n.x, n.y, n.z);
    }
    const e = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, t),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, t),
      this.zoomTo(this._zoom0, t)
    ];
    return Promise.all(e);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, rr), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const t = be.subVectors(this._target, this._camera.position).normalize(), e = Pe.crossVectors(t, this._camera.up);
    this._camera.up.crossVectors(e, t).normalize(), this._camera.updateMatrixWorld();
    const n = this.getPosition(be);
    this.updateCameraUp(), this.setPosition(n.x, n.y, n.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(t) {
    const e = this._sphericalEnd.theta - this._spherical.theta, n = this._sphericalEnd.phi - this._spherical.phi, s = this._sphericalEnd.radius - this._spherical.radius, i = Wl.subVectors(this._targetEnd, this._target), r = Kl.subVectors(this._focalOffsetEnd, this._focalOffset), o = this._zoomEnd - this._zoom;
    if (Ue(e))
      this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
    else {
      const d = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = sr(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, d, 1 / 0, t), this._needsUpdate = true;
    }
    if (Ue(n))
      this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
    else {
      const d = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = sr(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, d, 1 / 0, t), this._needsUpdate = true;
    }
    if (Ue(s))
      this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
    else {
      const d = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = sr(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, d, this.maxSpeed, t), this._needsUpdate = true;
    }
    if (Ue(i.x) && Ue(i.y) && Ue(i.z))
      this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
    else {
      const d = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      Yl(this._target, this._targetEnd, this._targetVelocity, d, this.maxSpeed, t, this._target), this._needsUpdate = true;
    }
    if (Ue(r.x) && Ue(r.y) && Ue(r.z))
      this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
    else {
      const d = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      Yl(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, d, this.maxSpeed, t, this._focalOffset), this._needsUpdate = true;
    }
    if (Ue(o))
      this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
    else {
      const d = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = sr(this._zoom, this._zoomEnd, this._zoomVelocity, d, 1 / 0, t);
    }
    if (this.dollyToCursor) {
      if (Dn(this._camera) && this._changedDolly !== 0) {
        const d = this._spherical.radius - this._lastDistance, m = this._camera, f = this._getCameraDirection(Xs), g = be.copy(f).cross(m.up).normalize();
        g.lengthSq() === 0 && (g.x = 1);
        const I = Pe.crossVectors(g, f), y = this._sphericalEnd.radius * Math.tan(m.getEffectiveFOV() * Ws * 0.5), x = (this._sphericalEnd.radius - d - this._sphericalEnd.radius) / this._sphericalEnd.radius, A = as.copy(this._targetEnd).add(g.multiplyScalar(this._dollyControlCoord.x * y * m.aspect)).add(I.multiplyScalar(this._dollyControlCoord.y * y)), F = be.copy(this._targetEnd).lerp(A, x), P = this._lastDollyDirection === rs.IN && this._spherical.radius <= this.minDistance, b = this._lastDollyDirection === rs.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (P || b)) {
          this._sphericalEnd.radius -= d, this._spherical.radius -= d;
          const k = Pe.copy(f).multiplyScalar(-d);
          F.add(k);
        }
        this._boundary.clampPoint(F, F);
        const O = Pe.subVectors(F, this._targetEnd);
        this._targetEnd.copy(F), this._target.add(O), this._changedDolly -= d, Ue(this._changedDolly) && (this._changedDolly = 0);
      } else if (gn(this._camera) && this._changedZoom !== 0) {
        const d = this._zoom - this._lastZoom, m = this._camera, f = be.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (m.near + m.far) / (m.near - m.far)).unproject(m), g = Pe.set(0, 0, -1).applyQuaternion(m.quaternion), I = as.copy(f).add(g.multiplyScalar(-f.dot(m.up))), y = -(this._zoom - d - this._zoom) / this._zoom, x = this._getCameraDirection(Xs), A = this._targetEnd.dot(x), F = be.copy(this._targetEnd).lerp(I, y), P = F.dot(x), b = x.multiplyScalar(P - A);
        F.sub(b), this._boundary.clampPoint(F, F);
        const O = Pe.subVectors(F, this._targetEnd);
        this._targetEnd.copy(F), this._target.add(O), this._changedZoom -= d, Ue(this._changedZoom) && (this._changedZoom = 0);
      }
    }
    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true), this._dragNeedsUpdate = true;
    const l = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, l), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!Ue(this._focalOffset.x) || !Ue(this._focalOffset.y) || !Ue(this._focalOffset.z)) && (this._camera.updateMatrixWorld(), zt.setFromMatrixColumn(this._camera.matrix, 0), Vt.setFromMatrixColumn(this._camera.matrix, 1), Ln.setFromMatrixColumn(this._camera.matrix, 2), zt.multiplyScalar(this._focalOffset.x), Vt.multiplyScalar(-this._focalOffset.y), Ln.multiplyScalar(this._focalOffset.z), be.copy(zt).add(Vt).add(Ln), this._camera.position.add(be)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), be.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const h = this._needsUpdate;
    return h && !this._updatedLastTime ? (this._hasRested = false, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : h ? (this.dispatchEvent({ type: "update" }), Ue(e, this.restThreshold) && Ue(n, this.restThreshold) && Ue(s, this.restThreshold) && Ue(i.x, this.restThreshold) && Ue(i.y, this.restThreshold) && Ue(i.z, this.restThreshold) && Ue(r.x, this.restThreshold) && Ue(r.y, this.restThreshold) && Ue(r.z, this.restThreshold) && Ue(o, this.restThreshold) && !this._hasRested && (this._hasRested = true, this.dispatchEvent({ type: "rest" }))) : !h && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = h, this._needsUpdate = false, h;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: Ks(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: Ks(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: Ks(this.maxPolarAngle),
      minAzimuthAngle: Ks(this.minAzimuthAngle),
      maxAzimuthAngle: Ks(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      verticalDragToForward: this.verticalDragToForward,
      target: this._targetEnd.toArray(),
      position: be.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(t, e = false) {
    const n = JSON.parse(t);
    this.enabled = n.enabled, this.minDistance = n.minDistance, this.maxDistance = js(n.maxDistance), this.minZoom = n.minZoom, this.maxZoom = js(n.maxZoom), this.minPolarAngle = n.minPolarAngle, this.maxPolarAngle = js(n.maxPolarAngle), this.minAzimuthAngle = js(n.minAzimuthAngle), this.maxAzimuthAngle = js(n.maxAzimuthAngle), this.smoothTime = n.smoothTime, this.draggingSmoothTime = n.draggingSmoothTime, this.dollySpeed = n.dollySpeed, this.truckSpeed = n.truckSpeed, this.dollyToCursor = n.dollyToCursor, this.verticalDragToForward = n.verticalDragToForward, this._target0.fromArray(n.target0), this._position0.fromArray(n.position0), this._zoom0 = n.zoom0, this._focalOffset0.fromArray(n.focalOffset0), this.moveTo(n.target[0], n.target[1], n.target[2], e), yt.setFromVector3(be.fromArray(n.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(yt.theta, yt.phi, e), this.dollyTo(yt.radius, e), this.zoomTo(n.zoom, e), this.setFocalOffset(n.focalOffset[0], n.focalOffset[1], n.focalOffset[2], e), this._needsUpdate = true;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(t) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    t.setAttribute("data-camera-controls-version", $d), this._addAllEventListeners(t), this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0);
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners(), this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(t) {
    return t.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(t) {
    return this._getTargetDirection(t).negate();
  }
  _findPointerById(t) {
    return this._activePointers.find((e) => e.pointerId === t);
  }
  _findPointerByMouseButton(t) {
    return this._activePointers.find((e) => e.mouseButton === t);
  }
  _disposePointer(t) {
    this._activePointers.splice(this._activePointers.indexOf(t), 1);
  }
  _encloseToBoundary(t, e, n) {
    const s = e.lengthSq();
    if (s === 0)
      return t;
    const i = Pe.copy(e).add(t), r = this._boundary.clampPoint(i, as).sub(i), o = r.lengthSq();
    if (o === 0)
      return t.add(e);
    if (o === s)
      return t;
    if (n === 0)
      return t.add(e).add(r);
    {
      const l = 1 + n * o / e.dot(r);
      return t.add(Pe.copy(e).multiplyScalar(l)).add(r.multiplyScalar(1 - n));
    }
  }
  _updateNearPlaneCorners() {
    if (Dn(this._camera)) {
      const t = this._camera, e = t.near, n = t.getEffectiveFOV() * Ws, s = Math.tan(n * 0.5) * e, i = s * t.aspect;
      this._nearPlaneCorners[0].set(-i, -s, 0), this._nearPlaneCorners[1].set(i, -s, 0), this._nearPlaneCorners[2].set(i, s, 0), this._nearPlaneCorners[3].set(-i, s, 0);
    } else if (gn(this._camera)) {
      const t = this._camera, e = 1 / t.zoom, n = t.left * e, s = t.right * e, i = t.top * e, r = t.bottom * e;
      this._nearPlaneCorners[0].set(n, i, 0), this._nearPlaneCorners[1].set(s, i, 0), this._nearPlaneCorners[2].set(s, r, 0), this._nearPlaneCorners[3].set(n, r, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let t = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || Qo(this._camera, "_collisionTest"))
      return t;
    const e = this._getTargetDirection(Xs);
    ea.lookAt(Hl, e, this._camera.up);
    for (let n = 0; n < 4; n++) {
      const s = Pe.copy(this._nearPlaneCorners[n]);
      s.applyMatrix4(ea);
      const i = as.addVectors(this._target, s);
      or.set(i, e), or.far = this._spherical.radius + 1;
      const r = or.intersectObjects(this.colliderMeshes);
      r.length !== 0 && r[0].distance < t && (t = r[0].distance);
    }
    return t;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(t) {
    if (!this._domElement)
      return;
    const e = this._domElement.getBoundingClientRect();
    return t.x = e.left, t.y = e.top, this._viewport ? (t.x += this._viewport.x, t.y += e.height - this._viewport.w - this._viewport.y, t.width = this._viewport.z, t.height = this._viewport.w) : (t.width = e.width, t.height = e.height), t;
  }
  _createOnRestPromise(t) {
    return t ? Promise.resolve() : (this._hasRested = false, this.dispatchEvent({ type: "transitionstart" }), new Promise((e) => {
      const n = () => {
        this.removeEventListener("rest", n), e();
      };
      this.addEventListener("rest", n);
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(t) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(t) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(t) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(t, e = new ve.Sphere()) {
    const n = e, s = n.center;
    ls.makeEmpty(), t.traverseVisible((r) => {
      r.isMesh && ls.expandByObject(r);
    }), ls.getCenter(s);
    let i = 0;
    return t.traverseVisible((r) => {
      if (!r.isMesh)
        return;
      const o = r, l = o.geometry.clone();
      l.applyMatrix4(o.matrixWorld);
      const h = l.attributes.position;
      for (let d = 0, m = h.count; d < m; d++)
        be.fromBufferAttribute(h, d), i = Math.max(i, s.distanceToSquared(be));
    }), n.radius = Math.sqrt(i), n;
  }
};
var xr = class _xr extends Ld {
  constructor(t) {
    super(t), S(this, "onBeforeUpdate", new $()), S(this, "onAfterUpdate", new $()), S(this, "onAspectUpdated", new $()), S(this, "onDisposed", new $()), S(this, "three"), S(this, "_allControls", /* @__PURE__ */ new Map()), S(this, "updateAspect", () => {
      var e;
      if (!(!this.currentWorld || !this.currentWorld.renderer)) {
        if (this.three instanceof OrthographicCamera) {
          this.onAspectUpdated.trigger();
          return;
        }
        if ((e = this.currentWorld.renderer) != null && e.isResizeable()) {
          const n = this.currentWorld.renderer.getSize();
          this.three.aspect = n.width / n.height, this.three.updateProjectionMatrix(), this.onAspectUpdated.trigger();
        }
      }
    }), this.three = this.setupCamera(), this.setupEvents(true), this.onWorldChanged.add(({ action: e, world: n }) => {
      if (e === "added") {
        const s = this.newCameraControls();
        this._allControls.set(n.uuid, s);
      }
      if (e === "removed") {
        const s = this._allControls.get(n.uuid);
        s && (s.dispose(), this._allControls.delete(n.uuid));
      }
    });
  }
  /**
   * The object that controls the camera. An instance of
   * [yomotsu's cameracontrols](https://github.com/yomotsu/camera-controls).
   * Transforming the camera directly will have no effect: you need to use this
   * object to move, rotate, look at objects, etc.
   */
  get controls() {
    if (!this.currentWorld)
      throw new Error("This camera needs a world to work!");
    const t = this._allControls.get(this.currentWorld.uuid);
    if (!t)
      throw new Error("Controls not found!");
    return t;
  }
  /** {@link Component.enabled} */
  get enabled() {
    return this.currentWorld === null ? false : this.controls.enabled;
  }
  /** {@link Component.enabled} */
  set enabled(t) {
    this.controls.enabled = t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.onAspectUpdated.reset(), this.onBeforeUpdate.reset(), this.onAfterUpdate.reset(), this.three.removeFromParent(), this.onDisposed.trigger(), this.onDisposed.reset();
    for (const [t, e] of this._allControls)
      e.dispose();
  }
  /** {@link Updateable.update} */
  update(t) {
    this.enabled && (this.onBeforeUpdate.trigger(this), this.controls.update(t), this.onAfterUpdate.trigger(this));
  }
  setupCamera() {
    const t = window.innerWidth / window.innerHeight, e = new PerspectiveCamera(60, t, 1, 1e3);
    return e.position.set(50, 50, 50), e.lookAt(new Vector3(0, 0, 0)), e;
  }
  newCameraControls() {
    if (!this.currentWorld)
      throw new Error("This camera needs a world to work!");
    if (!this.currentWorld.renderer)
      throw new Error("This camera needs a renderer to work!");
    oi.install({ THREE: _xr.getSubsetOfThree() });
    const { domElement: t } = this.currentWorld.renderer.three, e = new oi(this.three, t);
    return e.smoothTime = 0.2, e.dollyToCursor = true, e.infinityDolly = true, e;
  }
  setupEvents(t) {
    t ? window.addEventListener("resize", this.updateAspect) : window.removeEventListener("resize", this.updateAspect);
  }
  static getSubsetOfThree() {
    return {
      MOUSE,
      Vector2,
      Vector3,
      Vector4,
      Quaternion,
      Matrix4,
      Spherical,
      Box3,
      Sphere,
      Raycaster,
      MathUtils
    };
  }
};
var Wc = class Kc extends Re {
  constructor(t) {
    super(t), S(this, "onAfterUpdate", new $()), S(this, "onBeforeUpdate", new $()), S(this, "onDisposed", new $()), S(this, "onWorldCreated", new $()), S(this, "onWorldDeleted", new $()), S(this, "list", /* @__PURE__ */ new Map()), S(this, "enabled", true), t.add(Kc.uuid, this);
  }
  /**
   * Creates a new instance of a SimpleWorld and adds it to the list of worlds.
   *
   * @template T - The type of the scene, extending from BaseScene. Defaults to BaseScene.
   * @template U - The type of the camera, extending from BaseCamera. Defaults to BaseCamera.
   * @template S - The type of the renderer, extending from BaseRenderer. Defaults to BaseRenderer.
   *
   * @throws {Error} - Throws an error if a world with the same UUID already exists in the list.
   */
  create() {
    const t = new Qd(this.components), e = t.uuid;
    if (this.list.has(e))
      throw new Error("There is already a world with this name!");
    return this.list.set(e, t), this.onWorldCreated.trigger(t), t;
  }
  delete(t) {
    const e = t.uuid;
    this.list.delete(t.uuid), t.dispose(), this.onWorldDeleted.trigger(e);
  }
  dispose() {
    this.enabled = false;
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
  update(t) {
    if (this.enabled)
      for (const [e, n] of this.list)
        n.update(t);
  }
};
S(Wc, "uuid", "fdb61dc4-2ec1-4966-b83d-54ea795fad4a");
var nf = Wc;
var sf = class {
  constructor(t, e, n) {
    S(this, "onDisposed", new $()), S(this, "world"), S(this, "components"), S(this, "three"), S(this, "_fade", 3), S(this, "updateZoom", () => {
      this.world.camera instanceof xr && (this.material.uniforms.uZoom.value = this.world.camera.three.zoom);
    }), this.world = e;
    const { color: s, size1: i, size2: r, distance: o } = n;
    this.components = t;
    const l = new PlaneGeometry(2, 2, 1, 1), h = new ShaderMaterial({
      side: DoubleSide,
      uniforms: {
        uSize1: {
          value: i
        },
        uSize2: {
          value: r
        },
        uColor: {
          value: s
        },
        uDistance: {
          value: o
        },
        uFade: {
          value: this._fade
        },
        uZoom: {
          value: 1
        }
      },
      transparent: true,
      vertexShader: `
            
            varying vec3 worldPosition;
            
            uniform float uDistance;
            
            void main() {
            
                    vec3 pos = position.xzy * uDistance;
                    pos.xz += cameraPosition.xz;
                    
                    worldPosition = pos;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            
            }
            `,
      fragmentShader: `
            
            varying vec3 worldPosition;
            
            uniform float uZoom;
            uniform float uFade;
            uniform float uSize1;
            uniform float uSize2;
            uniform vec3 uColor;
            uniform float uDistance;
                
                
                
                float getGrid(float size) {
                
                    vec2 r = worldPosition.xz / size;
                    
                    
                    vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
                    float line = min(grid.x, grid.y);
                    
                
                    return 1.0 - min(line, 1.0);
                }
                
            void main() {
            
                    
                    float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / uDistance, 1.0);
                    
                    float g1 = getGrid(uSize1);
                    float g2 = getGrid(uSize2);
                    
                    // Ortho camera fades the grid away when zooming out
                    float minZoom = step(0.2, uZoom);
                    float zoomFactor = pow(min(uZoom, 1.), 2.) * minZoom;
                    
                    gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, uFade));
                    gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2) * zoomFactor;
                    
                    if ( gl_FragColor.a <= 0.0 ) discard;
                    
            
            }
            
            `,
      extensions: {
        derivatives: true
      }
    });
    this.three = new Mesh(l, h), this.three.frustumCulled = false, e.scene.three.add(this.three), this.setupEvents(true);
  }
  /** {@link Hideable.visible} */
  get visible() {
    return this.three.visible;
  }
  /** {@link Hideable.visible} */
  set visible(t) {
    t ? this.world.scene.three.add(this.three) : this.three.removeFromParent();
  }
  /** The material of the grid. */
  get material() {
    return this.three.material;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  get fade() {
    return this._fade === 3;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  set fade(t) {
    this._fade = t ? 3 : 0, this.material.uniforms.uFade.value = this._fade;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.components.get(rn).destroy(this.three), this.onDisposed.trigger(), this.onDisposed.reset(), this.world = null, this.components = null;
  }
  setupEvents(t) {
    if (this.world.isDisposing || !(this.world.camera instanceof xr))
      return;
    const e = this.world.camera.controls;
    t ? e.addEventListener("update", this.updateZoom) : e.removeEventListener("update", this.updateZoom);
  }
};
var rf = class jc extends Re {
  constructor(t) {
    super(t), S(this, "list", /* @__PURE__ */ new Map()), S(this, "onDisposed", new $()), S(this, "config", {
      color: new Color(12303291),
      size1: 1,
      size2: 10,
      distance: 500
    }), S(this, "enabled", true), t.add(jc.uuid, this);
  }
  create(t) {
    if (this.list.has(t.uuid))
      throw new Error("This world already has a grid!");
    const e = new sf(this.components, t, this.config);
    return this.list.set(t.uuid, e), t.onDisposed.add(() => {
      this.delete(t);
    }), e;
  }
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
S(rf, "uuid", "d1e814d5-b81c-4452-87a2-f039375e0489");
var Nn = new Raycaster();
var ot = new Vector3();
var mn = new Vector3();
var Ve = new Quaternion();
var Zl = {
  X: new Vector3(1, 0, 0),
  Y: new Vector3(0, 1, 0),
  Z: new Vector3(0, 0, 1)
};
var ta = { type: "change" };
var Ql = { type: "mouseDown" };
var ql = { type: "mouseUp", mode: null };
var Jl = { type: "objectChange" };
var of = class extends Object3D {
  constructor(t, e) {
    super(), e === void 0 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), e = document), this.isTransformControls = true, this.visible = false, this.domElement = e, this.domElement.style.touchAction = "none";
    const n = new df();
    this._gizmo = n, this.add(n);
    const s = new ff();
    this._plane = s, this.add(s);
    const i = this;
    function r(F, P) {
      let b = P;
      Object.defineProperty(i, F, {
        get: function() {
          return b !== void 0 ? b : P;
        },
        set: function(O) {
          b !== O && (b = O, s[F] = O, n[F] = O, i.dispatchEvent({ type: F + "-changed", value: O }), i.dispatchEvent(ta));
        }
      }), i[F] = P, s[F] = P, n[F] = P;
    }
    r("camera", t), r("object", void 0), r("enabled", true), r("axis", null), r("mode", "translate"), r("translationSnap", null), r("rotationSnap", null), r("scaleSnap", null), r("space", "world"), r("size", 1), r("dragging", false), r("showX", true), r("showY", true), r("showZ", true);
    const o = new Vector3(), l = new Vector3(), h = new Quaternion(), d = new Quaternion(), m = new Vector3(), f = new Quaternion(), g = new Vector3(), I = new Vector3(), y = new Vector3(), x = 0, A = new Vector3();
    r("worldPosition", o), r("worldPositionStart", l), r("worldQuaternion", h), r("worldQuaternionStart", d), r("cameraPosition", m), r("cameraQuaternion", f), r("pointStart", g), r("pointEnd", I), r("rotationAxis", y), r("rotationAngle", x), r("eye", A), this._offset = new Vector3(), this._startNorm = new Vector3(), this._endNorm = new Vector3(), this._cameraScale = new Vector3(), this._parentPosition = new Vector3(), this._parentQuaternion = new Quaternion(), this._parentQuaternionInv = new Quaternion(), this._parentScale = new Vector3(), this._worldScaleStart = new Vector3(), this._worldQuaternionInv = new Quaternion(), this._worldScale = new Vector3(), this._positionStart = new Vector3(), this._quaternionStart = new Quaternion(), this._scaleStart = new Vector3(), this._getPointer = af.bind(this), this._onPointerDown = cf.bind(this), this._onPointerHover = lf.bind(this), this._onPointerMove = hf.bind(this), this._onPointerUp = uf.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  // updateMatrixWorld  updates key transformation variables
  updateMatrixWorld() {
    this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye).negate() : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this);
  }
  pointerHover(t) {
    if (this.object === void 0 || this.dragging === true)
      return;
    Nn.setFromCamera(t, this.camera);
    const e = na(this._gizmo.picker[this.mode], Nn);
    e ? this.axis = e.object.name : this.axis = null;
  }
  pointerDown(t) {
    if (!(this.object === void 0 || this.dragging === true || t.button !== 0) && this.axis !== null) {
      Nn.setFromCamera(t, this.camera);
      const e = na(this._plane, Nn, true);
      e && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(e.point).sub(this.worldPositionStart)), this.dragging = true, Ql.mode = this.mode, this.dispatchEvent(Ql);
    }
  }
  pointerMove(t) {
    const e = this.axis, n = this.mode, s = this.object;
    let i = this.space;
    if (n === "scale" ? i = "local" : (e === "E" || e === "XYZE" || e === "XYZ") && (i = "world"), s === void 0 || e === null || this.dragging === false || t.button !== -1)
      return;
    Nn.setFromCamera(t, this.camera);
    const r = na(this._plane, Nn, true);
    if (r) {
      if (this.pointEnd.copy(r.point).sub(this.worldPositionStart), n === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), i === "local" && e !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), e.indexOf("X") === -1 && (this._offset.x = 0), e.indexOf("Y") === -1 && (this._offset.y = 0), e.indexOf("Z") === -1 && (this._offset.z = 0), i === "local" && e !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), s.position.copy(this._offset).add(this._positionStart), this.translationSnap && (i === "local" && (s.position.applyQuaternion(Ve.copy(this._quaternionStart).invert()), e.search("X") !== -1 && (s.position.x = Math.round(s.position.x / this.translationSnap) * this.translationSnap), e.search("Y") !== -1 && (s.position.y = Math.round(s.position.y / this.translationSnap) * this.translationSnap), e.search("Z") !== -1 && (s.position.z = Math.round(s.position.z / this.translationSnap) * this.translationSnap), s.position.applyQuaternion(this._quaternionStart)), i === "world" && (s.parent && s.position.add(ot.setFromMatrixPosition(s.parent.matrixWorld)), e.search("X") !== -1 && (s.position.x = Math.round(s.position.x / this.translationSnap) * this.translationSnap), e.search("Y") !== -1 && (s.position.y = Math.round(s.position.y / this.translationSnap) * this.translationSnap), e.search("Z") !== -1 && (s.position.z = Math.round(s.position.z / this.translationSnap) * this.translationSnap), s.parent && s.position.sub(ot.setFromMatrixPosition(s.parent.matrixWorld))));
      else if (n === "scale") {
        if (e.search("XYZ") !== -1) {
          let o = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (o *= -1), mn.set(o, o, o);
        } else
          ot.copy(this.pointStart), mn.copy(this.pointEnd), ot.applyQuaternion(this._worldQuaternionInv), mn.applyQuaternion(this._worldQuaternionInv), mn.divide(ot), e.search("X") === -1 && (mn.x = 1), e.search("Y") === -1 && (mn.y = 1), e.search("Z") === -1 && (mn.z = 1);
        s.scale.copy(this._scaleStart).multiply(mn), this.scaleSnap && (e.search("X") !== -1 && (s.scale.x = Math.round(s.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), e.search("Y") !== -1 && (s.scale.y = Math.round(s.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), e.search("Z") !== -1 && (s.scale.z = Math.round(s.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (n === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const o = 20 / this.worldPosition.distanceTo(ot.setFromMatrixPosition(this.camera.matrixWorld));
        let l = false;
        e === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(ot.copy(this.rotationAxis).cross(this.eye)) * o) : (e === "X" || e === "Y" || e === "Z") && (this.rotationAxis.copy(Zl[e]), ot.copy(Zl[e]), i === "local" && ot.applyQuaternion(this.worldQuaternion), ot.cross(this.eye), ot.length() === 0 ? l = true : this.rotationAngle = this._offset.dot(ot.normalize()) * o), (e === "E" || l) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), i === "local" && e !== "E" && e !== "XYZE" ? (s.quaternion.copy(this._quaternionStart), s.quaternion.multiply(Ve.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), s.quaternion.copy(Ve.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), s.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(ta), this.dispatchEvent(Jl);
    }
  }
  pointerUp(t) {
    t.button === 0 && (this.dragging && this.axis !== null && (ql.mode = this.mode, this.dispatchEvent(ql)), this.dragging = false, this.axis = null);
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function(t) {
      t.geometry && t.geometry.dispose(), t.material && t.material.dispose();
    });
  }
  // Set current object
  attach(t) {
    return this.object = t, this.visible = true, this;
  }
  // Detach from object
  detach() {
    return this.object = void 0, this.visible = false, this.axis = null, this;
  }
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(ta), this.dispatchEvent(Jl), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return Nn;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(t) {
    this.mode = t;
  }
  setTranslationSnap(t) {
    this.translationSnap = t;
  }
  setRotationSnap(t) {
    this.rotationSnap = t;
  }
  setScaleSnap(t) {
    this.scaleSnap = t;
  }
  setSize(t) {
    this.size = t;
  }
  setSpace(t) {
    this.space = t;
  }
};
function af(u) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: u.button
    };
  {
    const t = this.domElement.getBoundingClientRect();
    return {
      x: (u.clientX - t.left) / t.width * 2 - 1,
      y: -(u.clientY - t.top) / t.height * 2 + 1,
      button: u.button
    };
  }
}
function lf(u) {
  if (this.enabled)
    switch (u.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(u));
        break;
    }
}
function cf(u) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(u.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(u)), this.pointerDown(this._getPointer(u)));
}
function hf(u) {
  this.enabled && this.pointerMove(this._getPointer(u));
}
function uf(u) {
  this.enabled && (this.domElement.releasePointerCapture(u.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(u)));
}
function na(u, t, e) {
  const n = t.intersectObject(u, true);
  for (let s = 0; s < n.length; s++)
    if (n[s].object.visible || e)
      return n[s];
  return false;
}
var ar = new Euler();
var _e = new Vector3(0, 1, 0);
var $l = new Vector3(0, 0, 0);
var ec = new Matrix4();
var lr = new Quaternion();
var wr = new Quaternion();
var Gt = new Vector3();
var tc = new Matrix4();
var Js2 = new Vector3(1, 0, 0);
var _n = new Vector3(0, 1, 0);
var $s = new Vector3(0, 0, 1);
var cr = new Vector3();
var Qs = new Vector3();
var qs = new Vector3();
var df = class extends Object3D {
  constructor() {
    super(), this.isTransformControlsGizmo = true, this.type = "TransformControlsGizmo";
    const t = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    }), e = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    }), n = t.clone();
    n.opacity = 0.15;
    const s = e.clone();
    s.opacity = 0.5;
    const i = t.clone();
    i.color.setHex(16711680);
    const r = t.clone();
    r.color.setHex(65280);
    const o = t.clone();
    o.color.setHex(255);
    const l = t.clone();
    l.color.setHex(16711680), l.opacity = 0.5;
    const h = t.clone();
    h.color.setHex(65280), h.opacity = 0.5;
    const d = t.clone();
    d.color.setHex(255), d.opacity = 0.5;
    const m = t.clone();
    m.opacity = 0.25;
    const f = t.clone();
    f.color.setHex(16776960), f.opacity = 0.25, t.clone().color.setHex(16776960);
    const g = t.clone();
    g.color.setHex(7895160);
    const I = new CylinderGeometry(0, 0.04, 0.1, 12);
    I.translate(0, 0.05, 0);
    const y = new BoxGeometry(0.08, 0.08, 0.08);
    y.translate(0, 0.04, 0);
    const x = new BufferGeometry();
    x.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
    const A = new CylinderGeometry(75e-4, 75e-4, 0.5, 3);
    A.translate(0, 0.25, 0);
    function F(ue, me) {
      const Ie = new TorusGeometry(ue, 75e-4, 3, 64, me * Math.PI * 2);
      return Ie.rotateY(Math.PI / 2), Ie.rotateX(Math.PI / 2), Ie;
    }
    function P() {
      const ue = new BufferGeometry();
      return ue.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3)), ue;
    }
    const b = {
      X: [
        [new Mesh(I, i), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(I, i), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Mesh(A, i), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(I, r), [0, 0.5, 0]],
        [new Mesh(I, r), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Mesh(A, r)]
      ],
      Z: [
        [new Mesh(I, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(I, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Mesh(A, o), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.1, 0), m.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), d.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), l.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), h.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, O = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.2, 0), n)]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), n), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), n), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), n), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, k = {
      START: [
        [new Mesh(new OctahedronGeometry(0.01, 2), s), null, null, null, "helper"]
      ],
      END: [
        [new Mesh(new OctahedronGeometry(0.01, 2), s), null, null, null, "helper"]
      ],
      DELTA: [
        [new Line(P(), s), null, null, null, "helper"]
      ],
      X: [
        [new Line(x, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(x, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(x, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, Y = {
      XYZE: [
        [new Mesh(F(0.5, 1), g), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Mesh(F(0.5, 0.5), i)]
      ],
      Y: [
        [new Mesh(F(0.5, 0.5), r), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Mesh(F(0.5, 0.5), o), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Mesh(F(0.75, 1), f), null, [0, Math.PI / 2, 0]]
      ]
    }, H = {
      AXIS: [
        [new Line(x, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, K = {
      XYZE: [
        [new Mesh(new SphereGeometry(0.25, 10, 8), n)]
      ],
      X: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), n), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), n), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), n), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Mesh(new TorusGeometry(0.75, 0.1, 2, 24), n)]
      ]
    }, Z = {
      X: [
        [new Mesh(y, i), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(A, i), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(y, i), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(y, r), [0, 0.5, 0]],
        [new Mesh(A, r)],
        [new Mesh(y, r), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(y, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(A, o), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Mesh(y, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), d), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), l), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), h), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.1, 0.1, 0.1), m.clone())]
      ]
    }, q = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), n), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), n), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), n), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), n), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.2), n), [0, 0, 0]]
      ]
    }, ne = {
      X: [
        [new Line(x, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(x, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(x, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function se(ue) {
      const me = new Object3D();
      for (const Ie in ue)
        for (let Ee = ue[Ie].length; Ee--; ) {
          const de = ue[Ie][Ee][0].clone(), Le = ue[Ie][Ee][1], we = ue[Ie][Ee][2], Ke = ue[Ie][Ee][3], Nt = ue[Ie][Ee][4];
          de.name = Ie, de.tag = Nt, Le && de.position.set(Le[0], Le[1], Le[2]), we && de.rotation.set(we[0], we[1], we[2]), Ke && de.scale.set(Ke[0], Ke[1], Ke[2]), de.updateMatrix();
          const vt = de.geometry.clone();
          vt.applyMatrix4(de.matrix), de.geometry = vt, de.renderOrder = 1 / 0, de.position.set(0, 0, 0), de.rotation.set(0, 0, 0), de.scale.set(1, 1, 1), me.add(de);
        }
      return me;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = se(b)), this.add(this.gizmo.rotate = se(Y)), this.add(this.gizmo.scale = se(Z)), this.add(this.picker.translate = se(O)), this.add(this.picker.rotate = se(K)), this.add(this.picker.scale = se(q)), this.add(this.helper.translate = se(k)), this.add(this.helper.rotate = se(H)), this.add(this.helper.scale = se(ne)), this.picker.translate.visible = false, this.picker.rotate.visible = false, this.picker.scale.visible = false;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(t) {
    const e = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : wr;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let n = [];
    n = n.concat(this.picker[this.mode].children), n = n.concat(this.gizmo[this.mode].children), n = n.concat(this.helper[this.mode].children);
    for (let s = 0; s < n.length; s++) {
      const i = n[s];
      i.visible = true, i.rotation.set(0, 0, 0), i.position.copy(this.worldPosition);
      let r;
      if (this.camera.isOrthographicCamera ? r = (this.camera.top - this.camera.bottom) / this.camera.zoom : r = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), i.scale.set(1, 1, 1).multiplyScalar(r * this.size / 4), i.tag === "helper") {
        i.visible = false, i.name === "AXIS" ? (i.visible = !!this.axis, this.axis === "X" && (Ve.setFromEuler(ar.set(0, 0, 0)), i.quaternion.copy(e).multiply(Ve), Math.abs(_e.copy(Js2).applyQuaternion(e).dot(this.eye)) > 0.9 && (i.visible = false)), this.axis === "Y" && (Ve.setFromEuler(ar.set(0, 0, Math.PI / 2)), i.quaternion.copy(e).multiply(Ve), Math.abs(_e.copy(_n).applyQuaternion(e).dot(this.eye)) > 0.9 && (i.visible = false)), this.axis === "Z" && (Ve.setFromEuler(ar.set(0, Math.PI / 2, 0)), i.quaternion.copy(e).multiply(Ve), Math.abs(_e.copy($s).applyQuaternion(e).dot(this.eye)) > 0.9 && (i.visible = false)), this.axis === "XYZE" && (Ve.setFromEuler(ar.set(0, Math.PI / 2, 0)), _e.copy(this.rotationAxis), i.quaternion.setFromRotationMatrix(ec.lookAt($l, _e, _n)), i.quaternion.multiply(Ve), i.visible = this.dragging), this.axis === "E" && (i.visible = false)) : i.name === "START" ? (i.position.copy(this.worldPositionStart), i.visible = this.dragging) : i.name === "END" ? (i.position.copy(this.worldPosition), i.visible = this.dragging) : i.name === "DELTA" ? (i.position.copy(this.worldPositionStart), i.quaternion.copy(this.worldQuaternionStart), ot.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), ot.applyQuaternion(this.worldQuaternionStart.clone().invert()), i.scale.copy(ot), i.visible = this.dragging) : (i.quaternion.copy(e), this.dragging ? i.position.copy(this.worldPositionStart) : i.position.copy(this.worldPosition), this.axis && (i.visible = this.axis.search(i.name) !== -1));
        continue;
      }
      i.quaternion.copy(e), this.mode === "translate" || this.mode === "scale" ? (i.name === "X" && Math.abs(_e.copy(Js2).applyQuaternion(e).dot(this.eye)) > 0.99 && (i.scale.set(1e-10, 1e-10, 1e-10), i.visible = false), i.name === "Y" && Math.abs(_e.copy(_n).applyQuaternion(e).dot(this.eye)) > 0.99 && (i.scale.set(1e-10, 1e-10, 1e-10), i.visible = false), i.name === "Z" && Math.abs(_e.copy($s).applyQuaternion(e).dot(this.eye)) > 0.99 && (i.scale.set(1e-10, 1e-10, 1e-10), i.visible = false), i.name === "XY" && Math.abs(_e.copy($s).applyQuaternion(e).dot(this.eye)) < 0.2 && (i.scale.set(1e-10, 1e-10, 1e-10), i.visible = false), i.name === "YZ" && Math.abs(_e.copy(Js2).applyQuaternion(e).dot(this.eye)) < 0.2 && (i.scale.set(1e-10, 1e-10, 1e-10), i.visible = false), i.name === "XZ" && Math.abs(_e.copy(_n).applyQuaternion(e).dot(this.eye)) < 0.2 && (i.scale.set(1e-10, 1e-10, 1e-10), i.visible = false)) : this.mode === "rotate" && (lr.copy(e), _e.copy(this.eye).applyQuaternion(Ve.copy(e).invert()), i.name.search("E") !== -1 && i.quaternion.setFromRotationMatrix(ec.lookAt(this.eye, $l, _n)), i.name === "X" && (Ve.setFromAxisAngle(Js2, Math.atan2(-_e.y, _e.z)), Ve.multiplyQuaternions(lr, Ve), i.quaternion.copy(Ve)), i.name === "Y" && (Ve.setFromAxisAngle(_n, Math.atan2(_e.x, _e.z)), Ve.multiplyQuaternions(lr, Ve), i.quaternion.copy(Ve)), i.name === "Z" && (Ve.setFromAxisAngle($s, Math.atan2(_e.y, _e.x)), Ve.multiplyQuaternions(lr, Ve), i.quaternion.copy(Ve))), i.visible = i.visible && (i.name.indexOf("X") === -1 || this.showX), i.visible = i.visible && (i.name.indexOf("Y") === -1 || this.showY), i.visible = i.visible && (i.name.indexOf("Z") === -1 || this.showZ), i.visible = i.visible && (i.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), i.material._color = i.material._color || i.material.color.clone(), i.material._opacity = i.material._opacity || i.material.opacity, i.material.color.copy(i.material._color), i.material.opacity = i.material._opacity, this.enabled && this.axis && (i.name === this.axis || this.axis.split("").some(function(o) {
        return i.name === o;
      })) && (i.material.color.setHex(16776960), i.material.opacity = 1);
    }
    super.updateMatrixWorld(t);
  }
};
var ff = class extends Mesh {
  constructor() {
    super(
      new PlaneGeometry(1e5, 1e5, 2, 2),
      new MeshBasicMaterial({ visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false })
    ), this.isTransformControlsPlane = true, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(t) {
    let e = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (e = "local"), cr.copy(Js2).applyQuaternion(e === "local" ? this.worldQuaternion : wr), Qs.copy(_n).applyQuaternion(e === "local" ? this.worldQuaternion : wr), qs.copy($s).applyQuaternion(e === "local" ? this.worldQuaternion : wr), _e.copy(Qs), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            _e.copy(this.eye).cross(cr), Gt.copy(cr).cross(_e);
            break;
          case "Y":
            _e.copy(this.eye).cross(Qs), Gt.copy(Qs).cross(_e);
            break;
          case "Z":
            _e.copy(this.eye).cross(qs), Gt.copy(qs).cross(_e);
            break;
          case "XY":
            Gt.copy(qs);
            break;
          case "YZ":
            Gt.copy(cr);
            break;
          case "XZ":
            _e.copy(qs), Gt.copy(Qs);
            break;
          case "XYZ":
          case "E":
            Gt.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        Gt.set(0, 0, 0);
    }
    Gt.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (tc.lookAt(ot.set(0, 0, 0), Gt, _e), this.quaternion.setFromRotationMatrix(tc)), super.updateMatrixWorld(t);
  }
};
var jr = class _jr {
  constructor(t, e, n, s, i, r = 5, o = true) {
    if (S(this, "onDraggingStarted", new $()), S(this, "onDraggingEnded", new $()), S(this, "onDisposed", new $()), S(this, "normal"), S(this, "origin"), S(this, "three", new Plane()), S(this, "_helper"), S(this, "_visible", true), S(this, "_enabled", true), S(this, "components"), S(this, "world"), S(this, "_controlsActive", false), S(this, "_arrowBoundBox", new Mesh()), S(this, "_planeMesh"), S(this, "_controls"), S(this, "_hiddenMaterial", new MeshBasicMaterial({
      visible: false
    })), S(this, "update", () => {
      this._enabled && this.three.setFromNormalAndCoplanarPoint(
        this.normal,
        this._helper.position
      );
    }), S(this, "changeDrag", (l) => {
      this._visible = !l.value, this.preventCameraMovement(), this.notifyDraggingChanged(l);
    }), this.components = t, this.world = e, !e.renderer)
      throw new Error("The given world must have a renderer!");
    this.normal = s, this.origin = n, e.renderer.setPlane(true, this.three), this._planeMesh = _jr.newPlaneMesh(r, i), this._helper = this.newHelper(), this._controls = this.newTransformControls(), this.three.setFromNormalAndCoplanarPoint(s, n), o && this.toggleControls(true);
  }
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(t) {
    if (!this.world.renderer)
      throw new Error("No renderer found for clipping plane!");
    this._enabled = t, this.world.renderer.setPlane(t, this.three);
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(t) {
    this._visible = t, this._controls.visible = t, this._helper.visible = t, this.toggleControls(t);
  }
  /** The meshes used for raycasting */
  get meshes() {
    return [this._planeMesh, this._arrowBoundBox];
  }
  /** The material of the clipping plane representation. */
  get planeMaterial() {
    return this._planeMesh.material;
  }
  /** The material of the clipping plane representation. */
  set planeMaterial(t) {
    this._planeMesh.material = t;
  }
  /** The size of the clipping plane representation. */
  get size() {
    return this._planeMesh.scale.x;
  }
  /** Sets the size of the clipping plane representation. */
  set size(t) {
    this._planeMesh.scale.set(t, t, t);
  }
  get helper() {
    return this._helper;
  }
  setFromNormalAndCoplanarPoint(t, e) {
    this.reset(), this.normal.equals(t) || (this.normal.copy(t), this._helper.lookAt(t)), this.origin.copy(e), this._helper.position.copy(e), this._helper.updateMatrix(), this.update();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = false, this.onDraggingStarted.reset(), this.onDraggingEnded.reset(), this._helper.removeFromParent(), this.world.renderer && this.world.renderer.setPlane(false, this.three), this._arrowBoundBox.removeFromParent(), this._arrowBoundBox.geometry.dispose(), this._planeMesh.geometry.dispose(), this._controls.removeFromParent(), this._controls.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  reset() {
    const t = new Vector3(1, 0, 0), e = new Vector3();
    this.normal.equals(t) || (this.normal.copy(t), this._helper.lookAt(t)), this.origin.copy(e), this._helper.position.copy(e), this._helper.updateMatrix();
  }
  toggleControls(t) {
    if (t) {
      if (this._controlsActive)
        return;
      this._controls.addEventListener("change", this.update), this._controls.addEventListener("dragging-changed", this.changeDrag);
    } else
      this._controls.removeEventListener("change", this.update), this._controls.removeEventListener("dragging-changed", this.changeDrag);
    this._controlsActive = t;
  }
  newTransformControls() {
    if (!this.world.renderer)
      throw new Error("No renderer found for clipping plane!");
    const t = this.world.camera.three, e = this.world.renderer.three.domElement, n = new of(t, e);
    return this.initializeControls(n), this.world.scene.three.add(n), n;
  }
  initializeControls(t) {
    t.attach(this._helper), t.showX = false, t.showY = false, t.setSpace("local"), this.createArrowBoundingBox(), t.children[0].children[0].add(this._arrowBoundBox);
  }
  createArrowBoundingBox() {
    this._arrowBoundBox.geometry = new CylinderGeometry(0.18, 0.18, 1.2), this._arrowBoundBox.material = this._hiddenMaterial, this._arrowBoundBox.rotateX(Math.PI / 2), this._arrowBoundBox.updateMatrix(), this._arrowBoundBox.geometry.applyMatrix4(this._arrowBoundBox.matrix);
  }
  notifyDraggingChanged(t) {
    t.value ? this.onDraggingStarted.trigger() : this.onDraggingEnded.trigger();
  }
  preventCameraMovement() {
    this.world.camera.enabled = this._visible;
  }
  newHelper() {
    const t = new Object3D();
    return t.lookAt(this.normal), t.position.copy(this.origin), this._planeMesh.position.z += 0.01, t.add(this._planeMesh), this.world.scene.three.add(t), t;
  }
  static newPlaneMesh(t, e) {
    const n = new PlaneGeometry(1), s = new Mesh(n, e);
    return s.scale.set(t, t, t), s;
  }
};
var Xc = class va extends Re {
  constructor(t) {
    super(t), S(this, "onAfterCreate", new $()), S(this, "onAfterDelete", new $()), S(this, "onBeforeDrag", new $()), S(this, "onAfterDrag", new $()), S(this, "onBeforeCreate", new $()), S(this, "onBeforeCancel", new $()), S(this, "onAfterCancel", new $()), S(this, "onBeforeDelete", new $()), S(this, "onDisposed", new $()), S(this, "orthogonalY", false), S(this, "toleranceOrthogonalY", 0.7), S(this, "Type", jr), S(this, "list", []), S(this, "_material", new MeshBasicMaterial({
      color: 12255487,
      side: DoubleSide,
      transparent: true,
      opacity: 0.2
    })), S(this, "_size", 5), S(this, "_enabled", false), S(this, "_visible", true), S(this, "_onStartDragging", () => {
      this.onBeforeDrag.trigger();
    }), S(this, "_onEndDragging", () => {
      this.onAfterDrag.trigger();
    }), this.components.add(va.uuid, this);
  }
  /** {@link Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(t) {
    this._enabled = t;
    for (const e of this.list)
      e.enabled = t;
    this.updateMaterialsAndPlanes();
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(t) {
    this._visible = t;
    for (const e of this.list)
      e.visible = t;
  }
  /** The material of the clipping plane representation. */
  get material() {
    return this._material;
  }
  /** The material of the clipping plane representation. */
  set material(t) {
    this._material = t;
    for (const e of this.list)
      e.planeMaterial = t;
  }
  /** The size of the geometric representation of the clippings planes. */
  get size() {
    return this._size;
  }
  /** The size of the geometric representation of the clippings planes. */
  set size(t) {
    this._size = t;
    for (const e of this.list)
      e.size = t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = false;
    for (const t of this.list)
      t.dispose();
    this.list.length = 0, this._material.dispose(), this.onBeforeCreate.reset(), this.onBeforeCancel.reset(), this.onBeforeDelete.reset(), this.onBeforeDrag.reset(), this.onAfterCreate.reset(), this.onAfterCancel.reset(), this.onAfterDelete.reset(), this.onAfterDrag.reset(), this.onDisposed.trigger(va.uuid), this.onDisposed.reset();
  }
  /** {@link Createable.create} */
  create(t) {
    if (!this.enabled)
      return;
    const e = this.components.get(Dt).get(t).castRay();
    e && this.createPlaneFromIntersection(t, e);
  }
  /**
   * Creates a plane in a certain place and with a certain orientation,
   * without the need of the mouse.
   *
   * @param world - the world where this plane should be created.
   * @param normal - the orientation of the clipping plane.
   * @param point - the position of the clipping plane.
   * navigation.
   */
  createFromNormalAndCoplanarPoint(t, e, n) {
    const s = this.newPlane(t, n, e);
    return this.updateMaterialsAndPlanes(), s;
  }
  /**
   * {@link Createable.delete}
   *
   * @param world - the world where the plane to delete is.
   * @param plane - the plane to delete. If undefined, the first plane
   * found under the cursor will be deleted.
   */
  delete(t, e) {
    this.enabled && (e || (e = this.pickPlane(t)), e && this.deletePlane(e));
  }
  /** Deletes all the existing clipping planes. */
  deleteAll() {
    for (; this.list.length > 0; ) {
      const t = this.list[0];
      this.delete(t.world, t);
    }
  }
  deletePlane(t) {
    const e = this.list.indexOf(t);
    if (e !== -1) {
      if (this.list.splice(e, 1), !t.world.renderer)
        throw new Error("Renderer not found for this plane's world!");
      t.world.renderer.setPlane(false, t.three), t.dispose(), this.updateMaterialsAndPlanes(), this.onAfterDelete.trigger(t);
    }
  }
  pickPlane(t) {
    const e = this.components.get(Dt).get(t), n = this.getAllPlaneMeshes(), s = e.castRay(n);
    if (s) {
      const i = s.object;
      return this.list.find((r) => r.meshes.includes(i));
    }
  }
  getAllPlaneMeshes() {
    const t = [];
    for (const e of this.list)
      t.push(...e.meshes);
    return t;
  }
  createPlaneFromIntersection(t, e) {
    var n;
    if (!t.renderer)
      throw new Error("The given world must have a renderer!");
    const s = e.point.distanceTo(new Vector3(0, 0, 0)), i = (n = e.face) == null ? void 0 : n.normal;
    if (!s || !i)
      return;
    const r = this.getWorldNormal(e, i), o = this.newPlane(t, e.point, r.negate());
    o.visible = this._visible, o.size = this._size, t.renderer.setPlane(true, o.three), this.updateMaterialsAndPlanes();
  }
  getWorldNormal(t, e) {
    const n = t.object;
    let s = t.object.matrixWorld.clone();
    if (n instanceof InstancedMesh && t.instanceId !== void 0) {
      const o = new Matrix4();
      n.getMatrixAt(t.instanceId, o), s = o.multiply(s);
    }
    const i = new Matrix3().getNormalMatrix(s), r = e.clone().applyMatrix3(i).normalize();
    return this.normalizePlaneDirectionY(r), r;
  }
  normalizePlaneDirectionY(t) {
    this.orthogonalY && (t.y > this.toleranceOrthogonalY && (t.x = 0, t.y = 1, t.z = 0), t.y < -this.toleranceOrthogonalY && (t.x = 0, t.y = -1, t.z = 0));
  }
  newPlane(t, e, n) {
    const s = new this.Type(
      this.components,
      t,
      e,
      n,
      this._material
    );
    return s.onDraggingStarted.add(this._onStartDragging), s.onDraggingEnded.add(this._onEndDragging), this.list.push(s), this.onAfterCreate.trigger(s), s;
  }
  updateMaterialsAndPlanes() {
    const t = this.components.get(nf);
    for (const [e, n] of t.list) {
      if (!n.renderer)
        continue;
      n.renderer.updateClippingPlanes();
      const { clippingPlanes: s } = n.renderer;
      for (const i of n.meshes)
        if (Array.isArray(i.material))
          for (const r of i.material)
            r.clippingPlanes = s;
        else
          i.material.clippingPlanes = s;
    }
  }
};
S(Xc, "uuid", "66290bc5-18c4-4cd1-9379-2e17a0617611");
var Sr = Xc;
function pf(u, t, e, n) {
  return new Promise((s, i) => {
    function r() {
      const o = u.clientWaitSync(t, e, 0);
      if (o === u.WAIT_FAILED) {
        i();
        return;
      }
      if (o === u.TIMEOUT_EXPIRED) {
        setTimeout(r, n);
        return;
      }
      s();
    }
    r();
  });
}
async function mf(u, t, e, n, s, i, r) {
  const o = u.fenceSync(u.SYNC_GPU_COMMANDS_COMPLETE, 0);
  u.flush(), await pf(u, o, 0, 10), u.deleteSync(o), u.bindBuffer(t, e), u.getBufferSubData(t, n, s, i, r), u.bindBuffer(t, null);
}
async function gf(u, t, e, n, s, i, r, o) {
  const l = u.createBuffer();
  return u.bindBuffer(u.PIXEL_PACK_BUFFER, l), u.bufferData(u.PIXEL_PACK_BUFFER, o.byteLength, u.STREAM_READ), u.readPixels(t, e, n, s, i, r, 0), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), await mf(u, u.PIXEL_PACK_BUFFER, l, 0, o), u.deleteBuffer(l), o;
}
var Zc = class {
  constructor(t, e, n) {
    if (S(this, "onDisposed", new $()), S(this, "onViewUpdated", new yn()), S(this, "enabled", true), S(this, "needsUpdate", false), S(this, "renderDebugFrame", false), S(this, "components"), S(this, "world"), S(this, "renderer"), S(this, "autoUpdate", true), S(this, "updateInterval", 1e3), S(this, "worker"), S(this, "scene", new Scene()), S(this, "_width", 512), S(this, "_height", 512), S(this, "_availableColor", 1), S(this, "renderTarget"), S(this, "bufferSize"), S(this, "_buffer"), S(this, "_isWorkerBusy", false), S(this, "updateVisibility", async (r) => {
      if (!this.enabled || !this.needsUpdate && !r || this._isWorkerBusy)
        return;
      this._isWorkerBusy = true;
      const o = this.world.camera.three;
      o.updateMatrix(), this.renderer.setSize(this._width, this._height), this.renderer.setRenderTarget(this.renderTarget), this.renderer.render(this.scene, o);
      const l = this.renderer.getContext();
      await gf(
        l,
        0,
        0,
        this._width,
        this._height,
        l.RGBA,
        l.UNSIGNED_BYTE,
        this._buffer
      ), this.renderer.setRenderTarget(null), this.renderDebugFrame && this.renderer.render(this.scene, o), this.worker.postMessage({
        buffer: this._buffer
      }), this.needsUpdate = false;
    }), !e.renderer)
      throw new Error("The given world must have a renderer!");
    this.components = t, this.applySettings(n), this.world = e, this.renderer = new WebGLRenderer(), this.renderTarget = new WebGLRenderTarget(this._width, this._height), this.bufferSize = this._width * this._height * 4, this._buffer = new Uint8Array(this.bufferSize), this.renderer.clippingPlanes = e.renderer.clippingPlanes;
    const s = `
      addEventListener("message", (event) => {
        const { buffer } = event.data;
        const colors = new Map();
        for (let i = 0; i < buffer.length; i += 4) {
          const r = buffer[i];
          const g = buffer[i + 1];
          const b = buffer[i + 2];
          const code = "" + r + "-" + g + "-" + b;
          if(colors.has(code)) {
            colors.set(code, colors.get(code) + 1);
          } else {
            colors.set(code, 1);
          }
        }
        postMessage({ colors });
      });
    `, i = new Blob([s], { type: "application/javascript" });
    this.worker = new Worker(URL.createObjectURL(i));
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false;
    for (const t of this.scene.children)
      t.removeFromParent();
    this.onViewUpdated.reset(), this.worker.terminate(), this.renderer.dispose(), this.renderTarget.dispose(), this._buffer = null, this.onDisposed.reset();
  }
  getAvailableColor() {
    let t = BigInt(this._availableColor.toString());
    const e = [];
    do
      e.unshift(Number(t % 256n)), t /= 256n;
    while (t);
    for (; e.length !== 3; )
      e.unshift(0);
    const [n, s, i] = e, r = `${n}-${s}-${i}`;
    return { r: n, g: s, b: i, code: r };
  }
  increaseColor() {
    if (this._availableColor === 256 * 256 * 256) {
      console.warn("Color can't be increased over 256 x 256 x 256!");
      return;
    }
    this._availableColor++;
  }
  decreaseColor() {
    if (this._availableColor === 1) {
      console.warn("Color can't be decreased under 0!");
      return;
    }
    this._availableColor--;
  }
  applySettings(t) {
    t && (t.updateInterval !== void 0 && (this.updateInterval = t.updateInterval), t.height !== void 0 && (this._height = t.height), t.width !== void 0 && (this._width = t.width), t.autoUpdate !== void 0 && (this.autoUpdate = t.autoUpdate));
  }
};
var Ef = class extends Zc {
  constructor(t, e, n) {
    super(t, e, n), S(this, "threshold", 100), S(this, "onViewUpdated", new $()), S(this, "colorMeshes", /* @__PURE__ */ new Map()), S(this, "isProcessing", false), S(this, "_colorCodeMeshMap", /* @__PURE__ */ new Map()), S(this, "_meshIDColorCodeMap", /* @__PURE__ */ new Map()), S(this, "_currentVisibleMeshes", /* @__PURE__ */ new Set()), S(this, "_recentlyHiddenMeshes", /* @__PURE__ */ new Set()), S(this, "_intervalID", null), S(this, "_transparentMat", new MeshBasicMaterial({
      transparent: true,
      opacity: 0
    })), S(this, "handleWorkerMessage", async (s) => {
      if (this.isProcessing)
        return;
      const i = s.data.colors;
      this._recentlyHiddenMeshes = new Set(this._currentVisibleMeshes), this._currentVisibleMeshes.clear();
      for (const [r, o] of i) {
        if (o < this.threshold)
          continue;
        const l = this._colorCodeMeshMap.get(r);
        l && (this._currentVisibleMeshes.add(l), this._recentlyHiddenMeshes.delete(l));
      }
      this.onViewUpdated.trigger({
        seen: this._currentVisibleMeshes,
        unseen: this._recentlyHiddenMeshes
      }), this._isWorkerBusy = false;
    }), this.worker.addEventListener("message", this.handleWorkerMessage), this.autoUpdate && window.setInterval(async () => {
      this.isProcessing || await this.updateVisibility();
    }, this.updateInterval), this.onViewUpdated.add(({ seen: s, unseen: i }) => {
      for (const r of s)
        r.visible = true;
      for (const r of i)
        r.visible = false;
    });
  }
  dispose() {
    super.dispose(), this._intervalID !== null && (window.clearInterval(this._intervalID), this._intervalID = null), this._currentVisibleMeshes.clear(), this._recentlyHiddenMeshes.clear(), this._meshIDColorCodeMap.clear(), this._transparentMat.dispose(), this._colorCodeMeshMap.clear();
    const t = this.components.get(rn);
    for (const e in this.colorMeshes) {
      const n = this.colorMeshes.get(e);
      n && t.destroy(n, true);
    }
    this.colorMeshes.clear();
  }
  add(t) {
    if (!this.enabled)
      return;
    if (this.isProcessing) {
      console.log("Culler processing not finished yet.");
      return;
    }
    this.isProcessing = true;
    const e = t instanceof InstancedMesh, { geometry: n, material: s } = t, { colorMaterial: i, code: r } = this.getAvailableMaterial();
    let o;
    if (Array.isArray(s)) {
      let d = true;
      const m = [];
      for (const f of s)
        zl.isTransparent(f) ? m.push(this._transparentMat) : (d = false, m.push(i));
      if (d) {
        i.dispose(), this.isProcessing = false;
        return;
      }
      o = m;
    } else if (zl.isTransparent(s)) {
      i.dispose(), this.isProcessing = false;
      return;
    } else
      o = i;
    this._colorCodeMeshMap.set(r, t), this._meshIDColorCodeMap.set(t.uuid, r);
    const l = e ? t.count : 1, h = new InstancedMesh(n, o, l);
    e ? h.instanceMatrix = t.instanceMatrix : h.setMatrixAt(0, new Matrix4()), t.visible = false, h.applyMatrix4(t.matrix), h.updateMatrix(), this.scene.add(h), this.colorMeshes.set(t.uuid, h), this.increaseColor(), this.isProcessing = false;
  }
  remove(t) {
    if (this.isProcessing) {
      console.log("Culler processing not finished yet.");
      return;
    }
    this.isProcessing = true;
    const e = this.components.get(rn);
    this._currentVisibleMeshes.delete(t), this._recentlyHiddenMeshes.delete(t);
    const n = this.colorMeshes.get(t.uuid), s = this._meshIDColorCodeMap.get(t.uuid);
    if (!n || !s) {
      this.isProcessing = false, console.log(t.visible);
      return;
    }
    this._colorCodeMeshMap.delete(s), this._meshIDColorCodeMap.delete(t.uuid), this.colorMeshes.delete(t.uuid), n.geometry = void 0, n.material = [], e.destroy(n, true), this._recentlyHiddenMeshes.delete(t), this._currentVisibleMeshes.delete(t), this.isProcessing = false;
  }
  getAvailableMaterial() {
    const { r: t, g: e, b: n, code: s } = this.getAvailableColor(), i = ColorManagement.enabled;
    ColorManagement.enabled = false;
    const r = new Color(`rgb(${t}, ${e}, ${n})`);
    if (!this.world.renderer)
      throw new Error("Renderer not found in the world!");
    const o = this.world.renderer.clippingPlanes, l = new MeshBasicMaterial({
      color: r,
      clippingPlanes: o,
      side: DoubleSide
    });
    return ColorManagement.enabled = i, { colorMaterial: l, code: s };
  }
};
var Qc = class Ia extends Re {
  constructor(t) {
    super(t), S(this, "_enabled", true), S(this, "list", /* @__PURE__ */ new Map()), S(this, "onDisposed", new $()), t.add(Ia.uuid, this);
  }
  /**
   * Gets the enabled state of the Cullers component.
   *
   * @returns The current enabled state.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Sets the enabled state of the Cullers component.
   * Also sets the enabled state of all MeshCullerRenderer instances.
   *
   * @param value - The new enabled state.
   */
  set enabled(t) {
    this._enabled = t;
    for (const [e, n] of this.list)
      n.enabled = t;
  }
  /**
  * Creates a new MeshCullerRenderer for the given world.
  * If a MeshCullerRenderer already exists for the world, it will return the existing one.
  *
  * @param world - The world for which to create the MeshCullerRenderer.
  * @param config - Optional configuration settings for the MeshCullerRenderer.
  *
  * @returns The newly created or existing MeshCullerRenderer for the given world.
  */
  create(t, e) {
    if (this.list.has(t.uuid))
      return this.list.get(t.uuid);
    const n = new Ef(this.components, t, e);
    return this.list.set(t.uuid, n), n;
  }
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false, this.onDisposed.trigger(Ia.uuid), this.onDisposed.reset();
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear();
  }
};
S(Qc, "uuid", "69f2a50d-c266-44fc-b1bd-fa4d34be89e6");
var vf = Qc;
var If = class {
  constructor(t) {
    if (S(this, "onDisposed", new $()), S(this, "onAfterUpdate", new $()), S(this, "onBeforeUpdate", new $()), S(this, "onResize", new $()), S(this, "frontOffset", 0), S(this, "overrideMaterial", new MeshDepthMaterial()), S(this, "backgroundColor", new Color(395274)), S(this, "renderer"), S(this, "enabled", true), S(this, "world"), S(this, "_lockRotation", true), S(this, "_camera"), S(this, "_plane"), S(this, "_size", new Vector2(320, 160)), S(this, "_tempVector1", new Vector3()), S(this, "_tempVector2", new Vector3()), S(this, "_tempTarget", new Vector3()), S(this, "down", new Vector3(0, -1, 0)), S(this, "updatePlanes", () => {
      if (!this.world.renderer)
        throw new Error("The given world must have a renderer!");
      const s = [], i = this.world.renderer.three;
      for (const r of i.clippingPlanes)
        s.push(r);
      s.push(this._plane), this.renderer.clippingPlanes = s;
    }), this.world = t, !this.world.renderer)
      throw new Error("The given world must have a renderer!");
    this.renderer = new WebGLRenderer(), this.renderer.setSize(this._size.x, this._size.y);
    const e = 1, n = this._size.x / this._size.y;
    this._camera = new OrthographicCamera(
      e * n / -2,
      e * n / 2,
      e / 2,
      e / -2
    ), this.world.renderer.onClippingPlanesUpdated.add(this.updatePlanes), this._camera.position.set(0, 200, 0), this._camera.zoom = 0.1, this._camera.rotation.x = -Math.PI / 2, this._plane = new Plane(this.down, 200), this.updatePlanes();
  }
  get lockRotation() {
    return this._lockRotation;
  }
  set lockRotation(t) {
    this._lockRotation = t, t && (this._camera.rotation.z = 0);
  }
  get zoom() {
    return this._camera.zoom;
  }
  set zoom(t) {
    this._camera.zoom = t, this._camera.updateProjectionMatrix();
  }
  dispose() {
    this.enabled = false, this.onBeforeUpdate.reset(), this.onAfterUpdate.reset(), this.onResize.reset(), this.overrideMaterial.dispose(), this.renderer.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  get() {
    return this._camera;
  }
  update() {
    if (!this.enabled)
      return;
    this.onBeforeUpdate.trigger();
    const t = this.world.scene.three, e = this.world.camera;
    if (!e.hasCameraControls())
      throw new Error("The given world must use camera controls!");
    if (!(t instanceof Scene))
      throw new Error("The given world must have a THREE.Scene as a root!");
    const n = e.controls;
    if (n.getPosition(this._tempVector1), this._camera.position.x = this._tempVector1.x, this._camera.position.z = this._tempVector1.z, this.frontOffset !== 0 && (n.getTarget(this._tempVector2), this._tempVector2.sub(this._tempVector1), this._tempVector2.normalize().multiplyScalar(this.frontOffset), this._camera.position.x += this._tempVector2.x, this._camera.position.z += this._tempVector2.z), !this._lockRotation) {
      n.getTarget(this._tempTarget);
      const i = Math.atan2(
        this._tempTarget.x - this._tempVector1.x,
        this._tempTarget.z - this._tempVector1.z
      );
      this._camera.rotation.z = i + Math.PI;
    }
    this._plane.set(this.down, this._tempVector1.y);
    const s = t.background;
    t.background = this.backgroundColor, this.renderer.render(t, this._camera), t.background = s, this.onAfterUpdate.trigger();
  }
  getSize() {
    return this._size;
  }
  resize(t = this._size) {
    this._size.copy(t), this.renderer.setSize(t.x, t.y);
    const e = t.x / t.y, n = 1;
    this._camera.left = n * e / -2, this._camera.right = n * e / 2, this._camera.top = n / 2, this._camera.bottom = -n / 2, this._camera.updateProjectionMatrix(), this.onResize.trigger(t);
  }
};
var yf = class qc extends Re {
  constructor(t) {
    super(t), S(this, "onAfterUpdate", new $()), S(this, "onBeforeUpdate", new $()), S(this, "onDisposed", new $()), S(this, "enabled", true), S(this, "list", /* @__PURE__ */ new Map()), this.components.add(qc.uuid, this);
  }
  create(t) {
    if (this.list.has(t.uuid))
      throw new Error("This world already has a minimap!");
    const e = new If(t);
    return this.list.set(t.uuid, e), e;
  }
  delete(t) {
    const e = this.list.get(t);
    e && e.dispose(), this.list.delete(t);
  }
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
  update() {
    for (const [t, e] of this.list)
      e.update();
  }
};
S(yf, "uuid", "39ad6aad-84c8-4adf-a1e0-7f25313a9e7f");
var Jc = class tn extends Re {
  constructor(t) {
    super(t), S(this, "enabled", true), S(this, "onDisposed", new $()), S(this, "_absoluteMin"), S(this, "_absoluteMax"), S(this, "_meshes", []), this.components.add(tn.uuid, this), this._absoluteMin = tn.newBound(true), this._absoluteMax = tn.newBound(false);
  }
  static getDimensions(t) {
    const { min: e, max: n } = t, s = Math.abs(n.x - e.x), i = Math.abs(n.y - e.y), r = Math.abs(n.z - e.z), o = new Vector3();
    return o.subVectors(n, e).divideScalar(2).add(e), { width: s, height: i, depth: r, center: o };
  }
  static newBound(t) {
    const e = t ? 1 : -1;
    return new Vector3(
      e * Number.MAX_VALUE,
      e * Number.MAX_VALUE,
      e * Number.MAX_VALUE
    );
  }
  static getBounds(t, e, n) {
    const s = n || this.newBound(false), i = e || this.newBound(true);
    for (const r of t)
      r.x < i.x && (i.x = r.x), r.y < i.y && (i.y = r.y), r.z < i.z && (i.z = r.z), r.x > s.x && (s.x = r.x), r.y > s.y && (s.y = r.y), r.z > s.z && (s.z = r.z);
    return new Box3(e, n);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    const t = this.components.get(rn);
    for (const e of this._meshes)
      t.destroy(e);
    this._meshes = [], this.onDisposed.trigger(tn.uuid), this.onDisposed.reset();
  }
  get() {
    const t = this._absoluteMin.clone(), e = this._absoluteMax.clone();
    return new Box3(t, e);
  }
  getSphere() {
    const t = this._absoluteMin.clone(), e = this._absoluteMax.clone(), n = Math.abs((e.x - t.x) / 2), s = Math.abs((e.y - t.y) / 2), i = Math.abs((e.z - t.z) / 2), r = new Vector3(t.x + n, t.y + s, t.z + i), o = r.distanceTo(t);
    return new Sphere(r, o);
  }
  getMesh() {
    const t = new Box3(this._absoluteMin, this._absoluteMax), e = tn.getDimensions(t), { width: n, height: s, depth: i, center: r } = e, o = new BoxGeometry(n, s, i), l = new Mesh(o);
    return this._meshes.push(l), l.position.copy(r), l;
  }
  reset() {
    this._absoluteMin = tn.newBound(true), this._absoluteMax = tn.newBound(false);
  }
  add(t) {
    for (const e of t.items)
      this.addMesh(e.mesh);
  }
  addMesh(t, e) {
    if (!t.geometry.index)
      return;
    const n = tn.getFragmentBounds(t);
    t.updateMatrixWorld();
    const s = t.matrixWorld, i = new Matrix4(), r = t instanceof InstancedMesh, o = /* @__PURE__ */ new Set();
    if (e && t instanceof Js)
      for (const l of e) {
        const h = t.fragment.getInstancesIDs(l);
        if (h)
          for (const d of h)
            o.add(d);
      }
    else
      o.add(0);
    for (const l of o) {
      const h = n.min.clone(), d = n.max.clone();
      r && (t.getMatrixAt(l, i), h.applyMatrix4(i), d.applyMatrix4(i)), h.applyMatrix4(s), d.applyMatrix4(s), h.x < this._absoluteMin.x && (this._absoluteMin.x = h.x), h.y < this._absoluteMin.y && (this._absoluteMin.y = h.y), h.z < this._absoluteMin.z && (this._absoluteMin.z = h.z), h.x > this._absoluteMax.x && (this._absoluteMax.x = h.x), h.y > this._absoluteMax.y && (this._absoluteMax.y = h.y), h.z > this._absoluteMax.z && (this._absoluteMax.z = h.z), d.x > this._absoluteMax.x && (this._absoluteMax.x = d.x), d.y > this._absoluteMax.y && (this._absoluteMax.y = d.y), d.z > this._absoluteMax.z && (this._absoluteMax.z = d.z), d.x < this._absoluteMin.x && (this._absoluteMin.x = d.x), d.y < this._absoluteMin.y && (this._absoluteMin.y = d.y), d.z < this._absoluteMin.z && (this._absoluteMin.z = d.z);
    }
  }
  static getFragmentBounds(t) {
    const e = t.geometry.attributes.position, n = Number.MAX_VALUE, s = -n, i = new Vector3(n, n, n), r = new Vector3(s, s, s);
    if (!t.geometry.index)
      throw new Error("Geometry must be indexed!");
    const o = Array.from(t.geometry.index.array);
    for (let l = 0; l < o.length; l++) {
      if (l % 3 === 0 && o[l] === 0 && o[l + 1] === 0 && o[l + 2] === 0) {
        l += 2;
        continue;
      }
      const h = o[l], d = e.getX(h), m = e.getY(h), f = e.getZ(h);
      d < i.x && (i.x = d), m < i.y && (i.y = m), f < i.z && (i.z = f), d > r.x && (r.x = d), m > r.y && (r.y = m), f > r.z && (r.z = f);
    }
    return new Box3(i, r);
  }
};
S(Jc, "uuid", "d1444724-dba6-4cdd-a0c7-68ee1450d166");
var $c = Jc;
var Na = /* @__PURE__ */ new Set([
  1123145078,
  574549367,
  1675464909,
  2059837836,
  3798115385,
  32440307,
  3125803723,
  3207858831,
  2740243338,
  2624227202,
  4240577450,
  3615266464,
  3724593414,
  220341763,
  477187591,
  1878645084,
  1300840506,
  3303107099,
  1607154358,
  1878645084,
  846575682,
  1351298697,
  2417041796,
  3049322572,
  3331915920,
  1416205885,
  776857604,
  3285139300,
  3958052878,
  2827736869,
  2732653382,
  673634403,
  3448662350,
  4142052618,
  2924175390,
  803316827,
  2556980723,
  1809719519,
  2205249479,
  807026263,
  3737207727,
  1660063152,
  2347385850,
  3940055652,
  2705031697,
  3732776249,
  2485617015,
  2611217952,
  1704287377,
  2937912522,
  2770003689,
  1281925730,
  1484403080,
  3448662350,
  4142052618,
  3800577675,
  4006246654,
  3590301190,
  1383045692,
  2775532180,
  2047409740,
  370225590,
  3593883385,
  2665983363,
  4124623270,
  812098782,
  3649129432,
  987898635,
  1105321065,
  3510044353,
  1635779807,
  2603310189,
  3406155212,
  1310608509,
  4261334040,
  2736907675,
  3649129432,
  1136057603,
  1260505505,
  4182860854,
  2713105998,
  2898889636,
  59481748,
  3749851601,
  3486308946,
  3150382593,
  1062206242,
  3264961684,
  15328376,
  1485152156,
  370225590,
  1981873012,
  2859738748,
  45288368,
  2614616156,
  2732653382,
  775493141,
  2147822146,
  2601014836,
  2629017746,
  1186437898,
  2367409068,
  1213902940,
  3632507154,
  3900360178,
  476780140,
  1472233963,
  2804161546,
  3008276851,
  738692330,
  374418227,
  315944413,
  3905492369,
  3570813810,
  2571569899,
  178912537,
  2294589976,
  1437953363,
  2133299955,
  572779678,
  3092502836,
  388784114,
  2624227202,
  1425443689,
  3057273783,
  2347385850,
  1682466193,
  2519244187,
  2839578677,
  3958567839,
  2513912981,
  2830218821,
  427810014
]);
var eh = class th extends Re {
  constructor(t) {
    super(t), S(this, "enabled", true), t.add(th.uuid, this);
  }
  /**
   * Exports all the properties of an IFC into an array of JS objects.
   * @param webIfc The instance of [web-ifc]{@link https://github.com/ThatOpen/engine_web-ifc} to use.
   * @param modelID ID of the IFC model whose properties to extract.
   * @param indirect whether to get the indirect relationships as well.
   * @param recursiveSpatial whether to get the properties of spatial items recursively
   * to make the location data available (e.g. absolute position of building).
   */
  async export(t, e, n = false, s = true) {
    const i = {}, r = new Set(t.GetIfcEntityList(e)), o = /* @__PURE__ */ new Set([
      IFCPROJECT,
      IFCSITE,
      IFCBUILDING,
      IFCBUILDINGSTOREY,
      IFCSPACE
    ]);
    for (const l of o)
      r.add(l);
    for (const l of r) {
      if (Na.has(l))
        continue;
      const h = o.has(l) && s, d = t.GetLineIDsWithType(e, l);
      for (const m of d) {
        const f = t.GetLine(0, m, h, n);
        i[f.expressID] = f;
      }
    }
    return i;
  }
};
S(eh, "uuid", "b32c4332-cd67-436e-ba7f-196646c7a635");
var wf = eh;
var nh = class sh extends Re {
  constructor(t) {
    super(t), S(this, "onDisposed", new $()), S(this, "onFragmentsLoaded", new $()), S(this, "onFragmentsDisposed", new $()), S(this, "list", /* @__PURE__ */ new Map()), S(this, "groups", /* @__PURE__ */ new Map()), S(this, "enabled", true), S(this, "baseCoordinationModel", ""), S(this, "_loader", new Hi()), this.components.add(sh.uuid, this);
  }
  /** The list of meshes of the created fragments. */
  get meshes() {
    const t = [];
    for (const [e, n] of this.list)
      t.push(n.mesh);
    return t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.groups)
      e.dispose(true);
    this.baseCoordinationModel = "", this.groups.clear(), this.list.clear(), this.onFragmentsLoaded.reset(), this.onFragmentsDisposed.reset(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  disposeGroup(t) {
    const { uuid: e } = t, n = [];
    for (const s of t.items)
      n.push(s.id), this.list.delete(s.id);
    t.dispose(true), this.groups.delete(t.uuid), this.onFragmentsDisposed.trigger({
      groupID: e,
      fragmentIDs: n
    });
  }
  /**
   * Loads a binar file that contain fragment geometry.
   * @param data - The binary data to load.
   * @param config - Optional configuration for loading.
   * @param config.coordinate - Whether to apply coordinate transformation. Default is true.
   * @param config.properties - Ifc properties to set on the loaded fragments. Not to be used when streaming.
   * @returns The loaded FragmentsGroup.
   */
  load(t, e) {
    const n = { coordinate: true, ...e }, { coordinate: s, name: i, properties: r, relationsMap: o } = n, l = this._loader.import(t);
    i && (l.name = i);
    for (const h of l.items)
      h.group = l, this.list.set(h.id, h);
    return s && this.coordinate([l]), this.groups.set(l.uuid, l), r && l.setLocalProperties(r), o && this.components.get(Xr).setRelationMap(l, o), this.onFragmentsLoaded.trigger(l), l;
  }
  /**
   * Export the specified fragments.
   * @param group - the fragments group to be exported.
   * @returns the exported data as binary buffer.
   */
  export(t) {
    return this._loader.export(t);
  }
  coordinate(t = Array.from(this.groups.values())) {
    if (this.baseCoordinationModel.length === 0) {
      const n = t.pop();
      if (!n)
        return;
      this.baseCoordinationModel = n.uuid;
    }
    if (!t.length)
      return;
    const e = this.groups.get(this.baseCoordinationModel);
    if (!e) {
      console.log("No base model found for coordination!");
      return;
    }
    for (const n of t)
      n !== e && (n.position.set(0, 0, 0), n.rotation.set(0, 0, 0), n.scale.set(1, 1, 1), n.updateMatrix(), n.applyMatrix4(n.coordinationMatrix.clone().invert()), n.applyMatrix4(e.coordinationMatrix));
  }
};
S(nh, "uuid", "fef46874-46a3-461b-8c44-2922ab77c806");
var We = nh;
var Cf = /* @__PURE__ */ new Map([
  [
    IFCRELAGGREGATES,
    {
      forRelating: "IsDecomposedBy",
      forRelated: "Decomposes"
    }
  ],
  [
    IFCRELASSOCIATESMATERIAL,
    {
      forRelating: "AssociatedTo",
      forRelated: "HasAssociations"
    }
  ],
  [
    IFCRELASSOCIATESCLASSIFICATION,
    {
      forRelating: "ClassificationForObjects",
      forRelated: "HasAssociations"
    }
  ],
  [
    IFCRELASSIGNSTOGROUP,
    {
      forRelating: "IsGroupedBy",
      forRelated: "HasAssignments"
    }
  ],
  [
    IFCRELDEFINESBYPROPERTIES,
    {
      forRelated: "IsDefinedBy",
      forRelating: "DefinesOcurrence"
    }
  ],
  [
    IFCRELDEFINESBYTYPE,
    {
      forRelated: "IsTypedBy",
      forRelating: "Types"
    }
  ],
  [
    IFCRELDEFINESBYTEMPLATE,
    {
      forRelated: "IsDefinedBy",
      forRelating: "Defines"
    }
  ],
  [
    IFCRELCONTAINEDINSPATIALSTRUCTURE,
    {
      forRelated: "ContainedInStructure",
      forRelating: "ContainsElements"
    }
  ]
]);
var ih = class ya extends Re {
  constructor(t) {
    super(t), S(this, "onDisposed", new $()), S(this, "enabled", true), S(this, "onRelationsIndexed", new $()), S(this, "_relToAttributesMap", Cf), S(this, "_inverseAttributes", [
      "IsDecomposedBy",
      "Decomposes",
      "AssociatedTo",
      "HasAssociations",
      "ClassificationForObjects",
      "IsGroupedBy",
      "HasAssignments",
      "IsDefinedBy",
      "DefinesOcurrence",
      "IsTypedBy",
      "Types",
      "Defines",
      "ContainedInStructure",
      "ContainsElements"
    ]), S(this, "_ifcRels", [
      IFCRELAGGREGATES,
      IFCRELASSOCIATESMATERIAL,
      IFCRELASSOCIATESCLASSIFICATION,
      IFCRELASSIGNSTOGROUP,
      IFCRELDEFINESBYPROPERTIES,
      IFCRELDEFINESBYTYPE,
      IFCRELDEFINESBYTEMPLATE,
      IFCRELCONTAINEDINSPATIALSTRUCTURE
    ]), S(this, "relationMaps", {}), S(this, "onFragmentsDisposed", (e) => {
      delete this.relationMaps[e.groupID];
    }), this.components.add(ya.uuid, this), t.get(We).onFragmentsDisposed.add(this.onFragmentsDisposed);
  }
  indexRelations(t, e, n, s) {
    const i = Object.keys(e).find(
      (m) => m.startsWith("Relating")
    ), r = Object.keys(e).find(
      (m) => m.startsWith("Related")
    );
    if (!(i && r))
      return;
    const o = e[i].value, l = e[r].map((m) => m.value), h = t.get(o) ?? /* @__PURE__ */ new Map(), d = this._inverseAttributes.indexOf(s);
    h.set(d, l), t.set(o, h);
    for (const m of l) {
      const f = t.get(m) ?? /* @__PURE__ */ new Map(), g = this._inverseAttributes.indexOf(n), I = f.get(g) ?? [];
      I.push(o), f.set(g, I), t.set(m, f);
    }
  }
  /**
   * Adds a relation map to the model's relations map.
   *
   * @param model - The `FragmentsGroup` model to which the relation map will be added.
   * @param relationMap - The `RelationsMap` to be added to the model's relations map.
   *
   * @fires onRelationsIndexed - Triggers an event with the model's UUID and the added relation map.
   */
  setRelationMap(t, e) {
    this.relationMaps[t.uuid] = e, this.onRelationsIndexed.trigger({
      modelID: t.uuid,
      relationsMap: e
    });
  }
  /**
   * Processes a given model to index its IFC entities relations based on predefined inverse attributes.
   * This method iterates through each specified inverse attribute, retrieves the corresponding relations,
   * and maps them in a structured way to facilitate quick access to related entities.
   *
   * The process involves querying the model for each relation type associated with the inverse attributes
   * and updating the internal relationMaps with the relationships found. This map is keyed by the model's UUID
   * and contains a nested map where each key is an entity's expressID and its value is another map.
   * This inner map's keys are the indices of the inverse attributes, and its values are arrays of expressIDs
   * of entities that are related through that attribute.
   *
   * @param model The `FragmentsGroup` model to be processed. It must have properties loaded.
   * @returns A promise that resolves to the relations map for the processed model. This map is a detailed
   * representation of the relations indexed by entity expressIDs and relation types.
   * @throws An error if the model does not have properties loaded.
   */
  async process(t) {
    if (!t.hasProperties)
      throw new Error("FragmentsGroup properties not found");
    let e = this.relationMaps[t.uuid];
    if (e)
      return e;
    e = /* @__PURE__ */ new Map();
    for (const n of this._ifcRels) {
      const s = await t.getAllPropertiesOfType(n);
      if (!s)
        continue;
      const i = this._relToAttributesMap.get(n);
      if (!i)
        continue;
      const { forRelated: r, forRelating: o } = i;
      for (const l in s) {
        const h = s[l];
        this.indexRelations(e, h, r, o);
      }
    }
    return this.setRelationMap(t, e), e;
  }
  /**
   * Processes a given model from a WebIfc API to index its IFC entities relations.
   *
   * @param ifcApi - The WebIfc API instance from which to retrieve the model's properties.
   * @param modelID - The unique identifier of the model within the WebIfc API.
   * @returns A promise that resolves to the relations map for the processed model.
   *          This map is a detailed representation of the relations indexed by entity expressIDs and relation types.
   */
  async processFromWebIfc(t, e) {
    const n = /* @__PURE__ */ new Map();
    for (const s of this._ifcRels) {
      const i = this._relToAttributesMap.get(s);
      if (!i)
        continue;
      const { forRelated: r, forRelating: o } = i, l = t.GetLineIDsWithType(e, s);
      for (let h = 0; h < l.size(); h++) {
        const d = await t.properties.getItemProperties(
          e,
          l.get(h)
        );
        this.indexRelations(n, d, r, o);
      }
    }
    return this.onRelationsIndexed.trigger({
      modelID: e.toString(),
      relationsMap: n
    }), n;
  }
  /**
   * Retrieves the relations of a specific entity within a model based on the given relation name.
   * This method searches the indexed relation maps for the specified model and entity,
   * returning the IDs of related entities if a match is found.
   *
   * @param model The `FragmentsGroup` model containing the entity.
   * @param expressID The unique identifier of the entity within the model.
   * @param relationName The IFC schema inverse attribute of the relation to search for (e.g., "IsDefinedBy", "ContainsElements").
   * @returns An array of express IDs representing the related entities, or `null` if no relations are found
   * or the specified relation name is not indexed.
   */
  getEntityRelations(t, e, n) {
    const s = this.relationMaps[t.uuid];
    if (!s)
      return null;
    const i = s.get(e), r = this._inverseAttributes.indexOf(n);
    return !i || r === -1 ? null : i.get(r) || null;
  }
  /**
   * Serializes the relations of a given relation map into a JSON string.
   * This method iterates through the relations in the given map, organizing them into a structured object where each key is an expressID of an entity,
   * and its value is another object mapping relation indices to arrays of related entity expressIDs.
   * The resulting object is then serialized into a JSON string.
   *
   * @param relationMap - The map of relations to be serialized. The map keys are expressIDs of entities, and the values are maps where each key is a relation type ID and its value is an array of expressIDs of entities related through that relation type.
   * @returns A JSON string representing the serialized relations of the given relation map.
   */
  serializeRelations(t) {
    const e = {};
    for (const [n, s] of t.entries()) {
      e[n] || (e[n] = {});
      for (const [i, r] of s.entries())
        e[n][i] = r;
    }
    return JSON.stringify(e);
  }
  /**
   * Serializes the relations of a specific model into a JSON string.
   * This method iterates through the relations indexed for the given model,
   * organizing them into a structured object where each key is an expressID of an entity,
   * and its value is another object mapping relation indices to arrays of related entity expressIDs.
   * The resulting object is then serialized into a JSON string.
   *
   * @param model The `FragmentsGroup` model whose relations are to be serialized.
   * @returns A JSON string representing the serialized relations of the specified model.
   * If the model has no indexed relations, `null` is returned.
   */
  serializeModelRelations(t) {
    const e = this.relationMaps[t.uuid];
    return e ? this.serializeRelations(e) : null;
  }
  /**
   * Serializes all relations of every model processed by the indexer into a JSON string.
   * This method iterates through each model's relations indexed in `relationMaps`, organizing them
   * into a structured JSON object. Each top-level key in this object corresponds to a model's UUID,
   * and its value is another object mapping entity expressIDs to their related entities, categorized
   * by relation types. The structure facilitates easy access to any entity's relations across all models.
   *
   * @returns A JSON string representing the serialized relations of all models processed by the indexer.
   *          If no relations have been indexed, an empty object is returned as a JSON string.
   */
  serializeAllRelations() {
    const t = {};
    for (const e in this.relationMaps) {
      const n = this.relationMaps[e], s = {};
      for (const [i, r] of n.entries()) {
        s[i] || (s[i] = {});
        for (const [o, l] of r.entries())
          s[i][o] = l;
      }
      t[e] = s;
    }
    return JSON.stringify(t);
  }
  /**
   * Converts a JSON string representing relations between entities into a structured map.
   * This method parses the JSON string to reconstruct the relations map that indexes
   * entity relations by their express IDs. The outer map keys are the express IDs of entities,
   * and the values are maps where each key is a relation type ID and its value is an array
   * of express IDs of entities related through that relation type.
   *
   * @param json The JSON string to be parsed into the relations map.
   * @returns A `Map` where the key is the express ID of an entity as a number, and the value
   * is another `Map`. This inner map's key is the relation type ID as a number, and its value
   * is an array of express IDs (as numbers) of entities related through that relation type.
   */
  getRelationsMapFromJSON(t) {
    const e = JSON.parse(t), n = /* @__PURE__ */ new Map();
    for (const s in e) {
      const i = e[s], r = /* @__PURE__ */ new Map();
      for (const o in i)
        r.set(Number(o), i[o]);
      n.set(Number(s), r);
    }
    return n;
  }
  /**
   * Disposes the component, cleaning up resources and detaching event listeners.
   * This ensures that the component is properly cleaned up and does not leave behind any
   * references that could prevent garbage collection.
   */
  dispose() {
    this.relationMaps = {}, this.components.get(We).onFragmentsDisposed.remove(this.onFragmentsDisposed), this.onDisposed.trigger(ya.uuid), this.onDisposed.reset();
  }
};
S(ih, "uuid", "23a889ab-83b3-44a4-8bee-ead83438370b");
var Xr = ih;
var rh = {
  950732822: "IFCURIREFERENCE",
  4075327185: "IFCTIME",
  1209108979: "IFCTEMPERATURERATEOFCHANGEMEASURE",
  3457685358: "IFCSOUNDPRESSURELEVELMEASURE",
  4157543285: "IFCSOUNDPOWERLEVELMEASURE",
  2798247006: "IFCPROPERTYSETDEFINITIONSET",
  1790229001: "IFCPOSITIVEINTEGER",
  525895558: "IFCNONNEGATIVELENGTHMEASURE",
  1774176899: "IFCLINEINDEX",
  1275358634: "IFCLANGUAGEID",
  2541165894: "IFCDURATION",
  3701338814: "IFCDAYINWEEKNUMBER",
  2195413836: "IFCDATETIME",
  937566702: "IFCDATE",
  1683019596: "IFCCARDINALPOINTREFERENCE",
  2314439260: "IFCBINARY",
  1500781891: "IFCAREADENSITYMEASURE",
  3683503648: "IFCARCINDEX",
  4065007721: "IFCYEARNUMBER",
  1718600412: "IFCWARPINGMOMENTMEASURE",
  51269191: "IFCWARPINGCONSTANTMEASURE",
  2593997549: "IFCVOLUMETRICFLOWRATEMEASURE",
  3458127941: "IFCVOLUMEMEASURE",
  3345633955: "IFCVAPORPERMEABILITYMEASURE",
  1278329552: "IFCTORQUEMEASURE",
  2591213694: "IFCTIMESTAMP",
  2726807636: "IFCTIMEMEASURE",
  743184107: "IFCTHERMODYNAMICTEMPERATUREMEASURE",
  2016195849: "IFCTHERMALTRANSMITTANCEMEASURE",
  857959152: "IFCTHERMALRESISTANCEMEASURE",
  2281867870: "IFCTHERMALEXPANSIONCOEFFICIENTMEASURE",
  2645777649: "IFCTHERMALCONDUCTIVITYMEASURE",
  232962298: "IFCTHERMALADMITTANCEMEASURE",
  296282323: "IFCTEXTTRANSFORMATION",
  603696268: "IFCTEXTFONTNAME",
  3490877962: "IFCTEXTDECORATION",
  1460886941: "IFCTEXTALIGNMENT",
  2801250643: "IFCTEXT",
  58845555: "IFCTEMPERATUREGRADIENTMEASURE",
  361837227: "IFCSPECULARROUGHNESS",
  2757832317: "IFCSPECULAREXPONENT",
  3477203348: "IFCSPECIFICHEATCAPACITYMEASURE",
  993287707: "IFCSOUNDPRESSUREMEASURE",
  846465480: "IFCSOUNDPOWERMEASURE",
  3471399674: "IFCSOLIDANGLEMEASURE",
  408310005: "IFCSHEARMODULUSMEASURE",
  2190458107: "IFCSECTIONALAREAINTEGRALMEASURE",
  3467162246: "IFCSECTIONMODULUSMEASURE",
  2766185779: "IFCSECONDINMINUTE",
  3211557302: "IFCROTATIONALSTIFFNESSMEASURE",
  1755127002: "IFCROTATIONALMASSMEASURE",
  2133746277: "IFCROTATIONALFREQUENCYMEASURE",
  200335297: "IFCREAL",
  96294661: "IFCRATIOMEASURE",
  3972513137: "IFCRADIOACTIVITYMEASURE",
  3665567075: "IFCPRESSUREMEASURE",
  2169031380: "IFCPRESENTABLETEXT",
  1364037233: "IFCPOWERMEASURE",
  1245737093: "IFCPOSITIVERATIOMEASURE",
  3054510233: "IFCPOSITIVEPLANEANGLEMEASURE",
  2815919920: "IFCPOSITIVELENGTHMEASURE",
  4042175685: "IFCPLANEANGLEMEASURE",
  2642773653: "IFCPLANARFORCEMEASURE",
  2260317790: "IFCPARAMETERVALUE",
  929793134: "IFCPHMEASURE",
  2395907400: "IFCNUMERICMEASURE",
  2095195183: "IFCNORMALISEDRATIOMEASURE",
  765770214: "IFCMONTHINYEARNUMBER",
  2615040989: "IFCMONETARYMEASURE",
  3114022597: "IFCMOMENTOFINERTIAMEASURE",
  1648970520: "IFCMOLECULARWEIGHTMEASURE",
  3177669450: "IFCMOISTUREDIFFUSIVITYMEASURE",
  1753493141: "IFCMODULUSOFSUBGRADEREACTIONMEASURE",
  1052454078: "IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE",
  2173214787: "IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE",
  3341486342: "IFCMODULUSOFELASTICITYMEASURE",
  102610177: "IFCMINUTEINHOUR",
  3531705166: "IFCMASSPERLENGTHMEASURE",
  3124614049: "IFCMASSMEASURE",
  4017473158: "IFCMASSFLOWRATEMEASURE",
  1477762836: "IFCMASSDENSITYMEASURE",
  2486716878: "IFCMAGNETICFLUXMEASURE",
  286949696: "IFCMAGNETICFLUXDENSITYMEASURE",
  151039812: "IFCLUMINOUSINTENSITYMEASURE",
  2755797622: "IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE",
  2095003142: "IFCLUMINOUSFLUXMEASURE",
  503418787: "IFCLOGICAL",
  3086160713: "IFCLINEARVELOCITYMEASURE",
  1307019551: "IFCLINEARSTIFFNESSMEASURE",
  2128979029: "IFCLINEARMOMENTMEASURE",
  191860431: "IFCLINEARFORCEMEASURE",
  1243674935: "IFCLENGTHMEASURE",
  3258342251: "IFCLABEL",
  2054016361: "IFCKINEMATICVISCOSITYMEASURE",
  3192672207: "IFCISOTHERMALMOISTURECAPACITYMEASURE",
  3686016028: "IFCIONCONCENTRATIONMEASURE",
  3809634241: "IFCINTEGERCOUNTRATEMEASURE",
  1939436016: "IFCINTEGER",
  2679005408: "IFCINDUCTANCEMEASURE",
  3358199106: "IFCILLUMINANCEMEASURE",
  983778844: "IFCIDENTIFIER",
  2589826445: "IFCHOURINDAY",
  1158859006: "IFCHEATINGVALUEMEASURE",
  3113092358: "IFCHEATFLUXDENSITYMEASURE",
  3064340077: "IFCGLOBALLYUNIQUEID",
  3044325142: "IFCFREQUENCYMEASURE",
  1361398929: "IFCFORCEMEASURE",
  2590844177: "IFCFONTWEIGHT",
  2715512545: "IFCFONTVARIANT",
  1102727119: "IFCFONTSTYLE",
  2078135608: "IFCENERGYMEASURE",
  2506197118: "IFCELECTRICVOLTAGEMEASURE",
  2951915441: "IFCELECTRICRESISTANCEMEASURE",
  3790457270: "IFCELECTRICCURRENTMEASURE",
  2093906313: "IFCELECTRICCONDUCTANCEMEASURE",
  3818826038: "IFCELECTRICCHARGEMEASURE",
  1827137117: "IFCELECTRICCAPACITANCEMEASURE",
  69416015: "IFCDYNAMICVISCOSITYMEASURE",
  524656162: "IFCDOSEEQUIVALENTMEASURE",
  4134073009: "IFCDIMENSIONCOUNT",
  1514641115: "IFCDESCRIPTIVEMEASURE",
  300323983: "IFCDAYLIGHTSAVINGHOUR",
  86635668: "IFCDAYINMONTHNUMBER",
  94842927: "IFCCURVATUREMEASURE",
  1778710042: "IFCCOUNTMEASURE",
  3238673880: "IFCCONTEXTDEPENDENTMEASURE",
  3812528620: "IFCCOMPOUNDPLANEANGLEMEASURE",
  2991860651: "IFCCOMPLEXNUMBER",
  1867003952: "IFCBOXALIGNMENT",
  2735952531: "IFCBOOLEAN",
  2650437152: "IFCAREAMEASURE",
  632304761: "IFCANGULARVELOCITYMEASURE",
  360377573: "IFCAMOUNTOFSUBSTANCEMEASURE",
  4182062534: "IFCACCELERATIONMEASURE",
  3699917729: "IFCABSORBEDDOSEMEASURE",
  1971632696: "IFCGEOSLICE",
  2680139844: "IFCGEOMODEL",
  24726584: "IFCELECTRICFLOWTREATMENTDEVICE",
  3693000487: "IFCDISTRIBUTIONBOARD",
  3460952963: "IFCCONVEYORSEGMENT",
  3999819293: "IFCCAISSONFOUNDATION",
  3314249567: "IFCBOREHOLE",
  4196446775: "IFCBEARING",
  325726236: "IFCALIGNMENT",
  3425753595: "IFCTRACKELEMENT",
  991950508: "IFCSIGNAL",
  3798194928: "IFCREINFORCEDSOIL",
  3290496277: "IFCRAIL",
  1383356374: "IFCPAVEMENT",
  2182337498: "IFCNAVIGATIONELEMENT",
  234836483: "IFCMOORINGDEVICE",
  2078563270: "IFCMOBILETELECOMMUNICATIONSAPPLIANCE",
  1638804497: "IFCLIQUIDTERMINAL",
  1154579445: "IFCLINEARPOSITIONINGELEMENT",
  2696325953: "IFCKERB",
  2713699986: "IFCGEOTECHNICALASSEMBLY",
  2142170206: "IFCELECTRICFLOWTREATMENTDEVICETYPE",
  3376911765: "IFCEARTHWORKSFILL",
  1077100507: "IFCEARTHWORKSELEMENT",
  3071239417: "IFCEARTHWORKSCUT",
  479945903: "IFCDISTRIBUTIONBOARDTYPE",
  3426335179: "IFCDEEPFOUNDATION",
  1502416096: "IFCCOURSE",
  2940368186: "IFCCONVEYORSEGMENTTYPE",
  3203706013: "IFCCAISSONFOUNDATIONTYPE",
  3862327254: "IFCBUILTSYSTEM",
  1876633798: "IFCBUILTELEMENT",
  963979645: "IFCBRIDGEPART",
  644574406: "IFCBRIDGE",
  3649138523: "IFCBEARINGTYPE",
  1662888072: "IFCALIGNMENTVERTICAL",
  317615605: "IFCALIGNMENTSEGMENT",
  1545765605: "IFCALIGNMENTHORIZONTAL",
  4266260250: "IFCALIGNMENTCANT",
  3956297820: "IFCVIBRATIONDAMPERTYPE",
  1530820697: "IFCVIBRATIONDAMPER",
  840318589: "IFCVEHICLE",
  1953115116: "IFCTRANSPORTATIONDEVICE",
  618700268: "IFCTRACKELEMENTTYPE",
  2281632017: "IFCTENDONCONDUITTYPE",
  3663046924: "IFCTENDONCONDUIT",
  42703149: "IFCSINESPIRAL",
  1894708472: "IFCSIGNALTYPE",
  3599934289: "IFCSIGNTYPE",
  33720170: "IFCSIGN",
  1027922057: "IFCSEVENTHORDERPOLYNOMIALSPIRAL",
  544395925: "IFCSEGMENTEDREFERENCECURVE",
  3649235739: "IFCSECONDORDERPOLYNOMIALSPIRAL",
  550521510: "IFCROADPART",
  146592293: "IFCROAD",
  3818125796: "IFCRELADHERESTOELEMENT",
  4021432810: "IFCREFERENT",
  1891881377: "IFCRAILWAYPART",
  3992365140: "IFCRAILWAY",
  1763565496: "IFCRAILTYPE",
  1946335990: "IFCPOSITIONINGELEMENT",
  514975943: "IFCPAVEMENTTYPE",
  506776471: "IFCNAVIGATIONELEMENTTYPE",
  710110818: "IFCMOORINGDEVICETYPE",
  1950438474: "IFCMOBILETELECOMMUNICATIONSAPPLIANCETYPE",
  976884017: "IFCMARINEPART",
  525669439: "IFCMARINEFACILITY",
  1770583370: "IFCLIQUIDTERMINALTYPE",
  2176059722: "IFCLINEARELEMENT",
  679976338: "IFCKERBTYPE",
  3948183225: "IFCIMPACTPROTECTIONDEVICETYPE",
  2568555532: "IFCIMPACTPROTECTIONDEVICE",
  2898700619: "IFCGRADIENTCURVE",
  1594536857: "IFCGEOTECHNICALSTRATUM",
  4230923436: "IFCGEOTECHNICALELEMENT",
  4228831410: "IFCFACILITYPARTCOMMON",
  1310830890: "IFCFACILITYPART",
  24185140: "IFCFACILITY",
  4234616927: "IFCDIRECTRIXDERIVEDREFERENCESWEPTAREASOLID",
  1306400036: "IFCDEEPFOUNDATIONTYPE",
  4189326743: "IFCCOURSETYPE",
  2000195564: "IFCCOSINESPIRAL",
  3497074424: "IFCCLOTHOID",
  1626504194: "IFCBUILTELEMENTTYPE",
  3651464721: "IFCVEHICLETYPE",
  1229763772: "IFCTRIANGULATEDIRREGULARNETWORK",
  3665877780: "IFCTRANSPORTATIONDEVICETYPE",
  782932809: "IFCTHIRDORDERPOLYNOMIALSPIRAL",
  2735484536: "IFCSPIRAL",
  1356537516: "IFCSECTIONEDSURFACE",
  1290935644: "IFCSECTIONEDSOLIDHORIZONTAL",
  1862484736: "IFCSECTIONEDSOLID",
  1441486842: "IFCRELPOSITIONS",
  1033248425: "IFCRELASSOCIATESPROFILEDEF",
  3381221214: "IFCPOLYNOMIALCURVE",
  2485787929: "IFCOFFSETCURVEBYDISTANCES",
  590820931: "IFCOFFSETCURVE",
  3465909080: "IFCINDEXEDPOLYGONALTEXTUREMAP",
  593015953: "IFCDIRECTRIXCURVESWEPTAREASOLID",
  4212018352: "IFCCURVESEGMENT",
  3425423356: "IFCAXIS2PLACEMENTLINEAR",
  823603102: "IFCSEGMENT",
  2165702409: "IFCPOINTBYDISTANCEEXPRESSION",
  182550632: "IFCOPENCROSSPROFILEDEF",
  388784114: "IFCLINEARPLACEMENT",
  536804194: "IFCALIGNMENTHORIZONTALSEGMENT",
  3752311538: "IFCALIGNMENTCANTSEGMENT",
  1010789467: "IFCTEXTURECOORDINATEINDICESWITHVOIDS",
  222769930: "IFCTEXTURECOORDINATEINDICES",
  2691318326: "IFCQUANTITYNUMBER",
  3633395639: "IFCALIGNMENTVERTICALSEGMENT",
  2879124712: "IFCALIGNMENTPARAMETERSEGMENT",
  25142252: "IFCCONTROLLER",
  3087945054: "IFCALARM",
  4288193352: "IFCACTUATOR",
  630975310: "IFCUNITARYCONTROLELEMENT",
  4086658281: "IFCSENSOR",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  182646315: "IFCFLOWINSTRUMENT",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  819412036: "IFCFILTER",
  3415622556: "IFCFAN",
  1003880860: "IFCELECTRICTIMECONTROL",
  402227799: "IFCELECTRICMOTOR",
  264262732: "IFCELECTRICGENERATOR",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  1904799276: "IFCELECTRICAPPLIANCE",
  1360408905: "IFCDUCTSILENCER",
  3518393246: "IFCDUCTSEGMENT",
  342316401: "IFCDUCTFITTING",
  562808652: "IFCDISTRIBUTIONCIRCUIT",
  4074379575: "IFCDAMPER",
  3640358203: "IFCCOOLINGTOWER",
  4136498852: "IFCCOOLEDBEAM",
  2272882330: "IFCCONDENSER",
  3571504051: "IFCCOMPRESSOR",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  639361253: "IFCCOIL",
  3902619387: "IFCCHILLER",
  4217484030: "IFCCABLESEGMENT",
  1051757585: "IFCCABLEFITTING",
  3758799889: "IFCCABLECARRIERSEGMENT",
  635142910: "IFCCABLECARRIERFITTING",
  2938176219: "IFCBURNER",
  32344328: "IFCBOILER",
  2906023776: "IFCBEAMSTANDARDCASE",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  177149247: "IFCAIRTERMINALBOX",
  1634111441: "IFCAIRTERMINAL",
  486154966: "IFCWINDOWSTANDARDCASE",
  4237592921: "IFCWASTETERMINAL",
  4156078855: "IFCWALLELEMENTEDCASE",
  4207607924: "IFCVALVE",
  4292641817: "IFCUNITARYEQUIPMENT",
  3179687236: "IFCUNITARYCONTROLELEMENTTYPE",
  3026737570: "IFCTUBEBUNDLE",
  3825984169: "IFCTRANSFORMER",
  812556717: "IFCTANK",
  1162798199: "IFCSWITCHINGDEVICE",
  385403989: "IFCSTRUCTURALLOADCASE",
  1404847402: "IFCSTACKTERMINAL",
  1999602285: "IFCSPACEHEATER",
  3420628829: "IFCSOLARDEVICE",
  3027962421: "IFCSLABSTANDARDCASE",
  3127900445: "IFCSLABELEMENTEDCASE",
  1329646415: "IFCSHADINGDEVICE",
  3053780830: "IFCSANITARYTERMINAL",
  2572171363: "IFCREINFORCINGBARTYPE",
  1232101972: "IFCRATIONALBSPLINECURVEWITHKNOTS",
  90941305: "IFCPUMP",
  655969474: "IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",
  738039164: "IFCPROTECTIVEDEVICE",
  1156407060: "IFCPLATESTANDARDCASE",
  3612865200: "IFCPIPESEGMENT",
  310824031: "IFCPIPEFITTING",
  3694346114: "IFCOUTLET",
  144952367: "IFCOUTERBOUNDARYCURVE",
  2474470126: "IFCMOTORCONNECTION",
  1911478936: "IFCMEMBERSTANDARDCASE",
  1437502449: "IFCMEDICALDEVICE",
  629592764: "IFCLIGHTFIXTURE",
  76236018: "IFCLAMP",
  2176052936: "IFCJUNCTIONBOX",
  4175244083: "IFCINTERCEPTOR",
  2068733104: "IFCHUMIDIFIER",
  3319311131: "IFCHEATEXCHANGER",
  2188021234: "IFCFLOWMETER",
  1209101575: "IFCEXTERNALSPATIALELEMENT",
  484807127: "IFCEVAPORATOR",
  3747195512: "IFCEVAPORATIVECOOLER",
  2814081492: "IFCENGINE",
  2417008758: "IFCELECTRICDISTRIBUTIONBOARDTYPE",
  3242481149: "IFCDOORSTANDARDCASE",
  3205830791: "IFCDISTRIBUTIONSYSTEM",
  400855858: "IFCCOMMUNICATIONSAPPLIANCETYPE",
  905975707: "IFCCOLUMNSTANDARDCASE",
  1677625105: "IFCCIVILELEMENT",
  3296154744: "IFCCHIMNEY",
  2674252688: "IFCCABLEFITTINGTYPE",
  2188180465: "IFCBURNERTYPE",
  1177604601: "IFCBUILDINGSYSTEM",
  39481116: "IFCBUILDINGELEMENTPARTTYPE",
  1136057603: "IFCBOUNDARYCURVE",
  2461110595: "IFCBSPLINECURVEWITHKNOTS",
  1532957894: "IFCAUDIOVISUALAPPLIANCETYPE",
  4088093105: "IFCWORKCALENDAR",
  4009809668: "IFCWINDOWTYPE",
  926996030: "IFCVOIDINGFEATURE",
  2391383451: "IFCVIBRATIONISOLATOR",
  2415094496: "IFCTENDONTYPE",
  3081323446: "IFCTENDONANCHORTYPE",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  3101698114: "IFCSURFACEFEATURE",
  3657597509: "IFCSTRUCTURALSURFACEACTION",
  2757150158: "IFCSTRUCTURALCURVEREACTION",
  1004757350: "IFCSTRUCTURALCURVEACTION",
  338393293: "IFCSTAIRTYPE",
  1072016465: "IFCSOLARDEVICETYPE",
  4074543187: "IFCSHADINGDEVICETYPE",
  2157484638: "IFCSEAMCURVE",
  2781568857: "IFCROOFTYPE",
  2310774935: "IFCREINFORCINGMESHTYPE",
  964333572: "IFCREINFORCINGELEMENTTYPE",
  683857671: "IFCRATIONALBSPLINESURFACEWITHKNOTS",
  1469900589: "IFCRAMPTYPE",
  2839578677: "IFCPOLYGONALFACESET",
  1158309216: "IFCPILETYPE",
  3079942009: "IFCOPENINGSTANDARDCASE",
  1114901282: "IFCMEDICALDEVICETYPE",
  3113134337: "IFCINTERSECTIONCURVE",
  3946677679: "IFCINTERCEPTORTYPE",
  2571569899: "IFCINDEXEDPOLYCURVE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  1509553395: "IFCFURNITURE",
  1893162501: "IFCFOOTINGTYPE",
  2853485674: "IFCEXTERNALSPATIALSTRUCTUREELEMENT",
  4148101412: "IFCEVENT",
  132023988: "IFCENGINETYPE",
  2397081782: "IFCELEMENTASSEMBLYTYPE",
  2323601079: "IFCDOORTYPE",
  1213902940: "IFCCYLINDRICALSURFACE",
  1525564444: "IFCCONSTRUCTIONPRODUCTRESOURCETYPE",
  4105962743: "IFCCONSTRUCTIONMATERIALRESOURCETYPE",
  2185764099: "IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",
  15328376: "IFCCOMPOSITECURVEONSURFACE",
  3875453745: "IFCCOMPLEXPROPERTYTEMPLATE",
  3893394355: "IFCCIVILELEMENTTYPE",
  2197970202: "IFCCHIMNEYTYPE",
  167062518: "IFCBSPLINESURFACEWITHKNOTS",
  2887950389: "IFCBSPLINESURFACE",
  2603310189: "IFCADVANCEDBREPWITHVOIDS",
  1635779807: "IFCADVANCEDBREP",
  2916149573: "IFCTRIANGULATEDFACESET",
  1935646853: "IFCTOROIDALSURFACE",
  2387106220: "IFCTESSELLATEDFACESET",
  3206491090: "IFCTASKTYPE",
  699246055: "IFCSURFACECURVE",
  4095615324: "IFCSUBCONTRACTRESOURCETYPE",
  603775116: "IFCSTRUCTURALSURFACEREACTION",
  4015995234: "IFCSPHERICALSURFACE",
  2481509218: "IFCSPATIALZONETYPE",
  463610769: "IFCSPATIALZONE",
  710998568: "IFCSPATIALELEMENTTYPE",
  1412071761: "IFCSPATIALELEMENT",
  3663146110: "IFCSIMPLEPROPERTYTEMPLATE",
  3243963512: "IFCREVOLVEDAREASOLIDTAPERED",
  816062949: "IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",
  1521410863: "IFCRELSPACEBOUNDARY2NDLEVEL",
  3523091289: "IFCRELSPACEBOUNDARY1STLEVEL",
  427948657: "IFCRELINTERFERESELEMENTS",
  307848117: "IFCRELDEFINESBYTEMPLATE",
  1462361463: "IFCRELDEFINESBYOBJECT",
  2565941209: "IFCRELDECLARES",
  1027710054: "IFCRELASSIGNSTOGROUPBYFACTOR",
  3521284610: "IFCPROPERTYTEMPLATE",
  492091185: "IFCPROPERTYSETTEMPLATE",
  653396225: "IFCPROJECTLIBRARY",
  569719735: "IFCPROCEDURETYPE",
  3967405729: "IFCPREDEFINEDPROPERTYSET",
  1682466193: "IFCPCURVE",
  428585644: "IFCLABORRESOURCETYPE",
  2294589976: "IFCINDEXEDPOLYGONALFACEWITHVOIDS",
  178912537: "IFCINDEXEDPOLYGONALFACE",
  4095422895: "IFCGEOGRAPHICELEMENTTYPE",
  2652556860: "IFCFIXEDREFERENCESWEPTAREASOLID",
  2804161546: "IFCEXTRUDEDAREASOLIDTAPERED",
  4024345920: "IFCEVENTTYPE",
  2629017746: "IFCCURVEBOUNDEDSURFACE",
  1815067380: "IFCCREWRESOURCETYPE",
  3419103109: "IFCCONTEXT",
  2574617495: "IFCCONSTRUCTIONRESOURCETYPE",
  2059837836: "IFCCARTESIANPOINTLIST3D",
  1675464909: "IFCCARTESIANPOINTLIST2D",
  574549367: "IFCCARTESIANPOINTLIST",
  3406155212: "IFCADVANCEDFACE",
  3698973494: "IFCTYPERESOURCE",
  3736923433: "IFCTYPEPROCESS",
  901063453: "IFCTESSELLATEDITEM",
  1096409881: "IFCSWEPTDISKSOLIDPOLYGONAL",
  1042787934: "IFCRESOURCETIME",
  1608871552: "IFCRESOURCECONSTRAINTRELATIONSHIP",
  2943643501: "IFCRESOURCEAPPROVALRELATIONSHIP",
  2090586900: "IFCQUANTITYSET",
  1482703590: "IFCPROPERTYTEMPLATEDEFINITION",
  3778827333: "IFCPREDEFINEDPROPERTIES",
  2998442950: "IFCMIRROREDPROFILEDEF",
  853536259: "IFCMATERIALRELATIONSHIP",
  3404854881: "IFCMATERIALPROFILESETUSAGETAPERING",
  3079605661: "IFCMATERIALPROFILESETUSAGE",
  2852063980: "IFCMATERIALCONSTITUENTSET",
  3708119e3: "IFCMATERIALCONSTITUENT",
  1585845231: "IFCLAGTIME",
  2133299955: "IFCINDEXEDTRIANGLETEXTUREMAP",
  1437953363: "IFCINDEXEDTEXTUREMAP",
  3570813810: "IFCINDEXEDCOLOURMAP",
  1437805879: "IFCEXTERNALREFERENCERELATIONSHIP",
  297599258: "IFCEXTENDEDPROPERTIES",
  211053100: "IFCEVENTTIME",
  2713554722: "IFCCONVERSIONBASEDUNITWITHOFFSET",
  3285139300: "IFCCOLOURRGBLIST",
  1236880293: "IFCWORKTIME",
  1199560280: "IFCTIMEPERIOD",
  3611470254: "IFCTEXTUREVERTEXLIST",
  2771591690: "IFCTASKTIMERECURRING",
  1549132990: "IFCTASKTIME",
  2043862942: "IFCTABLECOLUMN",
  2934153892: "IFCSURFACEREINFORCEMENTAREA",
  609421318: "IFCSTRUCTURALLOADORRESULT",
  3478079324: "IFCSTRUCTURALLOADCONFIGURATION",
  1054537805: "IFCSCHEDULINGTIME",
  2439245199: "IFCRESOURCELEVELRELATIONSHIP",
  2433181523: "IFCREFERENCE",
  3915482550: "IFCRECURRENCEPATTERN",
  986844984: "IFCPROPERTYABSTRACTION",
  3843373140: "IFCPROJECTEDCRS",
  677532197: "IFCPRESENTATIONITEM",
  1507914824: "IFCMATERIALUSAGEDEFINITION",
  552965576: "IFCMATERIALPROFILEWITHOFFSETS",
  164193824: "IFCMATERIALPROFILESET",
  2235152071: "IFCMATERIALPROFILE",
  1847252529: "IFCMATERIALLAYERWITHOFFSETS",
  760658860: "IFCMATERIALDEFINITION",
  3057273783: "IFCMAPCONVERSION",
  4294318154: "IFCEXTERNALINFORMATION",
  1466758467: "IFCCOORDINATEREFERENCESYSTEM",
  1785450214: "IFCCOORDINATEOPERATION",
  775493141: "IFCCONNECTIONVOLUMEGEOMETRY",
  979691226: "IFCREINFORCINGBAR",
  3700593921: "IFCELECTRICDISTRIBUTIONPOINT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  578613899: "IFCCONTROLLERTYPE",
  2454782716: "IFCCHAMFEREDGEFEATURE",
  753842376: "IFCBEAM",
  3001207471: "IFCALARMTYPE",
  2874132201: "IFCACTUATORTYPE",
  3304561284: "IFCWINDOW",
  3512223829: "IFCWALLSTANDARDCASE",
  2391406946: "IFCWALL",
  3313531582: "IFCVIBRATIONISOLATORTYPE",
  2347447852: "IFCTENDONANCHOR",
  3824725483: "IFCTENDON",
  2515109513: "IFCSTRUCTURALANALYSISMODEL",
  4252922144: "IFCSTAIRFLIGHT",
  331165859: "IFCSTAIR",
  1529196076: "IFCSLAB",
  1783015770: "IFCSENSORTYPE",
  1376911519: "IFCROUNDEDEDGEFEATURE",
  2016517767: "IFCROOF",
  2320036040: "IFCREINFORCINGMESH",
  3027567501: "IFCREINFORCINGELEMENT",
  3055160366: "IFCRATIONALBEZIERCURVE",
  3283111854: "IFCRAMPFLIGHT",
  3024970846: "IFCRAMP",
  2262370178: "IFCRAILING",
  3171933400: "IFCPLATE",
  1687234759: "IFCPILE",
  1073191201: "IFCMEMBER",
  900683007: "IFCFOOTING",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  2223149337: "IFCFLOWTERMINAL",
  707683696: "IFCFLOWSTORAGEDEVICE",
  987401354: "IFCFLOWSEGMENT",
  3132237377: "IFCFLOWMOVINGDEVICE",
  4037862832: "IFCFLOWINSTRUMENTTYPE",
  4278956645: "IFCFLOWFITTING",
  2058353004: "IFCFLOWCONTROLLER",
  4222183408: "IFCFIRESUPPRESSIONTERMINALTYPE",
  1810631287: "IFCFILTERTYPE",
  346874300: "IFCFANTYPE",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  857184966: "IFCELECTRICALELEMENT",
  1634875225: "IFCELECTRICALCIRCUIT",
  712377611: "IFCELECTRICTIMECONTROLTYPE",
  1217240411: "IFCELECTRICMOTORTYPE",
  1365060375: "IFCELECTRICHEATERTYPE",
  1534661035: "IFCELECTRICGENERATORTYPE",
  3277789161: "IFCELECTRICFLOWSTORAGEDEVICETYPE",
  663422040: "IFCELECTRICAPPLIANCETYPE",
  855621170: "IFCEDGEFEATURE",
  2030761528: "IFCDUCTSILENCERTYPE",
  3760055223: "IFCDUCTSEGMENTTYPE",
  869906466: "IFCDUCTFITTINGTYPE",
  395920057: "IFCDOOR",
  3041715199: "IFCDISTRIBUTIONPORT",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  2063403501: "IFCDISTRIBUTIONCONTROLELEMENTTYPE",
  1599208980: "IFCDISTRIBUTIONCHAMBERELEMENTTYPE",
  2635815018: "IFCDISCRETEACCESSORYTYPE",
  1335981549: "IFCDISCRETEACCESSORY",
  4147604152: "IFCDIAMETERDIMENSION",
  3961806047: "IFCDAMPERTYPE",
  3495092785: "IFCCURTAINWALL",
  1973544240: "IFCCOVERING",
  2954562838: "IFCCOOLINGTOWERTYPE",
  335055490: "IFCCOOLEDBEAMTYPE",
  488727124: "IFCCONSTRUCTIONPRODUCTRESOURCE",
  1060000209: "IFCCONSTRUCTIONMATERIALRESOURCE",
  3898045240: "IFCCONSTRUCTIONEQUIPMENTRESOURCE",
  1163958913: "IFCCONDITIONCRITERION",
  2188551683: "IFCCONDITION",
  2816379211: "IFCCONDENSERTYPE",
  3850581409: "IFCCOMPRESSORTYPE",
  843113511: "IFCCOLUMN",
  2301859152: "IFCCOILTYPE",
  2611217952: "IFCCIRCLE",
  2951183804: "IFCCHILLERTYPE",
  1285652485: "IFCCABLESEGMENTTYPE",
  3293546465: "IFCCABLECARRIERSEGMENTTYPE",
  395041908: "IFCCABLECARRIERFITTINGTYPE",
  1909888760: "IFCBUILDINGELEMENTPROXYTYPE",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  2979338954: "IFCBUILDINGELEMENTPART",
  52481810: "IFCBUILDINGELEMENTCOMPONENT",
  3299480353: "IFCBUILDINGELEMENT",
  231477066: "IFCBOILERTYPE",
  1916977116: "IFCBEZIERCURVE",
  819618141: "IFCBEAMTYPE",
  1967976161: "IFCBSPLINECURVE",
  3460190687: "IFCASSET",
  2470393545: "IFCANGULARDIMENSION",
  1871374353: "IFCAIRTOAIRHEATRECOVERYTYPE",
  3352864051: "IFCAIRTERMINALTYPE",
  1411407467: "IFCAIRTERMINALBOXTYPE",
  3821786052: "IFCACTIONREQUEST",
  1213861670: "IFC2DCOMPOSITECURVE",
  1033361043: "IFCZONE",
  3342526732: "IFCWORKSCHEDULE",
  4218914973: "IFCWORKPLAN",
  1028945134: "IFCWORKCONTROL",
  1133259667: "IFCWASTETERMINALTYPE",
  1898987631: "IFCWALLTYPE",
  2769231204: "IFCVIRTUALELEMENT",
  728799441: "IFCVALVETYPE",
  1911125066: "IFCUNITARYEQUIPMENTTYPE",
  1600972822: "IFCTUBEBUNDLETYPE",
  3593883385: "IFCTRIMMEDCURVE",
  1620046519: "IFCTRANSPORTELEMENT",
  1692211062: "IFCTRANSFORMERTYPE",
  1637806684: "IFCTIMESERIESSCHEDULE",
  5716631: "IFCTANKTYPE",
  2254336722: "IFCSYSTEM",
  2315554128: "IFCSWITCHINGDEVICETYPE",
  148013059: "IFCSUBCONTRACTRESOURCE",
  1975003073: "IFCSTRUCTURALSURFACECONNECTION",
  2986769608: "IFCSTRUCTURALRESULTGROUP",
  1235345126: "IFCSTRUCTURALPOINTREACTION",
  734778138: "IFCSTRUCTURALPOINTCONNECTION",
  2082059205: "IFCSTRUCTURALPOINTACTION",
  3987759626: "IFCSTRUCTURALPLANARACTIONVARYING",
  1621171031: "IFCSTRUCTURALPLANARACTION",
  1252848954: "IFCSTRUCTURALLOADGROUP",
  1721250024: "IFCSTRUCTURALLINEARACTIONVARYING",
  1807405624: "IFCSTRUCTURALLINEARACTION",
  2445595289: "IFCSTRUCTURALCURVEMEMBERVARYING",
  214636428: "IFCSTRUCTURALCURVEMEMBER",
  4243806635: "IFCSTRUCTURALCURVECONNECTION",
  1179482911: "IFCSTRUCTURALCONNECTION",
  682877961: "IFCSTRUCTURALACTION",
  1039846685: "IFCSTAIRFLIGHTTYPE",
  3112655638: "IFCSTACKTERMINALTYPE",
  3812236995: "IFCSPACETYPE",
  652456506: "IFCSPACEPROGRAM",
  1305183839: "IFCSPACEHEATERTYPE",
  3856911033: "IFCSPACE",
  2533589738: "IFCSLABTYPE",
  4097777520: "IFCSITE",
  4105383287: "IFCSERVICELIFE",
  3517283431: "IFCSCHEDULETIMECONTROL",
  1768891740: "IFCSANITARYTERMINALTYPE",
  2863920197: "IFCRELASSIGNSTASKS",
  160246688: "IFCRELAGGREGATES",
  2324767716: "IFCRAMPFLIGHTTYPE",
  2893384427: "IFCRAILINGTYPE",
  3248260540: "IFCRADIUSDIMENSION",
  2250791053: "IFCPUMPTYPE",
  1842657554: "IFCPROTECTIVEDEVICETYPE",
  3651124850: "IFCPROJECTIONELEMENT",
  3642467123: "IFCPROJECTORDERRECORD",
  2904328755: "IFCPROJECTORDER",
  2744685151: "IFCPROCEDURE",
  3740093272: "IFCPORT",
  3724593414: "IFCPOLYLINE",
  4017108033: "IFCPLATETYPE",
  4231323485: "IFCPIPESEGMENTTYPE",
  804291784: "IFCPIPEFITTINGTYPE",
  3327091369: "IFCPERMIT",
  2382730787: "IFCPERFORMANCEHISTORY",
  2837617999: "IFCOUTLETTYPE",
  3425660407: "IFCORDERACTION",
  3588315303: "IFCOPENINGELEMENT",
  4143007308: "IFCOCCUPANT",
  1916936684: "IFCMOVE",
  977012517: "IFCMOTORCONNECTIONTYPE",
  3181161470: "IFCMEMBERTYPE",
  2108223431: "IFCMECHANICALFASTENERTYPE",
  377706215: "IFCMECHANICALFASTENER",
  2506943328: "IFCLINEARDIMENSION",
  1161773419: "IFCLIGHTFIXTURETYPE",
  1051575348: "IFCLAMPTYPE",
  3827777499: "IFCLABORRESOURCE",
  4288270099: "IFCJUNCTIONBOXTYPE",
  2391368822: "IFCINVENTORY",
  1806887404: "IFCHUMIDIFIERTYPE",
  1251058090: "IFCHEATEXCHANGERTYPE",
  2706460486: "IFCGROUP",
  3009204131: "IFCGRID",
  200128114: "IFCGASTERMINALTYPE",
  814719939: "IFCFURNITURESTANDARD",
  263784265: "IFCFURNISHINGELEMENT",
  3009222698: "IFCFLOWTREATMENTDEVICETYPE",
  2297155007: "IFCFLOWTERMINALTYPE",
  1339347760: "IFCFLOWSTORAGEDEVICETYPE",
  1834744321: "IFCFLOWSEGMENTTYPE",
  1482959167: "IFCFLOWMOVINGDEVICETYPE",
  3815607619: "IFCFLOWMETERTYPE",
  3198132628: "IFCFLOWFITTINGTYPE",
  3907093117: "IFCFLOWCONTROLLERTYPE",
  1287392070: "IFCFEATUREELEMENTSUBTRACTION",
  2143335405: "IFCFEATUREELEMENTADDITION",
  2827207264: "IFCFEATUREELEMENT",
  2489546625: "IFCFASTENERTYPE",
  647756555: "IFCFASTENER",
  3737207727: "IFCFACETEDBREPWITHVOIDS",
  807026263: "IFCFACETEDBREP",
  3390157468: "IFCEVAPORATORTYPE",
  3174744832: "IFCEVAPORATIVECOOLERTYPE",
  3272907226: "IFCEQUIPMENTSTANDARD",
  1962604670: "IFCEQUIPMENTELEMENT",
  2107101300: "IFCENERGYCONVERSIONDEVICETYPE",
  1704287377: "IFCELLIPSE",
  2590856083: "IFCELEMENTCOMPONENTTYPE",
  1623761950: "IFCELEMENTCOMPONENT",
  4123344466: "IFCELEMENTASSEMBLY",
  1758889154: "IFCELEMENT",
  360485395: "IFCELECTRICALBASEPROPERTIES",
  3849074793: "IFCDISTRIBUTIONFLOWELEMENTTYPE",
  3256556792: "IFCDISTRIBUTIONELEMENTTYPE",
  681481545: "IFCDIMENSIONCURVEDIRECTEDCALLOUT",
  1457835157: "IFCCURTAINWALLTYPE",
  3295246426: "IFCCREWRESOURCE",
  1916426348: "IFCCOVERINGTYPE",
  1419761937: "IFCCOSTSCHEDULE",
  3895139033: "IFCCOSTITEM",
  3293443760: "IFCCONTROL",
  2559216714: "IFCCONSTRUCTIONRESOURCE",
  2510884976: "IFCCONIC",
  3732776249: "IFCCOMPOSITECURVE",
  300633059: "IFCCOLUMNTYPE",
  2937912522: "IFCCIRCLEHOLLOWPROFILEDEF",
  3124254112: "IFCBUILDINGSTOREY",
  1950629157: "IFCBUILDINGELEMENTTYPE",
  4031249490: "IFCBUILDING",
  1260505505: "IFCBOUNDEDCURVE",
  3649129432: "IFCBOOLEANCLIPPINGRESULT",
  1334484129: "IFCBLOCK",
  3207858831: "IFCASYMMETRICISHAPEPROFILEDEF",
  1674181508: "IFCANNOTATION",
  2296667514: "IFCACTOR",
  2097647324: "IFCTRANSPORTELEMENTTYPE",
  3473067441: "IFCTASK",
  1580310250: "IFCSYSTEMFURNITUREELEMENTTYPE",
  4124788165: "IFCSURFACEOFREVOLUTION",
  2809605785: "IFCSURFACEOFLINEAREXTRUSION",
  2028607225: "IFCSURFACECURVESWEPTAREASOLID",
  4070609034: "IFCSTRUCTUREDDIMENSIONCALLOUT",
  2218152070: "IFCSTRUCTURALSURFACEMEMBERVARYING",
  3979015343: "IFCSTRUCTURALSURFACEMEMBER",
  3689010777: "IFCSTRUCTURALREACTION",
  530289379: "IFCSTRUCTURALMEMBER",
  3136571912: "IFCSTRUCTURALITEM",
  3544373492: "IFCSTRUCTURALACTIVITY",
  451544542: "IFCSPHERE",
  3893378262: "IFCSPATIALSTRUCTUREELEMENTTYPE",
  2706606064: "IFCSPATIALSTRUCTUREELEMENT",
  3626867408: "IFCRIGHTCIRCULARCYLINDER",
  4158566097: "IFCRIGHTCIRCULARCONE",
  1856042241: "IFCREVOLVEDAREASOLID",
  2914609552: "IFCRESOURCE",
  1401173127: "IFCRELVOIDSELEMENT",
  3451746338: "IFCRELSPACEBOUNDARY",
  366585022: "IFCRELSERVICESBUILDINGS",
  4122056220: "IFCRELSEQUENCE",
  1058617721: "IFCRELSCHEDULESCOSTITEMS",
  1245217292: "IFCRELREFERENCEDINSPATIALSTRUCTURE",
  750771296: "IFCRELPROJECTSELEMENT",
  202636808: "IFCRELOVERRIDESPROPERTIES",
  2051452291: "IFCRELOCCUPIESSPACES",
  3268803585: "IFCRELNESTS",
  4189434867: "IFCRELINTERACTIONREQUIREMENTS",
  279856033: "IFCRELFLOWCONTROLELEMENTS",
  3940055652: "IFCRELFILLSELEMENT",
  781010003: "IFCRELDEFINESBYTYPE",
  4186316022: "IFCRELDEFINESBYPROPERTIES",
  693640335: "IFCRELDEFINES",
  2551354335: "IFCRELDECOMPOSES",
  2802773753: "IFCRELCOVERSSPACES",
  886880790: "IFCRELCOVERSBLDGELEMENTS",
  3242617779: "IFCRELCONTAINEDINSPATIALSTRUCTURE",
  3678494232: "IFCRELCONNECTSWITHREALIZINGELEMENTS",
  504942748: "IFCRELCONNECTSWITHECCENTRICITY",
  1638771189: "IFCRELCONNECTSSTRUCTURALMEMBER",
  3912681535: "IFCRELCONNECTSSTRUCTURALELEMENT",
  2127690289: "IFCRELCONNECTSSTRUCTURALACTIVITY",
  3190031847: "IFCRELCONNECTSPORTS",
  4201705270: "IFCRELCONNECTSPORTTOELEMENT",
  3945020480: "IFCRELCONNECTSPATHELEMENTS",
  1204542856: "IFCRELCONNECTSELEMENTS",
  826625072: "IFCRELCONNECTS",
  2851387026: "IFCRELASSOCIATESPROFILEPROPERTIES",
  2655215786: "IFCRELASSOCIATESMATERIAL",
  3840914261: "IFCRELASSOCIATESLIBRARY",
  982818633: "IFCRELASSOCIATESDOCUMENT",
  2728634034: "IFCRELASSOCIATESCONSTRAINT",
  919958153: "IFCRELASSOCIATESCLASSIFICATION",
  4095574036: "IFCRELASSOCIATESAPPROVAL",
  1327628568: "IFCRELASSOCIATESAPPLIEDVALUE",
  1865459582: "IFCRELASSOCIATES",
  205026976: "IFCRELASSIGNSTORESOURCE",
  3372526763: "IFCRELASSIGNSTOPROJECTORDER",
  2857406711: "IFCRELASSIGNSTOPRODUCT",
  4278684876: "IFCRELASSIGNSTOPROCESS",
  1307041759: "IFCRELASSIGNSTOGROUP",
  2495723537: "IFCRELASSIGNSTOCONTROL",
  1683148259: "IFCRELASSIGNSTOACTOR",
  3939117080: "IFCRELASSIGNS",
  3454111270: "IFCRECTANGULARTRIMMEDSURFACE",
  2798486643: "IFCRECTANGULARPYRAMID",
  2770003689: "IFCRECTANGLEHOLLOWPROFILEDEF",
  3219374653: "IFCPROXY",
  1451395588: "IFCPROPERTYSET",
  4194566429: "IFCPROJECTIONCURVE",
  103090709: "IFCPROJECT",
  4208778838: "IFCPRODUCT",
  2945172077: "IFCPROCESS",
  220341763: "IFCPLANE",
  603570806: "IFCPLANARBOX",
  3566463478: "IFCPERMEABLECOVERINGPROPERTIES",
  3505215534: "IFCOFFSETCURVE3D",
  3388369263: "IFCOFFSETCURVE2D",
  3888040117: "IFCOBJECT",
  1425443689: "IFCMANIFOLDSOLIDBREP",
  1281925730: "IFCLINE",
  572779678: "IFCLSHAPEPROFILEDEF",
  1484403080: "IFCISHAPEPROFILEDEF",
  987898635: "IFCGEOMETRICCURVESET",
  1268542332: "IFCFURNITURETYPE",
  4238390223: "IFCFURNISHINGELEMENTTYPE",
  3455213021: "IFCFLUIDFLOWPROPERTIES",
  315944413: "IFCFILLAREASTYLETILES",
  4203026998: "IFCFILLAREASTYLETILESYMBOLWITHSTYLE",
  374418227: "IFCFILLAREASTYLEHATCHING",
  2047409740: "IFCFACEBASEDSURFACEMODEL",
  477187591: "IFCEXTRUDEDAREASOLID",
  80994333: "IFCENERGYPROPERTIES",
  2835456948: "IFCELLIPSEPROFILEDEF",
  2777663545: "IFCELEMENTARYSURFACE",
  339256511: "IFCELEMENTTYPE",
  1883228015: "IFCELEMENTQUANTITY",
  1472233963: "IFCEDGELOOP",
  4006246654: "IFCDRAUGHTINGPREDEFINEDCURVEFONT",
  445594917: "IFCDRAUGHTINGPREDEFINEDCOLOUR",
  3073041342: "IFCDRAUGHTINGCALLOUT",
  526551008: "IFCDOORSTYLE",
  1714330368: "IFCDOORPANELPROPERTIES",
  2963535650: "IFCDOORLININGPROPERTIES",
  32440307: "IFCDIRECTION",
  4054601972: "IFCDIMENSIONCURVETERMINATOR",
  606661476: "IFCDIMENSIONCURVE",
  693772133: "IFCDEFINEDSYMBOL",
  2827736869: "IFCCURVEBOUNDEDPLANE",
  2601014836: "IFCCURVE",
  2147822146: "IFCCSGSOLID",
  2506170314: "IFCCSGPRIMITIVE3D",
  194851669: "IFCCRANERAILFSHAPEPROFILEDEF",
  4133800736: "IFCCRANERAILASHAPEPROFILEDEF",
  2485617015: "IFCCOMPOSITECURVESEGMENT",
  2205249479: "IFCCLOSEDSHELL",
  1383045692: "IFCCIRCLEPROFILEDEF",
  1416205885: "IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",
  3331915920: "IFCCARTESIANTRANSFORMATIONOPERATOR3D",
  3486308946: "IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",
  3749851601: "IFCCARTESIANTRANSFORMATIONOPERATOR2D",
  59481748: "IFCCARTESIANTRANSFORMATIONOPERATOR",
  1123145078: "IFCCARTESIANPOINT",
  2898889636: "IFCCSHAPEPROFILEDEF",
  2713105998: "IFCBOXEDHALFSPACE",
  2581212453: "IFCBOUNDINGBOX",
  4182860854: "IFCBOUNDEDSURFACE",
  2736907675: "IFCBOOLEANRESULT",
  2740243338: "IFCAXIS2PLACEMENT3D",
  3125803723: "IFCAXIS2PLACEMENT2D",
  4261334040: "IFCAXIS1PLACEMENT",
  1302238472: "IFCANNOTATIONSURFACE",
  2265737646: "IFCANNOTATIONFILLAREAOCCURRENCE",
  669184980: "IFCANNOTATIONFILLAREA",
  3288037868: "IFCANNOTATIONCURVEOCCURRENCE",
  2543172580: "IFCZSHAPEPROFILEDEF",
  1299126871: "IFCWINDOWSTYLE",
  512836454: "IFCWINDOWPANELPROPERTIES",
  336235671: "IFCWINDOWLININGPROPERTIES",
  2759199220: "IFCVERTEXLOOP",
  1417489154: "IFCVECTOR",
  427810014: "IFCUSHAPEPROFILEDEF",
  2347495698: "IFCTYPEPRODUCT",
  1628702193: "IFCTYPEOBJECT",
  1345879162: "IFCTWODIRECTIONREPEATFACTOR",
  2715220739: "IFCTRAPEZIUMPROFILEDEF",
  3124975700: "IFCTEXTLITERALWITHEXTENT",
  4282788508: "IFCTEXTLITERAL",
  3028897424: "IFCTERMINATORSYMBOL",
  3071757647: "IFCTSHAPEPROFILEDEF",
  230924584: "IFCSWEPTSURFACE",
  1260650574: "IFCSWEPTDISKSOLID",
  2247615214: "IFCSWEPTAREASOLID",
  1878645084: "IFCSURFACESTYLERENDERING",
  2513912981: "IFCSURFACE",
  2233826070: "IFCSUBEDGE",
  3653947884: "IFCSTRUCTURALSTEELPROFILEPROPERTIES",
  3843319758: "IFCSTRUCTURALPROFILEPROPERTIES",
  1190533807: "IFCSTRUCTURALLOADSINGLEFORCEWARPING",
  1597423693: "IFCSTRUCTURALLOADSINGLEFORCE",
  1973038258: "IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",
  2473145415: "IFCSTRUCTURALLOADSINGLEDISPLACEMENT",
  2668620305: "IFCSTRUCTURALLOADPLANARFORCE",
  1595516126: "IFCSTRUCTURALLOADLINEARFORCE",
  390701378: "IFCSPACETHERMALLOADPROPERTIES",
  1202362311: "IFCSOUNDVALUE",
  2485662743: "IFCSOUNDPROPERTIES",
  723233188: "IFCSOLIDMODEL",
  2609359061: "IFCSLIPPAGECONNECTIONCONDITION",
  4124623270: "IFCSHELLBASEDSURFACEMODEL",
  2411513650: "IFCSERVICELIFEFACTOR",
  1509187699: "IFCSECTIONEDSPINE",
  2778083089: "IFCROUNDEDRECTANGLEPROFILEDEF",
  478536968: "IFCRELATIONSHIP",
  3765753017: "IFCREINFORCEMENTDEFINITIONPROPERTIES",
  3413951693: "IFCREGULARTIMESERIES",
  3615266464: "IFCRECTANGLEPROFILEDEF",
  110355661: "IFCPROPERTYTABLEVALUE",
  3650150729: "IFCPROPERTYSINGLEVALUE",
  3357820518: "IFCPROPERTYSETDEFINITION",
  941946838: "IFCPROPERTYREFERENCEVALUE",
  2752243245: "IFCPROPERTYLISTVALUE",
  4166981789: "IFCPROPERTYENUMERATEDVALUE",
  1680319473: "IFCPROPERTYDEFINITION",
  871118103: "IFCPROPERTYBOUNDEDVALUE",
  673634403: "IFCPRODUCTDEFINITIONSHAPE",
  179317114: "IFCPREDEFINEDPOINTMARKERSYMBOL",
  433424934: "IFCPREDEFINEDDIMENSIONSYMBOL",
  2559016684: "IFCPREDEFINEDCURVEFONT",
  759155922: "IFCPREDEFINEDCOLOUR",
  2775532180: "IFCPOLYGONALBOUNDEDHALFSPACE",
  2924175390: "IFCPOLYLOOP",
  1423911732: "IFCPOINTONSURFACE",
  4022376103: "IFCPOINTONCURVE",
  2067069095: "IFCPOINT",
  1663979128: "IFCPLANAREXTENT",
  2004835150: "IFCPLACEMENT",
  597895409: "IFCPIXELTEXTURE",
  3021840470: "IFCPHYSICALCOMPLEXQUANTITY",
  2519244187: "IFCPATH",
  2529465313: "IFCPARAMETERIZEDPROFILEDEF",
  1029017970: "IFCORIENTEDEDGE",
  2665983363: "IFCOPENSHELL",
  2833995503: "IFCONEDIRECTIONREPEATFACTOR",
  219451334: "IFCOBJECTDEFINITION",
  1430189142: "IFCMECHANICALCONCRETEMATERIALPROPERTIES",
  2022407955: "IFCMATERIALDEFINITIONREPRESENTATION",
  2347385850: "IFCMAPPEDITEM",
  1008929658: "IFCLOOP",
  2624227202: "IFCLOCALPLACEMENT",
  3422422726: "IFCLIGHTSOURCESPOT",
  1520743889: "IFCLIGHTSOURCEPOSITIONAL",
  4266656042: "IFCLIGHTSOURCEGONIOMETRIC",
  2604431987: "IFCLIGHTSOURCEDIRECTIONAL",
  125510826: "IFCLIGHTSOURCEAMBIENT",
  1402838566: "IFCLIGHTSOURCE",
  3741457305: "IFCIRREGULARTIMESERIES",
  3905492369: "IFCIMAGETEXTURE",
  2445078500: "IFCHYGROSCOPICMATERIALPROPERTIES",
  812098782: "IFCHALFSPACESOLID",
  178086475: "IFCGRIDPLACEMENT",
  3590301190: "IFCGEOMETRICSET",
  4142052618: "IFCGEOMETRICREPRESENTATIONSUBCONTEXT",
  2453401579: "IFCGEOMETRICREPRESENTATIONITEM",
  3448662350: "IFCGEOMETRICREPRESENTATIONCONTEXT",
  1446786286: "IFCGENERALPROFILEPROPERTIES",
  803998398: "IFCGENERALMATERIALPROPERTIES",
  3857492461: "IFCFUELPROPERTIES",
  738692330: "IFCFILLAREASTYLE",
  4219587988: "IFCFAILURECONNECTIONCONDITION",
  3008276851: "IFCFACESURFACE",
  803316827: "IFCFACEOUTERBOUND",
  1809719519: "IFCFACEBOUND",
  2556980723: "IFCFACE",
  1860660968: "IFCEXTENDEDMATERIALPROPERTIES",
  476780140: "IFCEDGECURVE",
  3900360178: "IFCEDGE",
  4170525392: "IFCDRAUGHTINGPREDEFINEDTEXTFONT",
  3732053477: "IFCDOCUMENTREFERENCE",
  1694125774: "IFCDIMENSIONPAIR",
  2273265877: "IFCDIMENSIONCALLOUTRELATIONSHIP",
  3632507154: "IFCDERIVEDPROFILEDEF",
  3800577675: "IFCCURVESTYLE",
  2889183280: "IFCCONVERSIONBASEDUNIT",
  3050246964: "IFCCONTEXTDEPENDENTUNIT",
  45288368: "IFCCONNECTIONPOINTECCENTRICITY",
  1981873012: "IFCCONNECTIONCURVEGEOMETRY",
  370225590: "IFCCONNECTEDFACESET",
  1485152156: "IFCCOMPOSITEPROFILEDEF",
  2542286263: "IFCCOMPLEXPROPERTY",
  776857604: "IFCCOLOURRGB",
  647927063: "IFCCLASSIFICATIONREFERENCE",
  3150382593: "IFCCENTERLINEPROFILEDEF",
  616511568: "IFCBLOBTEXTURE",
  2705031697: "IFCARBITRARYPROFILEDEFWITHVOIDS",
  1310608509: "IFCARBITRARYOPENPROFILEDEF",
  3798115385: "IFCARBITRARYCLOSEDPROFILEDEF",
  2297822566: "IFCANNOTATIONTEXTOCCURRENCE",
  3612888222: "IFCANNOTATIONSYMBOLOCCURRENCE",
  962685235: "IFCANNOTATIONSURFACEOCCURRENCE",
  2442683028: "IFCANNOTATIONOCCURRENCE",
  1065908215: "IFCWATERPROPERTIES",
  891718957: "IFCVIRTUALGRIDINTERSECTION",
  1907098498: "IFCVERTEXPOINT",
  3304826586: "IFCVERTEXBASEDTEXTUREMAP",
  2799835756: "IFCVERTEX",
  180925521: "IFCUNITASSIGNMENT",
  1735638870: "IFCTOPOLOGYREPRESENTATION",
  1377556343: "IFCTOPOLOGICALREPRESENTATIONITEM",
  581633288: "IFCTIMESERIESVALUE",
  1718945513: "IFCTIMESERIESREFERENCERELATIONSHIP",
  3101149627: "IFCTIMESERIES",
  3317419933: "IFCTHERMALMATERIALPROPERTIES",
  1210645708: "IFCTEXTUREVERTEX",
  2552916305: "IFCTEXTUREMAP",
  1742049831: "IFCTEXTURECOORDINATEGENERATOR",
  280115917: "IFCTEXTURECOORDINATE",
  1484833681: "IFCTEXTSTYLEWITHBOXCHARACTERISTICS",
  1640371178: "IFCTEXTSTYLETEXTMODEL",
  2636378356: "IFCTEXTSTYLEFORDEFINEDFONT",
  1983826977: "IFCTEXTSTYLEFONTMODEL",
  1447204868: "IFCTEXTSTYLE",
  912023232: "IFCTELECOMADDRESS",
  531007025: "IFCTABLEROW",
  985171141: "IFCTABLE",
  1290481447: "IFCSYMBOLSTYLE",
  626085974: "IFCSURFACETEXTURE",
  1351298697: "IFCSURFACESTYLEWITHTEXTURES",
  846575682: "IFCSURFACESTYLESHADING",
  1607154358: "IFCSURFACESTYLEREFRACTION",
  3303107099: "IFCSURFACESTYLELIGHTING",
  1300840506: "IFCSURFACESTYLE",
  3049322572: "IFCSTYLEDREPRESENTATION",
  3958052878: "IFCSTYLEDITEM",
  2830218821: "IFCSTYLEMODEL",
  3408363356: "IFCSTRUCTURALLOADTEMPERATURE",
  2525727697: "IFCSTRUCTURALLOADSTATIC",
  2162789131: "IFCSTRUCTURALLOAD",
  2273995522: "IFCSTRUCTURALCONNECTIONCONDITION",
  3692461612: "IFCSIMPLEPROPERTY",
  4240577450: "IFCSHAPEREPRESENTATION",
  3982875396: "IFCSHAPEMODEL",
  867548509: "IFCSHAPEASPECT",
  4165799628: "IFCSECTIONREINFORCEMENTPROPERTIES",
  2042790032: "IFCSECTIONPROPERTIES",
  448429030: "IFCSIUNIT",
  2341007311: "IFCROOT",
  3679540991: "IFCRIBPLATEPROFILEPROPERTIES",
  1660063152: "IFCREPRESENTATIONMAP",
  3008791417: "IFCREPRESENTATIONITEM",
  3377609919: "IFCREPRESENTATIONCONTEXT",
  1076942058: "IFCREPRESENTATION",
  1222501353: "IFCRELAXATION",
  1580146022: "IFCREINFORCEMENTBARPROPERTIES",
  2692823254: "IFCREFERENCESVALUEDOCUMENT",
  825690147: "IFCQUANTITYWEIGHT",
  2405470396: "IFCQUANTITYVOLUME",
  3252649465: "IFCQUANTITYTIME",
  931644368: "IFCQUANTITYLENGTH",
  2093928680: "IFCQUANTITYCOUNT",
  2044713172: "IFCQUANTITYAREA",
  3710013099: "IFCPROPERTYENUMERATION",
  148025276: "IFCPROPERTYDEPENDENCYRELATIONSHIP",
  3896028662: "IFCPROPERTYCONSTRAINTRELATIONSHIP",
  2598011224: "IFCPROPERTY",
  2802850158: "IFCPROFILEPROPERTIES",
  3958567839: "IFCPROFILEDEF",
  2267347899: "IFCPRODUCTSOFCOMBUSTIONPROPERTIES",
  2095639259: "IFCPRODUCTREPRESENTATION",
  2417041796: "IFCPRESENTATIONSTYLEASSIGNMENT",
  3119450353: "IFCPRESENTATIONSTYLE",
  1304840413: "IFCPRESENTATIONLAYERWITHSTYLE",
  2022622350: "IFCPRESENTATIONLAYERASSIGNMENT",
  1775413392: "IFCPREDEFINEDTEXTFONT",
  3213052703: "IFCPREDEFINEDTERMINATORSYMBOL",
  990879717: "IFCPREDEFINEDSYMBOL",
  3727388367: "IFCPREDEFINEDITEM",
  3355820592: "IFCPOSTALADDRESS",
  2226359599: "IFCPHYSICALSIMPLEQUANTITY",
  2483315170: "IFCPHYSICALQUANTITY",
  101040310: "IFCPERSONANDORGANIZATION",
  2077209135: "IFCPERSON",
  1207048766: "IFCOWNERHISTORY",
  1411181986: "IFCORGANIZATIONRELATIONSHIP",
  4251960020: "IFCORGANIZATION",
  1227763645: "IFCOPTICALMATERIALPROPERTIES",
  2251480897: "IFCOBJECTIVE",
  3701648758: "IFCOBJECTPLACEMENT",
  1918398963: "IFCNAMEDUNIT",
  2706619895: "IFCMONETARYUNIT",
  3368373690: "IFCMETRIC",
  677618848: "IFCMECHANICALSTEELMATERIALPROPERTIES",
  4256014907: "IFCMECHANICALMATERIALPROPERTIES",
  2597039031: "IFCMEASUREWITHUNIT",
  3265635763: "IFCMATERIALPROPERTIES",
  2199411900: "IFCMATERIALLIST",
  1303795690: "IFCMATERIALLAYERSETUSAGE",
  3303938423: "IFCMATERIALLAYERSET",
  248100487: "IFCMATERIALLAYER",
  1847130766: "IFCMATERIALCLASSIFICATIONRELATIONSHIP",
  1838606355: "IFCMATERIAL",
  30780891: "IFCLOCALTIME",
  1566485204: "IFCLIGHTINTENSITYDISTRIBUTION",
  4162380809: "IFCLIGHTDISTRIBUTIONDATA",
  3452421091: "IFCLIBRARYREFERENCE",
  2655187982: "IFCLIBRARYINFORMATION",
  3020489413: "IFCIRREGULARTIMESERIESVALUE",
  852622518: "IFCGRIDAXIS",
  3548104201: "IFCEXTERNALLYDEFINEDTEXTFONT",
  3207319532: "IFCEXTERNALLYDEFINEDSYMBOL",
  1040185647: "IFCEXTERNALLYDEFINEDSURFACESTYLE",
  2242383968: "IFCEXTERNALLYDEFINEDHATCHSTYLE",
  3200245327: "IFCEXTERNALREFERENCE",
  1648886627: "IFCENVIRONMENTALIMPACTVALUE",
  3796139169: "IFCDRAUGHTINGCALLOUTRELATIONSHIP",
  770865208: "IFCDOCUMENTINFORMATIONRELATIONSHIP",
  1154170062: "IFCDOCUMENTINFORMATION",
  1376555844: "IFCDOCUMENTELECTRONICFORMAT",
  2949456006: "IFCDIMENSIONALEXPONENTS",
  1045800335: "IFCDERIVEDUNITELEMENT",
  1765591967: "IFCDERIVEDUNIT",
  1072939445: "IFCDATEANDTIME",
  3510044353: "IFCCURVESTYLEFONTPATTERN",
  2367409068: "IFCCURVESTYLEFONTANDSCALING",
  1105321065: "IFCCURVESTYLEFONT",
  539742890: "IFCCURRENCYRELATIONSHIP",
  602808272: "IFCCOSTVALUE",
  1065062679: "IFCCOORDINATEDUNIVERSALTIMEOFFSET",
  347226245: "IFCCONSTRAINTRELATIONSHIP",
  613356794: "IFCCONSTRAINTCLASSIFICATIONRELATIONSHIP",
  1658513725: "IFCCONSTRAINTAGGREGATIONRELATIONSHIP",
  1959218052: "IFCCONSTRAINT",
  2732653382: "IFCCONNECTIONSURFACEGEOMETRY",
  4257277454: "IFCCONNECTIONPORTGEOMETRY",
  2614616156: "IFCCONNECTIONPOINTGEOMETRY",
  2859738748: "IFCCONNECTIONGEOMETRY",
  3264961684: "IFCCOLOURSPECIFICATION",
  3639012971: "IFCCLASSIFICATIONNOTATIONFACET",
  938368621: "IFCCLASSIFICATIONNOTATION",
  1098599126: "IFCCLASSIFICATIONITEMRELATIONSHIP",
  1767535486: "IFCCLASSIFICATIONITEM",
  747523909: "IFCCLASSIFICATION",
  622194075: "IFCCALENDARDATE",
  2069777674: "IFCBOUNDARYNODECONDITIONWARPING",
  1387855156: "IFCBOUNDARYNODECONDITION",
  3367102660: "IFCBOUNDARYFACECONDITION",
  1560379544: "IFCBOUNDARYEDGECONDITION",
  4037036970: "IFCBOUNDARYCONDITION",
  3869604511: "IFCAPPROVALRELATIONSHIP",
  390851274: "IFCAPPROVALPROPERTYRELATIONSHIP",
  2080292479: "IFCAPPROVALACTORRELATIONSHIP",
  130549933: "IFCAPPROVAL",
  1110488051: "IFCAPPLIEDVALUERELATIONSHIP",
  411424972: "IFCAPPLIEDVALUE",
  639542469: "IFCAPPLICATION",
  618182010: "IFCADDRESS",
  3630933823: "IFCACTORROLE",
  599546466: "FILE_DESCRIPTION",
  1390159747: "FILE_NAME",
  1109904537: "FILE_SCHEMA"
};
var wn = class _wn {
  static async getUnits(t) {
    var e;
    const { IFCUNITASSIGNMENT: n } = web_ifc_api_exports, s = await t.getAllPropertiesOfType(n);
    if (!s)
      return 1;
    const i = Object.keys(s), r = s[parseInt(i[0], 10)];
    for (const o of r.Units) {
      if (o.value === void 0 || o.value === null)
        continue;
      const l = await t.getProperties(o.value);
      if (!l || !l.UnitType || !l.UnitType.value || l.UnitType.value !== "LENGTHUNIT")
        continue;
      let h = 1, d = 1;
      return l.Name.value === "METRE" && (d = 1), l.Name.value === "FOOT" && (d = 0.3048), ((e = l.Prefix) == null ? void 0 : e.value) === "MILLI" && (h = 1e-3), d * h;
    }
    return 1;
  }
  static async findItemByGuid(t, e) {
    var n;
    const s = t.getAllPropertiesIDs();
    for (const i of s) {
      const r = await t.getProperties(i);
      if (r && ((n = r.GlobalId) == null ? void 0 : n.value) === e)
        return r;
    }
    return null;
  }
  static async getRelationMap(t, e, n) {
    var s;
    const i = n ?? (async () => {
    }), r = {}, o = t.getAllPropertiesIDs();
    for (const l of o) {
      const h = await t.getProperties(l);
      if (!h)
        continue;
      const d = h.type === e, m = Object.keys(h).find(
        (x) => x.startsWith("Relating")
      ), f = Object.keys(h).find(
        (x) => x.startsWith("Related")
      );
      if (!(d && m && f))
        continue;
      const g = await t.getProperties((s = h[m]) == null ? void 0 : s.value), I = h[f];
      if (!g || !I || !(I && Array.isArray(I)))
        continue;
      const y = I.map((x) => x.value);
      await i(g.expressID, y), r[g.expressID] = y;
    }
    return r;
  }
  static async getQsetQuantities(t, e, n) {
    const s = n ?? (() => {
    }), i = await t.getProperties(e);
    return !i || i.type !== IFCELEMENTQUANTITY ? null : (i.Quantities ?? [{}]).map((r) => (r.value && s(r.value), r.value)).filter((r) => r !== null);
  }
  static async getPsetProps(t, e, n) {
    const s = n ?? (() => {
    }), i = await t.getProperties(e);
    return !i || i.type !== IFCPROPERTYSET ? null : (i.HasProperties ?? [{}]).map((r) => (r.value && s(r.value), r.value)).filter((r) => r !== null);
  }
  static async getPsetRel(t, e) {
    var n;
    if (!await t.getProperties(e))
      return null;
    const s = await t.getAllPropertiesOfType(
      IFCRELDEFINESBYPROPERTIES
    );
    if (!s)
      return null;
    const i = Object.values(s);
    let r = null;
    for (const o of i)
      ((n = o.RelatingPropertyDefinition) == null ? void 0 : n.value) === e && (r = o.expressID);
    return r;
  }
  static async getQsetRel(t, e) {
    return _wn.getPsetRel(t, e);
  }
  static async getEntityName(t, e) {
    var n;
    const s = await t.getProperties(e);
    if (!s)
      return { key: null, name: null };
    const i = Object.keys(s).find((o) => o.endsWith("Name")) ?? null, r = i ? (n = s[i]) == null ? void 0 : n.value : null;
    return { key: i, name: r };
  }
  static async getQuantityValue(t, e) {
    const n = await t.getProperties(e);
    if (!n)
      return { key: null, value: null };
    const s = Object.keys(n).find((r) => r.endsWith("Value")) ?? null;
    let i;
    return s === null || n[s] === void 0 || n[s] === null ? i = null : i = n[s].value, { key: s, value: i };
  }
  static isRel(t) {
    return rh[t].startsWith("IFCREL");
  }
  static async attributeExists(t, e, n) {
    const s = await t.getProperties(e);
    return s ? Object.keys(s).includes(n) : false;
  }
  static async groupEntitiesByType(t, e) {
    var n;
    const s = /* @__PURE__ */ new Map();
    for (const i of e) {
      const r = await t.getProperties(i);
      if (!r)
        continue;
      const o = r.type;
      s.get(o) || s.set(o, /* @__PURE__ */ new Set()), (n = s.get(o)) == null || n.add(i);
    }
    return s;
  }
  // static getPropertyUnits(properties: IfcProperties, expressID: number) {
  //   const entity = properties[expressID];
  //   if (!entity) return null;
  //   const propertyInstance =
  //     entity instanceof WEBIFC.IFC2X3.IfcProperty ||
  //     entity instanceof WEBIFC.IFC4.IfcProperty ||
  //     entity instanceof WEBIFC.IFC4X3.IfcProperty;
  //   if (!propertyInstance) return null;
  //   const { key: valueKey } = IfcPropertiesUtils.getQuantityValue(
  //     properties,
  //     expressID
  //   );
  //   if (!valueKey) return null;
  //   // @ts-ignore
  //   const measureName = entity[valueKey].constructor.name as string;
  //   const isMeasureAttribute = measureName.endsWith("Measure");
  //   if (!isMeasureAttribute) return null;
  //   const measureType = measureName.slice(3, measureName.length - 7);
  //   return propertyInstance;
  // }
};
var Tf = class {
  constructor() {
    S(this, "factor", 1), S(this, "complement", 1);
  }
  apply(t) {
    const e = this.getScaleMatrix().multiply(t);
    t.copy(e);
  }
  setUp(t) {
    var e;
    this.factor = 1;
    const n = this.getLengthUnits(t);
    if (!n)
      return;
    const s = n == null, i = n.Name === void 0 || n.Name === null;
    s || i || (n.Name.value === "FOOT" ? this.factor = 0.3048 : ((e = n.Prefix) == null ? void 0 : e.value) === "MILLI" && (this.complement = 1e-3));
  }
  getLengthUnits(t) {
    try {
      const e = t.GetLineIDsWithType(
        0,
        IFCUNITASSIGNMENT
      ).get(0), n = t.GetLine(0, e);
      for (const s of n.Units) {
        if (!s || s.value === null || s.value === void 0)
          continue;
        const i = t.GetLine(0, s.value);
        if (i.UnitType && i.UnitType.value === "LENGTHUNIT")
          return i;
      }
      return null;
    } catch {
      return console.log("Could not get units"), null;
    }
  }
  getScaleMatrix() {
    const t = this.factor;
    return new Matrix4().fromArray([
      t,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ]);
  }
};
var oh = class {
  constructor() {
    S(this, "itemsByFloor", {}), S(this, "_units", new Tf());
  }
  // TODO: Maybe make this more flexible so that it also support more exotic spatial structures?
  setUp(t) {
    this._units.setUp(t), this.cleanUp();
    try {
      const e = t.GetLineIDsWithType(
        0,
        IFCRELCONTAINEDINSPATIALSTRUCTURE
      ), n = /* @__PURE__ */ new Set(), s = t.GetLineIDsWithType(0, IFCSPACE);
      for (let h = 0; h < s.size(); h++)
        n.add(s.get(h));
      const i = t.GetLineIDsWithType(0, IFCRELAGGREGATES), r = i.size();
      for (let h = 0; h < r; h++) {
        const d = i.get(h), m = t.GetLine(0, d);
        if (!m || !m.RelatingObject || !m.RelatedObjects)
          continue;
        const f = m.RelatingObject.value, g = m.RelatedObjects;
        for (const I of g) {
          const y = I.value;
          n.has(y) && (this.itemsByFloor[y] = f);
        }
      }
      const o = {}, l = e.size();
      for (let h = 0; h < l; h++) {
        const d = e.get(h), m = t.GetLine(0, d);
        if (!m || !m.RelatingStructure || !m.RelatedElements)
          continue;
        const f = m.RelatingStructure.value, g = m.RelatedElements;
        if (n.has(f))
          for (const I of g) {
            o[f] || (o[f] = []);
            const y = I.value;
            o[f].push(y);
          }
        else
          for (const I of g) {
            const y = I.value;
            this.itemsByFloor[y] = f;
          }
      }
      for (const h in o) {
        const d = this.itemsByFloor[h];
        if (d !== void 0) {
          const m = o[h];
          for (const f of m)
            this.itemsByFloor[f] = d;
        }
      }
      for (let h = 0; h < r; h++) {
        const d = i.get(h), m = t.GetLine(0, d);
        if (!m || !m.RelatingObject || !m.RelatedObjects)
          continue;
        const f = m.RelatingObject.value, g = m.RelatedObjects;
        for (const I of g) {
          const y = I.value, x = this.itemsByFloor[f];
          x !== void 0 && (this.itemsByFloor[y] = x);
        }
      }
    } catch {
      console.log("Could not get floors.");
    }
  }
  cleanUp() {
    this.itemsByFloor = {};
  }
};
var _a = class {
  constructor() {
    S(this, "includeProperties", true), S(this, "optionalCategories", [IFCSPACE]), S(this, "coordinate", true), S(this, "wasm", {
      path: "",
      absolute: false,
      logLevel: LogLevel.LOG_LEVEL_OFF
    }), S(this, "excludedCategories", /* @__PURE__ */ new Set()), S(this, "saveLocations", false), S(this, "webIfc", {
      COORDINATE_TO_ORIGIN: true,
      OPTIMIZE_PROFILES: true
    }), S(this, "autoSetWasm", true), S(this, "customLocateFileHandler", null);
  }
};
var ah = class {
  constructor() {
    S(this, "defLineMat", new LineBasicMaterial({ color: 16777215 }));
  }
  read(t) {
    const e = t.GetAllAlignments(0), n = t.GetAllCrossSections2D(0), s = t.GetAllCrossSections3D(0), i = {
      IfcAlignment: e,
      IfcCrossSection2D: n,
      IfcCrossSection3D: s
    };
    return this.get(i);
  }
  get(t) {
    if (t.IfcAlignment) {
      const e = /* @__PURE__ */ new Map();
      for (const n of t.IfcAlignment) {
        const s = new ki();
        s.absolute = this.getCurves(n.curve3D, s), s.horizontal = this.getCurves(n.horizontal, s), s.vertical = this.getCurves(n.vertical, s), e.set(e.size, s);
      }
      return { alignments: e, coordinationMatrix: new Matrix4() };
    }
  }
  getCurves(t, e) {
    const n = [];
    let s = 0;
    for (const i of t) {
      const r = {};
      if (i.data)
        for (const f of i.data) {
          const [g, I] = f.split(": "), y = parseFloat(I);
          r[g] = y || I;
        }
      const { points: o } = i, l = new Float32Array(o.length * 3);
      for (let f = 0; f < o.length; f++) {
        const { x: g, y: I, z: y } = o[f];
        l[f * 3] = g, l[f * 3 + 1] = I, l[f * 3 + 2] = y || 0;
      }
      const h = new BufferAttribute(l, 3), d = new EdgesGeometry();
      d.setAttribute("position", h);
      const m = new ji(
        s,
        r,
        e,
        d,
        this.defLineMat
      );
      n.push(m.curve), s++;
    }
    return n;
  }
};
var lh = class {
  getNameInfo(t) {
    var e;
    const n = {}, { arguments: s } = t.GetHeaderLine(0, FILE_NAME) || {};
    if (!s)
      return n;
    const [
      i,
      r,
      o,
      l,
      h,
      d,
      m
    ] = s;
    if (i != null && i.value && (n.name = i.value), r != null && r.value && (n.creationDate = new Date(r.value)), o) {
      n.author = {};
      const [f, g] = o;
      f != null && f.value && (n.author.name = f.value), g != null && g.value && (n.author.email = g.value);
    }
    return (e = l[0]) != null && e.value && (n.organization = l[0].value), h != null && h.value && (n.preprocessorVersion = h == null ? void 0 : h.value), d != null && d.value && (n.originatingSystem = d == null ? void 0 : d.value), m != null && m.value && (n.authorization = m == null ? void 0 : m.value), n;
  }
  getDescriptionInfo(t) {
    var e;
    const n = {}, { arguments: s } = t.GetHeaderLine(0, FILE_DESCRIPTION) || {};
    if (!s)
      return n;
    const [i, r] = s;
    if ((e = i[0]) != null && e.value) {
      const o = i[0].value.match(/\[([^\]]+)\]/);
      o[1] && (n.viewDefinition = o[1]);
    }
    return r != null && r.value && (n.implementationLevel = r.value), n;
  }
};
var ch = class wa extends Re {
  constructor(t) {
    super(t), S(this, "onIfcStartedLoading", new $()), S(this, "onSetup", new $()), S(this, "onDisposed", new $()), S(this, "settings", new _a()), S(this, "enabled", true), S(this, "webIfc", new IfcAPI2()), S(this, "_material", new MeshLambertMaterial()), S(this, "_spatialTree", new oh()), S(this, "_metaData", new lh()), S(this, "_fragmentInstances", /* @__PURE__ */ new Map()), S(this, "_civil", new ah()), S(this, "_visitedFragments", /* @__PURE__ */ new Map()), S(this, "_materialT", new MeshLambertMaterial({
      transparent: true,
      opacity: 0.5
    })), this.components.add(wa.uuid, this), this.settings.excludedCategories.add(IFCOPENINGELEMENT);
  }
  dispose() {
    this.webIfc = null, this.onDisposed.trigger(wa.uuid), this.onDisposed.reset();
  }
  async setup(t) {
    this.settings = { ...this.settings, ...t }, this.settings.autoSetWasm && await this.autoSetWasm(), this.onSetup.trigger();
  }
  async load(t, e = true) {
    const n = performance.now();
    this.onIfcStartedLoading.trigger(), await this.readIfcFile(t);
    const s = await this.getAllGeometries(), i = await this.components.get(wf).export(this.webIfc, 0);
    s.setLocalProperties(i), this.cleanUp();
    const r = this.components.get(We);
    r.groups.set(s.uuid, s);
    for (const o of s.items)
      r.list.set(o.id, o), o.mesh.uuid = o.id, o.group = s;
    return r.onFragmentsLoaded.trigger(s), e && r.coordinate([s]), console.log(`Streaming the IFC took ${performance.now() - n} ms!`), s;
  }
  async readIfcFile(t) {
    const { path: e, absolute: n, logLevel: s } = this.settings.wasm;
    return this.webIfc.SetWasmPath(e, n), await this.webIfc.Init(), s && this.webIfc.SetLogLevel(s), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  async getAllGeometries() {
    this._spatialTree.setUp(this.webIfc);
    const t = this.webIfc.GetIfcEntityList(0), e = new Gi();
    e.ifcMetadata = {
      name: "",
      description: "",
      ...this._metaData.getNameInfo(this.webIfc),
      ...this._metaData.getDescriptionInfo(this.webIfc),
      schema: this.webIfc.GetModelSchema(0) || "IFC2X3",
      maxExpressID: this.webIfc.GetMaxExpressID(0)
    };
    const n = [];
    for (const i of t) {
      if (!this.webIfc.IsIfcElement(i) && i !== IFCSPACE || this.settings.excludedCategories.has(i))
        continue;
      const r = this.webIfc.GetLineIDsWithType(0, i), o = r.size();
      for (let l = 0; l < o; l++) {
        const h = r.get(l);
        n.push(h);
        const d = this._spatialTree.itemsByFloor[h] || 0;
        e.data.set(h, [[], [d, i]]);
      }
    }
    this._spatialTree.cleanUp(), this.webIfc.StreamMeshes(0, n, (i) => {
      this.getMesh(i, e);
    });
    for (const i of this._visitedFragments) {
      const { index: r, fragment: o } = i[1];
      e.keyFragments.set(r, o.id);
    }
    for (const i of e.items) {
      const r = this._fragmentInstances.get(i.id);
      if (!r)
        throw new Error("Fragment not found!");
      const o = [];
      for (const [l, h] of r)
        o.push(h);
      i.add(o);
    }
    const s = this.webIfc.GetCoordinationMatrix(0);
    return e.coordinationMatrix.fromArray(s), e.civilData = this._civil.read(this.webIfc), e;
  }
  cleanUp() {
    this.webIfc = null, this.webIfc = new IfcAPI2(), this._visitedFragments.clear(), this._fragmentInstances.clear();
  }
  getMesh(t, e) {
    const n = t.geometries.size(), s = t.expressID;
    for (let i = 0; i < n; i++) {
      const r = t.geometries.get(i), { x: o, y: l, z: h, w: d } = r.color, m = d !== 1, { geometryExpressID: f } = r, g = `${f}-${m}`;
      if (!this._visitedFragments.has(g)) {
        const b = this.getGeometry(this.webIfc, f), O = m ? this._materialT : this._material, k = new Ni(b, O, 1);
        e.add(k.mesh), e.items.push(k);
        const Y = this._visitedFragments.size;
        this._visitedFragments.set(g, { index: Y, fragment: k });
      }
      const I = new Color().setRGB(o, l, h, "srgb"), y = new Matrix4();
      y.fromArray(r.flatTransformation);
      const x = this._visitedFragments.get(g);
      if (x === void 0)
        throw new Error("Error getting geometry data for streaming!");
      const A = e.data.get(s);
      if (!A)
        throw new Error("Data not found!");
      A[0].push(x.index);
      const { fragment: F } = x;
      this._fragmentInstances.has(F.id) || this._fragmentInstances.set(F.id, /* @__PURE__ */ new Map());
      const P = this._fragmentInstances.get(F.id);
      if (!P)
        throw new Error("Instances not found!");
      if (P.has(s)) {
        const b = P.get(s);
        if (!b)
          throw new Error("Instance not found!");
        b.transforms.push(y), b.colors && b.colors.push(I);
      } else
        P.set(s, { id: s, transforms: [y], colors: [I] });
    }
  }
  getGeometry(t, e) {
    const n = t.GetGeometry(0, e), s = t.GetIndexArray(
      n.GetIndexData(),
      n.GetIndexDataSize()
    ), i = t.GetVertexArray(
      n.GetVertexData(),
      n.GetVertexDataSize()
    ), r = new Float32Array(i.length / 2), o = new Float32Array(i.length / 2);
    for (let m = 0; m < i.length; m += 6)
      r[m / 2] = i[m], r[m / 2 + 1] = i[m + 1], r[m / 2 + 2] = i[m + 2], o[m / 2] = i[m + 3], o[m / 2 + 1] = i[m + 4], o[m / 2 + 2] = i[m + 5];
    const l = new BufferGeometry(), h = new BufferAttribute(r, 3), d = new BufferAttribute(o, 3);
    return l.setAttribute("position", h), l.setAttribute("normal", d), l.setIndex(Array.from(s)), n.delete(), l;
  }
  async autoSetWasm() {
    const t = await fetch(
      `https://unpkg.com/openbim-components@${jd.release}/package.json`
    );
    if (!t.ok) {
      console.warn(
        "Couldn't get openbim-components package.json. Set wasm settings manually."
      );
      return;
    }
    const e = await t.json();
    if (!("web-ifc" in e.peerDependencies))
      console.warn(
        "Couldn't get web-ifc from peer dependencies in openbim-components. Set wasm settings manually."
      );
    else {
      const n = e.peerDependencies["web-ifc"];
      this.settings.wasm.path = `https://unpkg.com/web-ifc@${n}/`, this.settings.wasm.absolute = true;
    }
  }
};
S(ch, "uuid", "a659add7-1418-4771-a0d6-7d4d438e4624");
var bf = ch;
var xf = class hs extends Re {
  constructor(t) {
    super(t), S(this, "onDisposed", new $()), S(this, "onRequestFile", new $()), S(this, "ifcToExport", null), S(this, "onElementToPset", new $()), S(this, "onPropToPset", new $()), S(this, "onPsetRemoved", new $()), S(this, "onDataChanged", new $()), S(this, "wasm", {
      path: "/",
      absolute: false
    }), S(this, "enabled", true), S(this, "attributeListeners", {}), S(this, "selectedModel"), S(this, "changeMap", {}), this.components.add(hs.uuid, this);
  }
  dispose() {
    this.selectedModel = void 0, this.attributeListeners = {}, this.changeMap = {}, this.onElementToPset.reset(), this.onPropToPset.reset(), this.onPsetRemoved.reset(), this.onDataChanged.reset(), this.onDisposed.trigger(hs.uuid), this.onDisposed.reset();
  }
  increaseMaxID(t) {
    return t.ifcMetadata.maxExpressID++, t.ifcMetadata.maxExpressID;
  }
  static getIFCSchema(t) {
    const e = t.ifcMetadata.schema;
    if (!e)
      throw new Error("IFC Schema not found");
    return e;
  }
  newGUID(t) {
    const e = hs.getIFCSchema(t);
    return new web_ifc_api_exports[e].IfcGloballyUniqueId(La.create());
  }
  async getOwnerHistory(t) {
    const e = await t.getAllPropertiesOfType(
      IFCOWNERHISTORY
    );
    if (!e)
      throw new Error("No OwnerHistory was found.");
    const n = Object.keys(e).map((r) => parseInt(r, 10)), s = e[n[0]], i = new Handle(s.expressID);
    return { ownerHistory: s, ownerHistoryHandle: i };
  }
  registerChange(t, ...e) {
    this.changeMap[t.uuid] || (this.changeMap[t.uuid] = /* @__PURE__ */ new Set());
    for (const n of e)
      this.changeMap[t.uuid].add(n), this.onDataChanged.trigger({ model: t, expressID: n });
  }
  async setData(t, ...e) {
    for (const n of e) {
      const s = n.expressID;
      s && (await t.setProperties(s, n), this.registerChange(t, s));
    }
  }
  async newPset(t, e, n) {
    const s = hs.getIFCSchema(t), { ownerHistoryHandle: i } = await this.getOwnerHistory(t), r = this.newGUID(t), o = new web_ifc_api_exports[s].IfcLabel(e), l = n ? new web_ifc_api_exports[s].IfcText(n) : null, h = new web_ifc_api_exports[s].IfcPropertySet(
      r,
      i,
      o,
      l,
      []
    );
    h.expressID = this.increaseMaxID(t);
    const d = this.newGUID(t), m = new web_ifc_api_exports[s].IfcRelDefinesByProperties(
      d,
      i,
      null,
      null,
      [],
      new Handle(h.expressID)
    );
    return m.expressID = this.increaseMaxID(t), await this.setData(t, h, m), { pset: h, rel: m };
  }
  async removePset(t, ...e) {
    for (const n of e) {
      const s = await t.getProperties(n);
      if ((s == null ? void 0 : s.type) !== IFCPROPERTYSET)
        continue;
      const i = await wn.getPsetRel(t, n);
      if (i && (await t.setProperties(i, null), this.registerChange(t, i)), s) {
        for (const r of s.HasProperties)
          await t.setProperties(r.value, null);
        await t.setProperties(n, null), this.onPsetRemoved.trigger({ model: t, psetID: n }), this.registerChange(t, n);
      }
    }
  }
  async newSingleProperty(t, e, n, s) {
    const i = hs.getIFCSchema(t), r = new web_ifc_api_exports[i].IfcIdentifier(n), o = new web_ifc_api_exports[i][e](s), l = new web_ifc_api_exports[i].IfcPropertySingleValue(
      r,
      null,
      o,
      null
    );
    return l.expressID = this.increaseMaxID(t), await this.setData(t, l), l;
  }
  newSingleStringProperty(t, e, n, s) {
    return this.newSingleProperty(t, e, n, s);
  }
  newSingleNumericProperty(t, e, n, s) {
    return this.newSingleProperty(t, e, n, s);
  }
  newSingleBooleanProperty(t, e, n, s) {
    return this.newSingleProperty(t, e, n, s);
  }
  async removePsetProp(t, e, n) {
    const s = await t.getProperties(e), i = await t.getProperties(n);
    !s || !i || s.type === IFCPROPERTYSET && i && (s.HasProperties = s.HasProperties.filter((r) => r.value !== n), await t.setProperties(n, null), this.registerChange(t, e, n));
  }
  async addElementToPset(t, e, ...n) {
    const s = await wn.getPsetRel(t, e);
    if (!s)
      return;
    const i = await t.getProperties(s);
    if (i) {
      for (const r of n) {
        const o = new Handle(r);
        i.RelatedObjects.push(o), this.onElementToPset.trigger({
          model: t,
          psetID: e,
          elementID: r
        });
      }
      this.registerChange(t, e);
    }
  }
  async addPropToPset(t, e, ...n) {
    const s = await t.getProperties(e);
    if (s) {
      for (const i of n) {
        if (s.HasProperties.includes(i))
          continue;
        const r = new Handle(i);
        s.HasProperties.push(r), this.onPropToPset.trigger({ model: t, psetID: e, propID: i });
      }
      this.registerChange(t, e);
    }
  }
  async saveToIfc(t, e) {
    const n = this.components.get(bf), s = n.webIfc, i = await n.readIfcFile(e), r = this.changeMap[t.uuid] ?? [];
    for (const l of r) {
      const h = await t.getProperties(l);
      if (h)
        try {
          s.WriteLine(i, h);
        } catch {
        }
      else
        try {
          s.DeleteLine(i, l);
        } catch {
        }
    }
    const o = s.SaveModel(i);
    return n.webIfc.CloseModel(i), n.cleanUp(), o;
  }
  async setAttributeListener(t, e, n) {
    this.attributeListeners[t.uuid] || (this.attributeListeners[t.uuid] = {});
    const s = this.attributeListeners[t.uuid][e] ? this.attributeListeners[t.uuid][e][n] : null;
    if (s)
      return s;
    const i = await t.getProperties(e);
    if (!i)
      throw new Error(`Entity with expressID ${e} doesn't exists.`);
    const r = i[n];
    if (Array.isArray(r) || !r)
      throw new Error(
        `Attribute ${n} is array or null, and it can't have a listener.`
      );
    const o = r.value;
    if (o === void 0 || o == null)
      throw new Error(`Attribute ${n} has a badly defined handle.`);
    const l = new $();
    return Object.defineProperty(i[n], "value", {
      get() {
        return this._value;
      },
      async set(h) {
        this._value = h, l.trigger(h);
      }
    }), i[n].value = o, this.attributeListeners[t.uuid][e] || (this.attributeListeners[t.uuid][e] = {}), this.attributeListeners[t.uuid][e][n] = l, l;
  }
};
S(xf, "uuid", "58c2d9f0-183c-48d6-a402-dfcf5b9a34df");
var hh = class uh extends Re {
  constructor(t) {
    super(t), S(this, "enabled", true), S(this, "list", {}), S(this, "onDisposed", new $()), S(this, "onFragmentsDisposed", (e) => {
      const { groupID: n, fragmentIDs: s } = e;
      for (const i in this.list) {
        const r = this.list[i], o = Object.keys(r);
        if (o.includes(n))
          delete r[n], Object.values(r).length === 0 && delete this.list[i];
        else
          for (const l of o) {
            const h = r[l];
            for (const d of s)
              delete h[d];
            Object.values(h).length === 0 && delete r[l];
          }
      }
    }), t.add(uh.uuid, this), t.get(We).onFragmentsDisposed.add(this.onFragmentsDisposed);
  }
  dispose() {
    this.list = {}, this.components.get(We).onFragmentsDisposed.remove(this.onFragmentsDisposed), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  remove(t) {
    for (const e in this.list) {
      const n = this.list[e];
      for (const s in n) {
        const i = n[s];
        delete i[t];
      }
    }
  }
  find(t) {
    const e = this.components.get(We);
    if (!t) {
      const r = {};
      for (const [o, l] of e.list)
        r[o] = new Set(l.ids);
      return r;
    }
    const n = Object.keys(t).length, s = {};
    for (const r in t) {
      const o = t[r];
      if (!this.list[r]) {
        console.warn(`Classification ${r} does not exist.`);
        continue;
      }
      for (const l of o) {
        const h = this.list[r][l];
        if (h)
          for (const d in h) {
            s[d] || (s[d] = /* @__PURE__ */ new Map());
            for (const m of h[d]) {
              const f = s[d].get(m);
              f === void 0 ? s[d].set(m, 1) : s[d].set(m, f + 1);
            }
          }
      }
    }
    const i = {};
    for (const r in s) {
      const o = s[r];
      for (const [l, h] of o) {
        if (h === void 0)
          throw new Error("Malformed fragments map!");
        h === n && (i[r] || (i[r] = /* @__PURE__ */ new Set()), i[r].add(l));
      }
    }
    return i;
  }
  byModel(t, e) {
    this.list.models || (this.list.models = {});
    const n = this.list.models;
    n[t] || (n[t] = {});
    const s = n[t];
    for (const [i, r] of e.data) {
      const o = r[0];
      for (const l of o) {
        const h = e.keyFragments.get(l);
        h && (s[h] || (s[h] = /* @__PURE__ */ new Set()), s[h].add(i));
      }
    }
  }
  async byPredefinedType(t) {
    var e;
    this.list.predefinedTypes || (this.list.predefinedTypes = {});
    const n = this.list.predefinedTypes, s = t.getAllPropertiesIDs();
    for (const i of s) {
      const r = await t.getProperties(i);
      if (!r)
        continue;
      const o = String((e = r.PredefinedType) == null ? void 0 : e.value).toUpperCase();
      n[o] || (n[o] = {});
      const l = n[o];
      for (const [h, d] of t.data) {
        const m = d[0];
        for (const f of m) {
          const g = t.keyFragments.get(f);
          if (!g)
            throw new Error("Fragment ID not found!");
          l[g] || (l[g] = /* @__PURE__ */ new Set()), l[g].add(r.expressID);
        }
      }
    }
  }
  byEntity(t) {
    this.list.entities || (this.list.entities = {});
    for (const [e, n] of t.data) {
      const s = n[1][1], i = rh[s];
      this.saveItem(t, "entities", i, e);
    }
  }
  async byIfcRel(t, e, n) {
    wn.isRel(e) && await wn.getRelationMap(
      t,
      e,
      async (s, i) => {
        const { name: r } = await wn.getEntityName(
          t,
          s
        );
        for (const o of i)
          this.saveItem(
            t,
            n,
            r ?? "NO REL NAME",
            o
          );
      }
    );
  }
  async bySpatialStructure(t) {
    var e;
    const n = this.components.get(Xr), s = n.relationMaps[t.uuid];
    if (!s)
      throw new Error(
        `Classifier: model relations of ${t.name || t.uuid} have to exists to group by spatial structure.`
      );
    const i = "spatialStructures";
    for (const [r] of s) {
      const o = n.getEntityRelations(
        t,
        r,
        "ContainsElements"
      ), l = await t.getProperties(r);
      if (!(o && l))
        continue;
      const h = (e = l.Name) == null ? void 0 : e.value;
      for (const d of o) {
        this.saveItem(t, i, h, d);
        const m = n.getEntityRelations(
          t,
          Number(d),
          "IsDecomposedBy"
        );
        if (m)
          for (const f of m)
            this.saveItem(t, i, h, f);
      }
    }
  }
  setColor(t, e, n = false) {
    const s = this.components.get(We);
    for (const i in t) {
      const r = s.list.get(i);
      if (!r)
        continue;
      const o = t[i];
      r.setColor(e, o, n);
    }
  }
  resetColor(t) {
    const e = this.components.get(We);
    for (const n in t) {
      const s = e.list.get(n);
      if (!s)
        continue;
      const i = t[n];
      s.resetColor(i);
    }
  }
  saveItem(t, e, n, s) {
    this.list[e] || (this.list[e] = {});
    const i = t.data.get(s);
    if (i)
      for (const r of i[0]) {
        const o = t.keyFragments.get(r);
        if (o) {
          const l = this.list[e];
          l[n] || (l[n] = {}), l[n][o] || (l[n][o] = /* @__PURE__ */ new Set()), l[n][o].add(s);
        }
      }
  }
};
S(hh, "uuid", "e25a7f3c-46c4-4a14-9d3d-5115f24ebeb7");
var Sf = hh;
var Af = class dh extends Re {
  constructor(t) {
    super(t), S(this, "enabled", true), S(this, "height", 10), S(this, "groupName", "storeys"), S(this, "onDisposed", new $()), S(this, "list", /* @__PURE__ */ new Set()), t.add(dh.uuid, this);
  }
  dispose() {
    this.list.clear(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  set(t) {
    if (!this.enabled)
      return;
    const e = this.components.get(Sf), n = this.components.get(We), s = t ? 1 : -1;
    let i = 0;
    const r = e.list[this.groupName], o = new Matrix4();
    for (const l in r) {
      o.elements[13] = i * s * this.height;
      for (const h in r[l]) {
        const d = n.list.get(h), m = l + h, f = this.list.has(m);
        if (!d || t && f || !t && !f)
          continue;
        t ? this.list.add(m) : this.list.delete(m);
        const g = r[l][h];
        d.applyTransform(g, o);
      }
      i++;
    }
  }
};
S(Af, "uuid", "d260618b-ce88-4c7d-826c-6debb91de3e2");
var Rf = class fh extends Re {
  constructor(t) {
    super(t), S(this, "enabled", true), this.components.add(fh.uuid, this);
  }
  set(t, e) {
    const n = this.components.get(We);
    if (!e) {
      for (const s in n.list) {
        const i = n.list.get(s);
        i && (i.setVisibility(t), this.updateCulledVisibility(i));
      }
      return;
    }
    for (const s in e) {
      const i = e[s], r = n.list.get(s);
      r && (r.setVisibility(t, i), this.updateCulledVisibility(r));
    }
  }
  isolate(t) {
    this.set(false), this.set(true, t);
  }
  updateCulledVisibility(t) {
    const e = this.components.get(vf);
    for (const [n, s] of e.list) {
      const i = s.colorMeshes.get(t.id);
      i && (i.count = t.mesh.count);
    }
  }
};
S(Rf, "uuid", "dd9ccf2d-8a21-4821-b7f6-2949add16a29");
var Ff = class extends _a {
  constructor() {
    super(...arguments), S(this, "minGeometrySize", 10), S(this, "minAssetsSize", 1e3);
  }
};
var ph = class extends _a {
  constructor() {
    super(...arguments), S(this, "propertiesSize", 100);
  }
};
var Pf = class extends Re {
  constructor() {
    super(...arguments), S(this, "onPropertiesStreamed", new yn()), S(this, "onProgress", new yn()), S(this, "onIndicesStreamed", new yn()), S(this, "onDisposed", new $()), S(this, "enabled", true), S(this, "settings", new ph()), S(this, "webIfc", new IfcAPI2());
  }
  async dispose() {
    this.onIndicesStreamed.reset(), this.onPropertiesStreamed.reset(), this.webIfc = null, this.onDisposed.reset();
  }
  async streamFromBuffer(t) {
    const e = performance.now();
    await this.readIfcFile(t), await this.streamAllProperties(), this.cleanUp(), console.log(`Streaming the IFC took ${performance.now() - e} ms!`);
  }
  async streamFromCallBack(t) {
    const e = performance.now();
    await this.streamIfcFile(t), await this.streamAllProperties(), this.cleanUp(), console.log(`Streaming the IFC took ${performance.now() - e} ms!`);
  }
  async readIfcFile(t) {
    const { path: e, absolute: n, logLevel: s } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, n), await this.webIfc.Init(), s && this.webIfc.SetLogLevel(s), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  async streamIfcFile(t) {
    const { path: e, absolute: n, logLevel: s } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, n), await this.webIfc.Init(), s && this.webIfc.SetLogLevel(s), this.webIfc.OpenModelFromCallback(t, this.settings.webIfc);
  }
  async streamAllProperties() {
    const { propertiesSize: t } = this.settings, e = new Set(this.webIfc.GetIfcEntityList(0)), n = [
      IFCRELDEFINESBYPROPERTIES,
      IFCRELDEFINESBYTYPE,
      IFCRELASSOCIATESMATERIAL,
      IFCRELCONTAINEDINSPATIALSTRUCTURE,
      IFCRELASSOCIATESCLASSIFICATION,
      IFCRELASSIGNSTOGROUP
    ], s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set([
      IFCPROJECT,
      IFCSITE,
      IFCBUILDING,
      IFCBUILDINGSTOREY,
      IFCSPACE
    ]);
    for (const h of i)
      e.add(h);
    let r = 0.01, o = 0;
    for (const h of e) {
      if (o++, Na.has(h))
        continue;
      const d = i.has(h), m = this.webIfc.GetLineIDsWithType(0, h), f = m.size();
      let g = 0;
      for (let y = 0; y < f - t; y += t) {
        const x = {};
        for (let A = 0; A < t; A++) {
          g++;
          const F = m.get(y + A);
          try {
            const P = this.webIfc.GetLine(0, F, d);
            n.includes(h) && this.getIndices(P, F, s), x[P.expressID] = P;
          } catch {
            console.log(`Could not get property: ${F}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type: h, data: x });
      }
      if (g !== f) {
        const y = {};
        for (let x = g; x < f; x++) {
          const A = m.get(x);
          try {
            const F = this.webIfc.GetLine(0, A, d);
            n.includes(h) && this.getIndices(F, A, s), y[F.expressID] = F;
          } catch {
            console.log(`Could not get property: ${A}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type: h, data: y });
      }
      const I = o / e.size;
      I > r && (r += 0.01, r = Math.max(r, I), await this.onProgress.trigger(Math.round(r * 100) / 100));
    }
    const l = [];
    for (const [h, d] of s)
      l.push([h, ...d]);
    await this.onIndicesStreamed.trigger(l);
  }
  getIndices(t, e, n) {
    const s = t.RelatedObjects || t.RelatedElements;
    if (!s) {
      console.log(`Related objects not found: ${e}`);
      return;
    }
    const i = t.RelatingType || t.RelatingMaterial || t.RelatingStructure || t.RelatingPropertyDefinition || t.RelatingGroup || t.RelatingClassification;
    if (!i) {
      console.log(`Relating object not found: ${e}`);
      return;
    }
    if (!Array.isArray(s) || i.value === void 0)
      return;
    const r = i.value;
    for (const o of s) {
      if (o.value === void 0 || o.value === null)
        continue;
      const l = o.value;
      n.has(l) || n.set(l, /* @__PURE__ */ new Set()), n.get(l).add(r);
    }
  }
  cleanUp() {
    this.webIfc = null, this.webIfc = new IfcAPI2();
  }
};
S(Pf, "uuid", "88d2c89c-ce32-47d7-8cb6-d51e4b311a0b");
var Mf = class mh extends Re {
  constructor(t) {
    super(t), S(this, "onGeometryStreamed", new $()), S(this, "onAssetStreamed", new $()), S(this, "onProgress", new $()), S(this, "onIfcLoaded", new $()), S(this, "onDisposed", new $()), S(this, "settings", new Ff()), S(this, "enabled", true), S(this, "webIfc", new IfcAPI2()), S(this, "_spatialTree", new oh()), S(this, "_metaData", new lh()), S(this, "_visitedGeometries", /* @__PURE__ */ new Map()), S(this, "_streamSerializer", new Xi()), S(this, "_geometries", /* @__PURE__ */ new Map()), S(this, "_geometryCount", 0), S(this, "_civil", new ah()), S(this, "_groupSerializer", new Hi()), S(this, "_assets", []), S(this, "_meshesWithHoles", /* @__PURE__ */ new Set()), this.components.add(mh.uuid, this), this.settings.excludedCategories.add(IFCOPENINGELEMENT);
  }
  dispose() {
    this.onIfcLoaded.reset(), this.onGeometryStreamed.reset(), this.onAssetStreamed.reset(), this.webIfc = null, this.onDisposed.trigger(), this.onDisposed.reset();
  }
  async streamFromBuffer(t) {
    const e = performance.now();
    await this.readIfcFile(t), await this.streamAllGeometries(), this.cleanUp(), console.log(`Streaming the IFC took ${performance.now() - e} ms!`);
  }
  async streamFromCallBack(t) {
    const e = performance.now();
    await this.streamIfcFile(t), await this.streamAllGeometries(), this.cleanUp(), console.log(`Streaming the IFC took ${performance.now() - e} ms!`);
  }
  async readIfcFile(t) {
    const { path: e, absolute: n, logLevel: s } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, n), await this.webIfc.Init(), s && this.webIfc.SetLogLevel(s), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  async streamIfcFile(t) {
    const { path: e, absolute: n, logLevel: s } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, n), await this.webIfc.Init(), s && this.webIfc.SetLogLevel(s), this.webIfc.OpenModelFromCallback(t, this.settings.webIfc);
  }
  async streamAllGeometries() {
    const { minGeometrySize: t, minAssetsSize: e } = this.settings;
    this._spatialTree.setUp(this.webIfc);
    const n = this.webIfc.GetIfcEntityList(0), s = [[]], i = new Gi();
    i.ifcMetadata = {
      name: "",
      description: "",
      ...this._metaData.getNameInfo(this.webIfc),
      ...this._metaData.getDescriptionInfo(this.webIfc),
      schema: this.webIfc.GetModelSchema(0) || "IFC2X3",
      maxExpressID: this.webIfc.GetMaxExpressID(0)
    };
    let r = 0, o = 0;
    for (const y of n) {
      if (!this.webIfc.IsIfcElement(y) && y !== IFCSPACE || this.settings.excludedCategories.has(y))
        continue;
      const x = this.webIfc.GetLineIDsWithType(0, y), A = x.size();
      for (let F = 0; F < A; F++) {
        r > t && (r = 0, o++, s.push([]));
        const P = x.get(F);
        s[o].push(P);
        const b = this._spatialTree.itemsByFloor[P] || 0;
        i.data.set(P, [[], [b, y]]), r++;
      }
    }
    this._spatialTree.cleanUp();
    let l = 0.01, h = 0;
    for (const y of s) {
      h++, this.webIfc.StreamMeshes(0, y, (A) => {
        this.getMesh(this.webIfc, A, i);
      }), this._geometryCount > t && await this.streamGeometries(), this._assets.length > e && await this.streamAssets();
      const x = h / s.length;
      x > l && (l += 0.01, l = Math.max(l, x), this.onProgress.trigger(Math.round(l * 100) / 100));
    }
    this._geometryCount && await this.streamGeometries(), this._assets.length && await this.streamAssets();
    const { opaque: d, transparent: m } = i.geometryIDs;
    for (const [y, { index: x, uuid: A }] of this._visitedGeometries)
      i.keyFragments.set(x, A), (y > 1 ? d : m).set(y, x);
    const f = i.data.keys();
    for (const y of f) {
      const [x] = i.data.get(y);
      x.length || i.data.delete(y);
    }
    const g = this.webIfc.GetCoordinationMatrix(0);
    i.coordinationMatrix.fromArray(g), i.civilData = this._civil.read(this.webIfc);
    const I = this._groupSerializer.export(i);
    this.onIfcLoaded.trigger(I), i.dispose(true);
  }
  cleanUp() {
    this.webIfc = null, this.webIfc = new IfcAPI2(), this._visitedGeometries.clear(), this._geometries.clear(), this._assets = [], this._meshesWithHoles.clear();
  }
  getMesh(t, e, n) {
    const s = e.geometries.size(), i = e.expressID, r = { id: i, geometries: [] };
    for (let o = 0; o < s; o++) {
      const l = e.geometries.get(o), h = l.geometryExpressID, d = l.color.w === 1 ? 1 : -1, m = h * d;
      if (!this._visitedGeometries.has(m)) {
        this._visitedGeometries.has(h) || this.getGeometry(t, h);
        const b = this._visitedGeometries.size, O = MathUtils.generateUUID();
        this._visitedGeometries.set(m, { uuid: O, index: b });
      }
      const f = this._visitedGeometries.get(m);
      if (f === void 0)
        throw new Error("Error getting geometry data for streaming!");
      const g = n.data.get(i);
      if (!g)
        throw new Error("Data not found!");
      g[0].push(f.index);
      const { x: I, y, z: x, w: A } = l.color, F = [I, y, x, A], P = l.flatTransformation;
      r.geometries.push({ color: F, geometryID: h, transformation: P });
    }
    this._assets.push(r);
  }
  getGeometry(t, e) {
    const n = t.GetGeometry(0, e), s = t.GetIndexArray(
      n.GetIndexData(),
      n.GetIndexDataSize()
    ), i = t.GetVertexArray(
      n.GetVertexData(),
      n.GetVertexDataSize()
    ), r = new Float32Array(i.length / 2), o = new Float32Array(i.length / 2);
    for (let f = 0; f < i.length; f += 6)
      r[f / 2] = i[f], r[f / 2 + 1] = i[f + 1], r[f / 2 + 2] = i[f + 2], o[f / 2] = i[f + 3], o[f / 2 + 1] = i[f + 4], o[f / 2 + 2] = i[f + 5];
    const l = Hd(r), h = new Float32Array(l.transformation.elements), d = [l.center.x, l.center.y, l.center.z];
    let m = false;
    for (let f = 0; f < r.length - 2; f += 3) {
      const g = r[f], I = r[f + 1], y = r[f + 2], x = o[f], A = o[f + 1], F = o[f + 2];
      if (Wd(d, [g, I, y], [x, A, F])) {
        m = true;
        break;
      }
    }
    this._geometries.set(e, {
      position: r,
      normal: o,
      index: s,
      boundingBox: h,
      hasHoles: m
    }), n.delete(), this._geometryCount++;
  }
  async streamAssets() {
    await this.onAssetStreamed.trigger(this._assets), this._assets = null, this._assets = [];
  }
  async streamGeometries() {
    let t = this._streamSerializer.export(this._geometries), e = {};
    for (const [n, { boundingBox: s, hasHoles: i }] of this._geometries)
      e[n] = { boundingBox: s, hasHoles: i };
    this.onGeometryStreamed.trigger({ data: e, buffer: t }), e = null, t = null, this._geometries.clear(), this._geometryCount = 0;
  }
};
S(Mf, "uuid", "d9999a00-e1f5-4d3f-8cfe-c56e08609764");
var Of = class extends Re {
  constructor() {
    super(...arguments), S(this, "onPropertiesStreamed", new yn()), S(this, "onProgress", new yn()), S(this, "onIndicesStreamed", new yn()), S(this, "onDisposed", new $()), S(this, "enabled", true), S(this, "settings", new ph()), S(this, "webIfc", new IfcAPI2());
  }
  async dispose() {
    this.onIndicesStreamed.reset(), this.onPropertiesStreamed.reset(), this.webIfc = null, this.onDisposed.reset();
  }
  async streamFromBuffer(t) {
    const e = performance.now();
    await this.readIfcFile(t), await this.streamAllProperties(), this.cleanUp(), console.log(`Streaming the IFC took ${performance.now() - e} ms!`);
  }
  async streamFromCallBack(t) {
    const e = performance.now();
    await this.streamIfcFile(t), await this.streamAllProperties(), this.cleanUp(), console.log(`Streaming the IFC took ${performance.now() - e} ms!`);
  }
  async readIfcFile(t) {
    const { path: e, absolute: n, logLevel: s } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, n), await this.webIfc.Init(), s && this.webIfc.SetLogLevel(s), this.webIfc.OpenModel(t, this.settings.webIfc);
  }
  async streamIfcFile(t) {
    const { path: e, absolute: n, logLevel: s } = this.settings.wasm;
    this.webIfc.SetWasmPath(e, n), await this.webIfc.Init(), s && this.webIfc.SetLogLevel(s), this.webIfc.OpenModelFromCallback(t, this.settings.webIfc);
  }
  async streamAllProperties() {
    const { propertiesSize: t } = this.settings, e = new Set(this.webIfc.GetIfcEntityList(0)), n = /* @__PURE__ */ new Set([
      IFCPROJECT,
      IFCSITE,
      IFCBUILDING,
      IFCBUILDINGSTOREY,
      IFCSPACE
    ]);
    for (const o of n)
      e.add(o);
    let s = 0.01, i = 0;
    for (const o of e) {
      if (i++, Na.has(o))
        continue;
      const l = n.has(o), h = this.webIfc.GetLineIDsWithType(0, o), d = h.size();
      let m = 0;
      for (let g = 0; g < d - t; g += t) {
        const I = {};
        for (let y = 0; y < t; y++) {
          m++;
          const x = h.get(g + y);
          try {
            const A = this.webIfc.GetLine(0, x, l);
            I[A.expressID] = A;
          } catch {
            console.log(`Could not get property: ${x}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type: o, data: I });
      }
      if (m !== d) {
        const g = {};
        for (let I = m; I < d; I++) {
          const y = h.get(I);
          try {
            const x = this.webIfc.GetLine(0, y, l);
            g[x.expressID] = x;
          } catch {
            console.log(`Could not get property: ${y}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type: o, data: g });
      }
      const f = i / e.size;
      f > s && (s += 0.01, s = Math.max(s, f), await this.onProgress.trigger(Math.round(s * 100) / 100));
    }
    const r = await this.components.get(Xr).processFromWebIfc(this.webIfc, 0);
    await this.onIndicesStreamed.trigger(r);
  }
  cleanUp() {
    this.webIfc = null, this.webIfc = new IfcAPI2();
  }
};
S(Of, "uuid", "88d2c89c-ce32-47d7-8cb6-d51e4b311a0b");
var gh = class Eh extends Re {
  constructor(t) {
    super(t), S(this, "enabled", true), t.add(Eh.uuid, this);
  }
  getFace(t, e, n) {
    if (!t.geometry.index)
      throw new Error("Geometry must be indexed!");
    const s = /* @__PURE__ */ new Map(), i = t.geometry.index.array, { plane: r } = this.getFaceData(
      e,
      n,
      t
    ), o = [];
    for (let m = 0; m < i.length / 3; m++) {
      const { plane: f, edges: g } = this.getFaceData(m, n, t);
      if (f.equals(r)) {
        o.push({ index: m, edges: g });
        for (const { id: I, points: y, distance: x } of g)
          s.set(I, { points: y, distance: x });
      }
    }
    let l = 0;
    const h = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Map();
    for (const { index: m, edges: f } of o) {
      const g = /* @__PURE__ */ new Map();
      for (const { id: b } of f)
        if (h.has(b)) {
          const O = h.get(b);
          g.set(b, O);
        }
      const I = f.map((b) => b.id);
      if (!g.size) {
        const b = l++;
        for (const { id: O } of f)
          h.set(O, b);
        d.set(b, {
          edges: new Set(I),
          indices: /* @__PURE__ */ new Set([m])
        });
        continue;
      }
      let y = null;
      const x = /* @__PURE__ */ new Set(), A = new Set(I);
      for (const [b, O] of g) {
        y === null ? y = O : O !== y && x.add(O), h.delete(b);
        const { edges: k } = d.get(O);
        k.delete(b), A.delete(b);
      }
      if (y === null)
        throw new Error("Error computing face!");
      const F = d.get(y), { indices: P } = F;
      P.add(m);
      for (const b of A) {
        h.set(b, y);
        const { edges: O } = F;
        O.add(b);
      }
      for (const b of x) {
        const O = d.get(b), { edges: k, indices: Y } = O, H = d.get(y), { edges: K, indices: Z } = H;
        for (const q of k)
          K.add(q), h.set(q, y);
        for (const q of Y)
          Z.add(q);
        d.delete(b);
      }
    }
    for (const [m, { indices: f, edges: g }] of d)
      if (f.has(e)) {
        const I = [];
        for (const y of g) {
          const x = s.get(y);
          I.push(x);
        }
        return { edges: I, indices: f };
      }
    return null;
  }
  static distanceFromPointToLine(t, e, n, s = false) {
    const i = new Line3(), r = new Vector3();
    return i.set(e, n), i.closestPointToPoint(t, s, r), r.distanceTo(t);
  }
  getFaceData(t, e, n) {
    const s = this.getVerticesAndNormal(n, t, e), { p1: i, p2: r, p3: o, faceNormal: l } = s;
    this.round(i), this.round(r), this.round(o), this.round(l);
    const h = [
      { id: `${i.x}|${i.y}|${i.z}`, value: i },
      { id: `${r.x}|${r.y}|${r.z}`, value: r },
      { id: `${o.x}|${o.y}|${o.z}`, value: o }
    ];
    h.sort((F, P) => F.id < P.id ? -1 : F.id > P.id ? 1 : 0);
    const [
      { id: d, value: m },
      { id: f, value: g },
      { id: I, value: y }
    ] = h, x = [
      {
        id: `${d}|${f}`,
        distance: m.distanceTo(g),
        points: [m, g]
      },
      {
        id: `${f}|${I}`,
        distance: g.distanceTo(y),
        points: [g, y]
      },
      {
        id: `${d}|${I}`,
        distance: m.distanceTo(y),
        points: [m, y]
      }
    ], A = new Plane();
    return A.setFromNormalAndCoplanarPoint(l, i), A.constant = Math.round(A.constant * 10) / 10, { plane: A, edges: x };
  }
  getVerticesAndNormal(t, e, n) {
    if (!t.geometry.index)
      throw new Error("Geometry must be indexed!");
    const s = t.geometry.index.array, i = t.geometry.attributes.position.array, r = t.geometry.attributes.normal.array, o = s[e * 3] * 3, l = s[e * 3 + 1] * 3, h = s[e * 3 + 2] * 3, d = new Vector3(i[o], i[o + 1], i[o + 2]), m = new Vector3(i[l], i[l + 1], i[l + 2]), f = new Vector3(i[h], i[h + 1], i[h + 2]), g = new Vector3(r[o], r[o + 1], r[o + 2]), I = new Vector3(r[l], r[l + 1], r[l + 2]), y = new Vector3(r[h], r[h + 1], r[h + 2]), x = (g.x + I.x + y.x) / 3, A = (g.y + I.y + y.y) / 3, F = (g.z + I.z + y.z) / 3, P = new Vector3(x, A, F);
    if (n !== void 0 && t instanceof InstancedMesh) {
      const b = new Matrix4();
      t.getMatrixAt(n, b);
      const O = new Matrix4();
      O.extractRotation(b), P.applyMatrix4(O), d.applyMatrix4(b), m.applyMatrix4(b), f.applyMatrix4(b);
    }
    return { p1: d, p2: m, p3: f, faceNormal: P };
  }
  round(t) {
    t.x = Math.trunc(t.x * 1e3) / 1e3, t.y = Math.trunc(t.y * 1e3) / 1e3, t.z = Math.trunc(t.z * 1e3) / 1e3;
  }
};
S(gh, "uuid", "267ca032-672f-4cb0-afa9-d24e904f39d6");
var Ar = gh;
var nc = new Box3();
var hr = new Vector3();
var vh = class extends InstancedBufferGeometry {
  constructor() {
    super(), this.isLineSegmentsGeometry = true, this.type = "LineSegmentsGeometry";
    const t = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], e = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], n = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(n), this.setAttribute("position", new Float32BufferAttribute(t, 3)), this.setAttribute("uv", new Float32BufferAttribute(e, 2));
  }
  applyMatrix4(t) {
    const e = this.attributes.instanceStart, n = this.attributes.instanceEnd;
    return e !== void 0 && (e.applyMatrix4(t), n.applyMatrix4(t), e.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(t) {
    let e;
    t instanceof Float32Array ? e = t : Array.isArray(t) && (e = new Float32Array(t));
    const n = new InstancedInterleavedBuffer(e, 6, 1);
    return this.setAttribute("instanceStart", new InterleavedBufferAttribute(n, 3, 0)), this.setAttribute("instanceEnd", new InterleavedBufferAttribute(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(t) {
    let e;
    t instanceof Float32Array ? e = t : Array.isArray(t) && (e = new Float32Array(t));
    const n = new InstancedInterleavedBuffer(e, 6, 1);
    return this.setAttribute("instanceColorStart", new InterleavedBufferAttribute(n, 3, 0)), this.setAttribute("instanceColorEnd", new InterleavedBufferAttribute(n, 3, 3)), this;
  }
  fromWireframeGeometry(t) {
    return this.setPositions(t.attributes.position.array), this;
  }
  fromEdgesGeometry(t) {
    return this.setPositions(t.attributes.position.array), this;
  }
  fromMesh(t) {
    return this.fromWireframeGeometry(new WireframeGeometry(t.geometry)), this;
  }
  fromLineSegments(t) {
    const e = t.geometry;
    return this.setPositions(e.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Box3());
    const t = this.attributes.instanceStart, e = this.attributes.instanceEnd;
    t !== void 0 && e !== void 0 && (this.boundingBox.setFromBufferAttribute(t), nc.setFromBufferAttribute(e), this.boundingBox.union(nc));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere()), this.boundingBox === null && this.computeBoundingBox();
    const t = this.attributes.instanceStart, e = this.attributes.instanceEnd;
    if (t !== void 0 && e !== void 0) {
      const n = this.boundingSphere.center;
      this.boundingBox.getCenter(n);
      let s = 0;
      for (let i = 0, r = t.count; i < r; i++)
        hr.fromBufferAttribute(t, i), s = Math.max(s, n.distanceToSquared(hr)), hr.fromBufferAttribute(e, i), s = Math.max(s, n.distanceToSquared(hr));
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(t) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(t);
  }
};
UniformsLib.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new Vector2(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
ShaderLib.line = {
  uniforms: UniformsUtils.merge([
    UniformsLib.common,
    UniformsLib.fog,
    UniformsLib.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
var di = class extends ShaderMaterial {
  constructor(t) {
    super({
      type: "LineMaterial",
      uniforms: UniformsUtils.clone(ShaderLib.line.uniforms),
      vertexShader: ShaderLib.line.vertexShader,
      fragmentShader: ShaderLib.line.fragmentShader,
      clipping: true
      // required for clipping support
    }), this.isLineMaterial = true, this.setValues(t);
  }
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(t) {
    this.uniforms.diffuse.value = t;
  }
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(t) {
    t === true ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(t) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = t);
  }
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(t) {
    t === true !== this.dashed && (this.needsUpdate = true), t === true ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(t) {
    this.uniforms.dashScale.value = t;
  }
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(t) {
    this.uniforms.dashSize.value = t;
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(t) {
    this.uniforms.dashOffset.value = t;
  }
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(t) {
    this.uniforms.gapSize.value = t;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(t) {
    this.uniforms && (this.uniforms.opacity.value = t);
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(t) {
    this.uniforms.resolution.value.copy(t);
  }
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(t) {
    this.defines && (t === true !== this.alphaToCoverage && (this.needsUpdate = true), t === true ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = true) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = false));
  }
};
var sc = new Vector3();
var ic = new Vector3();
var et = new Vector4();
var tt = new Vector4();
var Yt = new Vector4();
var sa = new Vector3();
var ia = new Matrix4();
var nt = new Line3();
var rc = new Vector3();
var ur = new Box3();
var dr = new Sphere();
var Ht = new Vector4();
var Xt;
var Bn;
function oc(u, t, e) {
  return Ht.set(0, 0, -t, 1).applyMatrix4(u.projectionMatrix), Ht.multiplyScalar(1 / Ht.w), Ht.x = Bn / e.width, Ht.y = Bn / e.height, Ht.applyMatrix4(u.projectionMatrixInverse), Ht.multiplyScalar(1 / Ht.w), Math.abs(Math.max(Ht.x, Ht.y));
}
function Df(u, t) {
  const e = u.matrixWorld, n = u.geometry, s = n.attributes.instanceStart, i = n.attributes.instanceEnd, r = Math.min(n.instanceCount, s.count);
  for (let o = 0, l = r; o < l; o++) {
    nt.start.fromBufferAttribute(s, o), nt.end.fromBufferAttribute(i, o), nt.applyMatrix4(e);
    const h = new Vector3(), d = new Vector3();
    Xt.distanceSqToSegment(nt.start, nt.end, d, h), d.distanceTo(h) < Bn * 0.5 && t.push({
      point: d,
      pointOnLine: h,
      distance: Xt.origin.distanceTo(d),
      object: u,
      face: null,
      faceIndex: o,
      uv: null,
      uv1: null
    });
  }
}
function Lf(u, t, e) {
  const n = t.projectionMatrix, i = u.material.resolution, r = u.matrixWorld, o = u.geometry, l = o.attributes.instanceStart, h = o.attributes.instanceEnd, d = Math.min(o.instanceCount, l.count), m = -t.near;
  Xt.at(1, Yt), Yt.w = 1, Yt.applyMatrix4(t.matrixWorldInverse), Yt.applyMatrix4(n), Yt.multiplyScalar(1 / Yt.w), Yt.x *= i.x / 2, Yt.y *= i.y / 2, Yt.z = 0, sa.copy(Yt), ia.multiplyMatrices(t.matrixWorldInverse, r);
  for (let f = 0, g = d; f < g; f++) {
    if (et.fromBufferAttribute(l, f), tt.fromBufferAttribute(h, f), et.w = 1, tt.w = 1, et.applyMatrix4(ia), tt.applyMatrix4(ia), et.z > m && tt.z > m)
      continue;
    if (et.z > m) {
      const P = et.z - tt.z, b = (et.z - m) / P;
      et.lerp(tt, b);
    } else if (tt.z > m) {
      const P = tt.z - et.z, b = (tt.z - m) / P;
      tt.lerp(et, b);
    }
    et.applyMatrix4(n), tt.applyMatrix4(n), et.multiplyScalar(1 / et.w), tt.multiplyScalar(1 / tt.w), et.x *= i.x / 2, et.y *= i.y / 2, tt.x *= i.x / 2, tt.y *= i.y / 2, nt.start.copy(et), nt.start.z = 0, nt.end.copy(tt), nt.end.z = 0;
    const y = nt.closestPointToPointParameter(sa, true);
    nt.at(y, rc);
    const x = MathUtils.lerp(et.z, tt.z, y), A = x >= -1 && x <= 1, F = sa.distanceTo(rc) < Bn * 0.5;
    if (A && F) {
      nt.start.fromBufferAttribute(l, f), nt.end.fromBufferAttribute(h, f), nt.start.applyMatrix4(r), nt.end.applyMatrix4(r);
      const P = new Vector3(), b = new Vector3();
      Xt.distanceSqToSegment(nt.start, nt.end, b, P), e.push({
        point: b,
        pointOnLine: P,
        distance: Xt.origin.distanceTo(b),
        object: u,
        face: null,
        faceIndex: f,
        uv: null,
        uv1: null
      });
    }
  }
}
var Nf = class extends Mesh {
  constructor(t = new vh(), e = new di({ color: Math.random() * 16777215 })) {
    super(t, e), this.isLineSegments2 = true, this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const t = this.geometry, e = t.attributes.instanceStart, n = t.attributes.instanceEnd, s = new Float32Array(2 * e.count);
    for (let r = 0, o = 0, l = e.count; r < l; r++, o += 2)
      sc.fromBufferAttribute(e, r), ic.fromBufferAttribute(n, r), s[o] = o === 0 ? 0 : s[o - 1], s[o + 1] = s[o] + sc.distanceTo(ic);
    const i = new InstancedInterleavedBuffer(s, 2, 1);
    return t.setAttribute("instanceDistanceStart", new InterleavedBufferAttribute(i, 1, 0)), t.setAttribute("instanceDistanceEnd", new InterleavedBufferAttribute(i, 1, 1)), this;
  }
  raycast(t, e) {
    const n = this.material.worldUnits, s = t.camera;
    s === null && !n && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const i = t.params.Line2 !== void 0 && t.params.Line2.threshold || 0;
    Xt = t.ray;
    const r = this.matrixWorld, o = this.geometry, l = this.material;
    Bn = l.linewidth + i, o.boundingSphere === null && o.computeBoundingSphere(), dr.copy(o.boundingSphere).applyMatrix4(r);
    let h;
    if (n)
      h = Bn * 0.5;
    else {
      const m = Math.max(s.near, dr.distanceToPoint(Xt.origin));
      h = oc(s, m, l.resolution);
    }
    if (dr.radius += h, Xt.intersectsSphere(dr) === false)
      return;
    o.boundingBox === null && o.computeBoundingBox(), ur.copy(o.boundingBox).applyMatrix4(r);
    let d;
    if (n)
      d = Bn * 0.5;
    else {
      const m = Math.max(s.near, ur.distanceToPoint(Xt.origin));
      d = oc(s, m, l.resolution);
    }
    ur.expandByScalar(d), Xt.intersectsBox(ur) !== false && (n ? Df(this, e) : Lf(this, s, e));
  }
};
var Rr = class extends vh {
  constructor() {
    super(), this.isLineGeometry = true, this.type = "LineGeometry";
  }
  setPositions(t) {
    const e = t.length - 3, n = new Float32Array(2 * e);
    for (let s = 0; s < e; s += 3)
      n[2 * s] = t[s], n[2 * s + 1] = t[s + 1], n[2 * s + 2] = t[s + 2], n[2 * s + 3] = t[s + 3], n[2 * s + 4] = t[s + 4], n[2 * s + 5] = t[s + 5];
    return super.setPositions(n), this;
  }
  setColors(t) {
    const e = t.length - 3, n = new Float32Array(2 * e);
    for (let s = 0; s < e; s += 3)
      n[2 * s] = t[s], n[2 * s + 1] = t[s + 1], n[2 * s + 2] = t[s + 2], n[2 * s + 3] = t[s + 3], n[2 * s + 4] = t[s + 4], n[2 * s + 5] = t[s + 5];
    return super.setColors(n), this;
  }
  fromLine(t) {
    const e = t.geometry;
    return this.setPositions(e.attributes.position.array), this;
  }
};
var Ih = class extends Nf {
  constructor(t = new Rr(), e = new di({ color: Math.random() * 16777215 })) {
    super(t, e), this.isLine2 = true, this.type = "Line2";
  }
};
var Pr = class Pr2 {
  constructor(t, e) {
    T(this, "scene");
    T(this, "onSelect", new $());
    T(this, "type");
    T(this, "selectCurve");
    T(this, "selectPoints");
    T(this, "hoverCurve");
    T(this, "hoverPoints");
    T(this, "caster", new Raycaster());
    this.scene = t, this.type = e, this.hoverCurve = this.newCurve(3e-3, 4473924, false), this.hoverPoints = this.newPoints(5, 4473924), this.selectCurve = this.newCurve(5e-3, 16777215, true), this.selectPoints = this.newPoints(7, 16777215);
  }
  dispose() {
    this.selectCurve && this.scene.remove(this.selectCurve), this.selectCurve.material.dispose(), this.selectCurve.geometry.dispose(), this.selectCurve = null, this.hoverCurve.material.dispose(), this.hoverCurve.geometry.dispose(), this.hoverCurve = null, this.hoverPoints.material.dispose(), this.hoverPoints.geometry.dispose(), this.selectPoints.material.dispose(), this.selectPoints.geometry.dispose(), this.scene = null;
  }
  castRay(t, e, n, s) {
    const i = new Vector2(), r = n.getBoundingClientRect();
    i.x = (t.clientX - r.left) / r.width * 2 - 1, i.y = -((t.clientY - r.top) / r.height) * 2 + 1, this.caster.setFromCamera(i, e);
    const o = this.caster.intersectObjects(s);
    return o.length ? o[0] : null;
  }
  select(t) {
    this.highlight(t, this.selectCurve, this.selectPoints, true), this.onSelect.trigger(t);
  }
  unSelect() {
    this.selectCurve.removeFromParent(), this.selectPoints.removeFromParent();
  }
  hover(t) {
    this.highlight(t, this.hoverCurve, this.hoverPoints, false);
  }
  unHover() {
    this.hoverCurve.removeFromParent(), this.hoverPoints.removeFromParent();
  }
  setResolution({ x: t, y: e }) {
    this.selectCurve.material.resolution.set(t / e, 1), this.hoverCurve.material.resolution.set(t / e, 1);
  }
  highlight(t, e, n, s) {
    const { alignment: i } = t.curve;
    this.scene.add(e), this.scene.add(n);
    const r = [], o = [], l = [];
    for (const f of i[this.type]) {
      const g = f.mesh.geometry.attributes.position;
      for (const A of g.array)
        r.push(A);
      if (s) {
        let A;
        if (this.type === "absolute") {
          const { horizontal: P } = f.alignment;
          A = P[f.index].data.TYPE;
        } else
          A = f.data.TYPE;
        const F = Pr2.settings.colors[A] || [1, 1, 1];
        for (let P = 0; P < g.count; P++)
          o.push(...F);
      }
      const [I, y, x] = g.array;
      l.push(new Vector3(I, y, x));
    }
    const h = r[r.length - 3], d = r[r.length - 2], m = r[r.length - 1];
    l.push(new Vector3(h, d, m)), r.length / 3 > e.geometry.attributes.position.count && (e.geometry.dispose(), e.geometry = new Rr()), e.geometry.setPositions(r), s && e.geometry.setColors(o), n.geometry.setFromPoints(l);
  }
  newCurve(t, e, n) {
    const s = new Rr(), i = new di({
      color: e,
      linewidth: t,
      vertexColors: n,
      worldUnits: false,
      depthTest: false
    }), r = new Ih(s, i);
    return this.scene.add(r), r;
  }
  newPoints(t, e) {
    const n = new BufferGeometry(), s = new BufferAttribute(new Float32Array(), 3);
    n.setAttribute("position", s);
    const i = new PointsMaterial({
      size: t,
      color: e,
      sizeAttenuation: false,
      depthTest: false
    }), r = new Points(n, i);
    return r.frustumCulled = false, this.scene.add(r), r;
  }
};
T(Pr, "settings", {
  colors: {
    LINE: [213 / 255, 0 / 255, 255 / 255],
    CIRCULARARC: [0 / 255, 46, 255 / 255],
    CLOTHOID: [0 / 255, 255 / 255, 0 / 255],
    PARABOLICARC: [0 / 255, 255 / 255, 72 / 255],
    CONSTANTGRADIENT: [213 / 255, 0 / 255, 255 / 255]
  }
});
var Fr = Pr;
var _f = class extends Object3D {
  constructor(t = document.createElement("div")) {
    super(), this.isCSS2DObject = true, this.element = t, this.element.style.position = "absolute", this.element.style.userSelect = "none", this.element.setAttribute("draggable", false), this.center = new Vector2(0.5, 0.5), this.addEventListener("removed", function() {
      this.traverse(function(e) {
        e.element instanceof Element && e.element.parentNode !== null && e.element.parentNode.removeChild(e.element);
      });
    });
  }
  copy(t, e) {
    return super.copy(t, e), this.element = t.element.cloneNode(true), this.center = t.center, this;
  }
};
var cs = new Vector3();
var ac = new Matrix4();
var lc = new Matrix4();
var cc = new Vector3();
var hc = new Vector3();
var Uf = class {
  constructor(t = {}) {
    const e = this;
    let n, s, i, r;
    const o = {
      objects: /* @__PURE__ */ new WeakMap()
    }, l = t.element !== void 0 ? t.element : document.createElement("div");
    l.style.overflow = "hidden", this.domElement = l, this.getSize = function() {
      return {
        width: n,
        height: s
      };
    }, this.render = function(g, I) {
      g.matrixWorldAutoUpdate === true && g.updateMatrixWorld(), I.parent === null && I.matrixWorldAutoUpdate === true && I.updateMatrixWorld(), ac.copy(I.matrixWorldInverse), lc.multiplyMatrices(I.projectionMatrix, ac), h(g, g, I), f(g);
    }, this.setSize = function(g, I) {
      n = g, s = I, i = n / 2, r = s / 2, l.style.width = g + "px", l.style.height = I + "px";
    };
    function h(g, I, y) {
      if (g.isCSS2DObject) {
        cs.setFromMatrixPosition(g.matrixWorld), cs.applyMatrix4(lc);
        const x = g.visible === true && cs.z >= -1 && cs.z <= 1 && g.layers.test(y.layers) === true;
        if (g.element.style.display = x === true ? "" : "none", x === true) {
          g.onBeforeRender(e, I, y);
          const F = g.element;
          F.style.transform = "translate(" + -100 * g.center.x + "%," + -100 * g.center.y + "%)translate(" + (cs.x * i + i) + "px," + (-cs.y * r + r) + "px)", F.parentNode !== l && l.appendChild(F), g.onAfterRender(e, I, y);
        }
        const A = {
          distanceToCameraSquared: d(y, g)
        };
        o.objects.set(g, A);
      }
      for (let x = 0, A = g.children.length; x < A; x++)
        h(g.children[x], I, y);
    }
    function d(g, I) {
      return cc.setFromMatrixPosition(g.matrixWorld), hc.setFromMatrixPosition(I.matrixWorld), cc.distanceToSquared(hc);
    }
    function m(g) {
      const I = [];
      return g.traverse(function(y) {
        y.isCSS2DObject && I.push(y);
      }), I;
    }
    function f(g) {
      const I = m(g).sort(function(x, A) {
        if (x.renderOrder !== A.renderOrder)
          return A.renderOrder - x.renderOrder;
        const F = o.objects.get(x).distanceToCameraSquared, P = o.objects.get(A).distanceToCameraSquared;
        return F - P;
      }), y = I.length;
      for (let x = 0, A = I.length; x < A; x++)
        I[x].element.style.zIndex = y - x;
    }
  }
};
var ft = class {
  // Define marker as setup configuration?
  constructor(t, e, n) {
    T(this, "three");
    T(this, "world");
    T(this, "onDisposed", new $());
    this.world = t;
    let s;
    e ? s = e : (s = document.createElement("div"), s.style.width = "15px", s.style.height = "15px", s.style.border = "5px solid red"), this.three = new _f(s), (n || t.scene.three).add(this.three), this.visible = true;
  }
  set visible(t) {
    this.three.visible = t;
  }
  get visible() {
    return this.three.visible;
  }
  toggleVisibility() {
    this.visible = !this.visible;
  }
  dispose() {
    this.three.removeFromParent(), this.three.element.remove(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
var Bf = class extends qd {
  constructor(e, n, s) {
    super(e, n, s);
    T(this, "three2D", new Uf());
    this.onAfterUpdate.add(() => {
      if (this.onBeforeUpdate.trigger(this), !this.enabled || !this.currentWorld)
        return;
      const i = this.currentWorld.scene.three, r = this.currentWorld.camera.three;
      i instanceof Scene && this.three2D.render(i, r);
    }), this.onDisposed.add(() => {
      this.three2D.domElement.remove();
    }), this.onResize.add(({ x: i, y: r }) => {
      this.three2D.setSize(i, r);
    }), this.setupHtmlRenderer(), this.resize();
  }
  setupHtmlRenderer() {
    this.three2D.domElement.style.position = "absolute", this.three2D.domElement.style.top = "0px", this.three2D.domElement.style.pointerEvents = "none", this.container && this.container.appendChild(this.three2D.domElement);
  }
};
var Mr = class Mr2 extends Re {
  constructor(e) {
    super(e);
    T(this, "onDisposed", new $());
    T(this, "enabled", true);
    T(this, "threshold", 50);
    T(this, "autoCluster", true);
    T(this, "list", /* @__PURE__ */ new Map());
    T(this, "_worldEvents", /* @__PURE__ */ new Map());
    T(this, "clusterLabels", /* @__PURE__ */ new Set());
    T(this, "currentKeys", /* @__PURE__ */ new Set());
    T(this, "_color", "white");
    T(this, "_markerKey", 0);
    T(this, "_clusterKey", 0);
    T(this, "_setupWorlds", /* @__PURE__ */ new Set());
    e.add(Mr2.uuid, this);
  }
  get color() {
    return this._color;
  }
  set color(e) {
    this._color = e;
    for (const [n, s] of this.list)
      for (const [i, r] of s)
        r.label.three.element.style.color = e;
  }
  create(e, n, s, i = false) {
    this.setupEvents(e, true);
    const r = this._markerKey.toString(), o = this.getWorldMarkerList(e);
    if (o.has(r))
      return;
    const l = document.createElement("span");
    l.innerHTML = n, l.style.color = this._color;
    const h = new ft(e, l);
    return h.three.position.copy(s), o.set(r, {
      key: r,
      label: h,
      merged: false,
      static: i
    }), this._markerKey++, r;
  }
  delete(e) {
    for (const [n, s] of this.list) {
      const i = s.get(e);
      i && i.label.dispose(), s.delete(e);
    }
  }
  getWorldMarkerList(e) {
    return this.list.has(e.uuid) || this.list.set(e.uuid, /* @__PURE__ */ new Map()), this.list.get(e.uuid);
  }
  dispose(e) {
    for (const [n, s] of this.list) {
      const i = [...s.keys()];
      for (const r of i) {
        const o = s.get(r);
        e && o.type !== e || (o.label.dispose(), s.delete(r));
      }
    }
    if (!e) {
      this.list.clear(), this._markerKey = 0;
      for (const n of this.clusterLabels)
        n.label.dispose();
      this.clusterLabels.clear(), this._clusterKey = 0, this.currentKeys.clear();
    }
    this.onDisposed.trigger();
  }
  setupEvents(e, n) {
    if (n && this._setupWorlds.has(e.uuid) || !e.camera.hasCameraControls())
      return;
    const s = this.getWorldEvent(e);
    e.camera.controls.removeEventListener("sleep", s), e.camera.controls.removeEventListener("rest", s), n && (e.camera.controls.addEventListener("sleep", s), e.camera.controls.addEventListener("rest", s));
  }
  getWorldEvent(e) {
    if (!this._worldEvents.has(e.uuid)) {
      const n = () => {
        this.cluster(e);
      };
      this._worldEvents.set(e.uuid, n);
    }
    return this._worldEvents.get(e.uuid);
  }
  resetMarkers() {
    for (const [e, n] of this.list)
      for (const [s, i] of n)
        i.merged = false;
    for (const e of this.clusterLabels)
      e.label.dispose();
    this.clusterLabels.clear(), this._clusterKey = 0;
  }
  removeMergeMarkers(e) {
    const n = this.list.get(e.uuid);
    if (n) {
      for (const [s, i] of n)
        i.merged ? i.label.dispose() : i.label.world.scene.three.add(i.label.three);
      for (const s of this.clusterLabels)
        if (s.markerKeys.length === 1) {
          for (const [i, r] of this.list) {
            const o = r.get(s.markerKeys[0]);
            if (!o)
              continue;
            o.label.world.scene.three.add(o.label.three), o.merged = false;
          }
          s.label.dispose(), this.clusterLabels.delete(s);
        }
    }
  }
  cluster(e) {
    if (!this.autoCluster)
      return;
    this.resetMarkers();
    const n = this.list.get(e.uuid);
    if (n) {
      for (const [s, i] of n)
        if (!i.merged && !i.static) {
          this.currentKeys.clear();
          for (const [r, o] of n)
            o.static || i.key !== o.key && !o.merged && this.distance(i.label, o.label) < this.threshold && (this.currentKeys.add(o.key), o.merged = true);
          if (this.currentKeys.size > 0) {
            this.currentKeys.add(i.key), i.merged = true;
            const r = Array.from(this.currentKeys), o = this.getAveragePositionFromLabels(r), l = new ft(
              i.label.world,
              this.createClusterElement(this._clusterKey.toString())
            ), { element: h } = l.three;
            h.textContent = r.length.toString(), l.three.position.copy(o), this.clusterLabels.add({
              key: this._clusterKey.toString(),
              markerKeys: r,
              label: l
            }), this._clusterKey++;
          }
        }
      this.removeMergeMarkers(e);
    }
  }
  getAveragePositionFromLabels(e) {
    const n = e.map((s) => {
      for (const [i, r] of this.list) {
        const o = r.get(s);
        if (o)
          return o.label.three.position;
      }
      return new Vector3();
    });
    return n.reduce((s, i) => s.add(i), new Vector3()).divideScalar(n.length);
  }
  createClusterElement(e) {
    const n = document.createElement("div");
    return n.textContent = e, n.style.color = "#000000", n.style.background = "#FFFFFF", n.style.fontSize = "1.2rem", n.style.fontWeight = "500", n.style.pointerEvents = "auto", n.style.borderRadius = "50%", n.style.padding = "5px 11px", n.style.textAlign = "center", n.style.cursor = "pointer", n.addEventListener("pointerdown", () => {
      this.navigateToCluster(e);
    }), n.addEventListener("pointerover", () => {
      n.style.background = "#BCF124";
    }), n.addEventListener("pointerout", () => {
      n.style.background = "#FFFFFF";
    }), n;
  }
  getScreenPosition(e) {
    const n = new Vector3();
    if (!e.world.renderer)
      throw new Error("Renderer not found!");
    const s = e.three.position.clone();
    s.project(e.world.camera.three);
    const i = e.world.renderer.getSize();
    return n.x = s.x * i.x / 2 + i.x / 2, n.y = -(s.y * i.y / 2) + i.y / 2, n;
  }
  distance(e, n) {
    const s = this.getScreenPosition(e), i = this.getScreenPosition(n), r = s.x - i.x, o = s.y - i.y, l = Math.sqrt(r * r + o * o) * 0.5;
    return l === 0 ? this.threshold + 1 : l;
  }
  navigateToCluster(e) {
    const n = [], s = Array.from(this.clusterLabels).find(
      (m) => m.key === e
    );
    if (!s)
      return;
    const i = s.label.world.camera;
    if (!i.hasCameraControls()) {
      console.warn("Zoom to clusters only supported with Camera Controls!");
      return;
    }
    for (const m of s.markerKeys)
      for (const [f, g] of this.list) {
        const I = g.get(m);
        if (I) {
          const { x: y, y: x, z: A } = I.label.three.position;
          n.push(y, x, A);
        }
      }
    s.label.dispose(), this.clusterLabels.delete(s);
    const r = new BufferGeometry(), o = new Float32Array(n), l = new BufferAttribute(o, 3);
    r.setAttribute("position", l);
    const h = new Mesh(r);
    h.geometry.computeBoundingSphere(), h.geometry.boundingSphere && i.controls.fitToSphere(h, true), r.dispose(), h.clear(), n.length = 0;
  }
};
T(Mr, "uuid", "4079eb91-79b0-4ede-bcf2-15b837129236");
var nn = Mr;
var uc = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function yh(u) {
  return u && u.__esModule && Object.prototype.hasOwnProperty.call(u, "default") ? u.default : u;
}
var Ua = { exports: {} };
Ua.exports = Zr;
Ua.exports.default = Zr;
function Zr(u, t, e) {
  e = e || 2;
  var n = t && t.length, s = n ? t[0] * e : u.length, i = wh(u, 0, s, e, true), r = [];
  if (!i || i.next === i.prev)
    return r;
  var o, l, h, d, m, f, g;
  if (n && (i = Yf(u, t, i, e)), u.length > 80 * e) {
    o = h = u[0], l = d = u[1];
    for (var I = e; I < s; I += e)
      m = u[I], f = u[I + 1], m < o && (o = m), f < l && (l = f), m > h && (h = m), f > d && (d = f);
    g = Math.max(h - o, d - l), g = g !== 0 ? 32767 / g : 0;
  }
  return ai(i, r, e, o, l, g, 0), r;
}
function wh(u, t, e, n, s) {
  var i, r;
  if (s === ba(u, t, e, n) > 0)
    for (i = t; i < e; i += n)
      r = dc(i, u[i], u[i + 1], r);
  else
    for (i = e - n; i >= t; i -= n)
      r = dc(i, u[i], u[i + 1], r);
  return r && Qr(r, r.next) && (ci(r), r = r.next), r;
}
function zn(u, t) {
  if (!u)
    return u;
  t || (t = u);
  var e = u, n;
  do
    if (n = false, !e.steiner && (Qr(e, e.next) || He(e.prev, e, e.next) === 0)) {
      if (ci(e), e = t = e.prev, e === e.next)
        break;
      n = true;
    } else
      e = e.next;
  while (n || e !== t);
  return t;
}
function ai(u, t, e, n, s, i, r) {
  if (u) {
    !r && i && Xf(u, n, s, i);
    for (var o = u, l, h; u.prev !== u.next; ) {
      if (l = u.prev, h = u.next, i ? zf(u, n, s, i) : kf(u)) {
        t.push(l.i / e | 0), t.push(u.i / e | 0), t.push(h.i / e | 0), ci(u), u = h.next, o = h.next;
        continue;
      }
      if (u = h, u === o) {
        r ? r === 1 ? (u = Vf(zn(u), t, e), ai(u, t, e, n, s, i, 2)) : r === 2 && Gf(u, t, e, n, s, i) : ai(zn(u), t, e, n, s, i, 1);
        break;
      }
    }
  }
}
function kf(u) {
  var t = u.prev, e = u, n = u.next;
  if (He(t, e, n) >= 0)
    return false;
  for (var s = t.x, i = e.x, r = n.x, o = t.y, l = e.y, h = n.y, d = s < i ? s < r ? s : r : i < r ? i : r, m = o < l ? o < h ? o : h : l < h ? l : h, f = s > i ? s > r ? s : r : i > r ? i : r, g = o > l ? o > h ? o : h : l > h ? l : h, I = n.next; I !== t; ) {
    if (I.x >= d && I.x <= f && I.y >= m && I.y <= g && ps(s, o, i, l, r, h, I.x, I.y) && He(I.prev, I, I.next) >= 0)
      return false;
    I = I.next;
  }
  return true;
}
function zf(u, t, e, n) {
  var s = u.prev, i = u, r = u.next;
  if (He(s, i, r) >= 0)
    return false;
  for (var o = s.x, l = i.x, h = r.x, d = s.y, m = i.y, f = r.y, g = o < l ? o < h ? o : h : l < h ? l : h, I = d < m ? d < f ? d : f : m < f ? m : f, y = o > l ? o > h ? o : h : l > h ? l : h, x = d > m ? d > f ? d : f : m > f ? m : f, A = Ca(g, I, t, e, n), F = Ca(y, x, t, e, n), P = u.prevZ, b = u.nextZ; P && P.z >= A && b && b.z <= F; ) {
    if (P.x >= g && P.x <= y && P.y >= I && P.y <= x && P !== s && P !== r && ps(o, d, l, m, h, f, P.x, P.y) && He(P.prev, P, P.next) >= 0 || (P = P.prevZ, b.x >= g && b.x <= y && b.y >= I && b.y <= x && b !== s && b !== r && ps(o, d, l, m, h, f, b.x, b.y) && He(b.prev, b, b.next) >= 0))
      return false;
    b = b.nextZ;
  }
  for (; P && P.z >= A; ) {
    if (P.x >= g && P.x <= y && P.y >= I && P.y <= x && P !== s && P !== r && ps(o, d, l, m, h, f, P.x, P.y) && He(P.prev, P, P.next) >= 0)
      return false;
    P = P.prevZ;
  }
  for (; b && b.z <= F; ) {
    if (b.x >= g && b.x <= y && b.y >= I && b.y <= x && b !== s && b !== r && ps(o, d, l, m, h, f, b.x, b.y) && He(b.prev, b, b.next) >= 0)
      return false;
    b = b.nextZ;
  }
  return true;
}
function Vf(u, t, e) {
  var n = u;
  do {
    var s = n.prev, i = n.next.next;
    !Qr(s, i) && Ch(s, n, n.next, i) && li(s, i) && li(i, s) && (t.push(s.i / e | 0), t.push(n.i / e | 0), t.push(i.i / e | 0), ci(n), ci(n.next), n = u = i), n = n.next;
  } while (n !== u);
  return zn(n);
}
function Gf(u, t, e, n, s, i) {
  var r = u;
  do {
    for (var o = r.next.next; o !== r.prev; ) {
      if (r.i !== o.i && qf(r, o)) {
        var l = Th(r, o);
        r = zn(r, r.next), l = zn(l, l.next), ai(r, t, e, n, s, i, 0), ai(l, t, e, n, s, i, 0);
        return;
      }
      o = o.next;
    }
    r = r.next;
  } while (r !== u);
}
function Yf(u, t, e, n) {
  var s = [], i, r, o, l, h;
  for (i = 0, r = t.length; i < r; i++)
    o = t[i] * n, l = i < r - 1 ? t[i + 1] * n : u.length, h = wh(u, o, l, n, false), h === h.next && (h.steiner = true), s.push(Qf(h));
  for (s.sort(Hf), i = 0; i < s.length; i++)
    e = Wf(s[i], e);
  return e;
}
function Hf(u, t) {
  return u.x - t.x;
}
function Wf(u, t) {
  var e = Kf(u, t);
  if (!e)
    return t;
  var n = Th(e, u);
  return zn(n, n.next), zn(e, e.next);
}
function Kf(u, t) {
  var e = t, n = u.x, s = u.y, i = -1 / 0, r;
  do {
    if (s <= e.y && s >= e.next.y && e.next.y !== e.y) {
      var o = e.x + (s - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (o <= n && o > i && (i = o, r = e.x < e.next.x ? e : e.next, o === n))
        return r;
    }
    e = e.next;
  } while (e !== t);
  if (!r)
    return null;
  var l = r, h = r.x, d = r.y, m = 1 / 0, f;
  e = r;
  do
    n >= e.x && e.x >= h && n !== e.x && ps(s < d ? n : i, s, h, d, s < d ? i : n, s, e.x, e.y) && (f = Math.abs(s - e.y) / (n - e.x), li(e, u) && (f < m || f === m && (e.x > r.x || e.x === r.x && jf(r, e))) && (r = e, m = f)), e = e.next;
  while (e !== l);
  return r;
}
function jf(u, t) {
  return He(u.prev, u, t.prev) < 0 && He(t.next, u, u.next) < 0;
}
function Xf(u, t, e, n) {
  var s = u;
  do
    s.z === 0 && (s.z = Ca(s.x, s.y, t, e, n)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next;
  while (s !== u);
  s.prevZ.nextZ = null, s.prevZ = null, Zf(s);
}
function Zf(u) {
  var t, e, n, s, i, r, o, l, h = 1;
  do {
    for (e = u, u = null, i = null, r = 0; e; ) {
      for (r++, n = e, o = 0, t = 0; t < h && (o++, n = n.nextZ, !!n); t++)
        ;
      for (l = h; o > 0 || l > 0 && n; )
        o !== 0 && (l === 0 || !n || e.z <= n.z) ? (s = e, e = e.nextZ, o--) : (s = n, n = n.nextZ, l--), i ? i.nextZ = s : u = s, s.prevZ = i, i = s;
      e = n;
    }
    i.nextZ = null, h *= 2;
  } while (r > 1);
  return u;
}
function Ca(u, t, e, n, s) {
  return u = (u - e) * s | 0, t = (t - n) * s | 0, u = (u | u << 8) & 16711935, u = (u | u << 4) & 252645135, u = (u | u << 2) & 858993459, u = (u | u << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, u | t << 1;
}
function Qf(u) {
  var t = u, e = u;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== u);
  return e;
}
function ps(u, t, e, n, s, i, r, o) {
  return (s - r) * (t - o) >= (u - r) * (i - o) && (u - r) * (n - o) >= (e - r) * (t - o) && (e - r) * (i - o) >= (s - r) * (n - o);
}
function qf(u, t) {
  return u.next.i !== t.i && u.prev.i !== t.i && !Jf(u, t) && // dones't intersect other edges
  (li(u, t) && li(t, u) && $f(u, t) && // locally visible
  (He(u.prev, u, t.prev) || He(u, t.prev, t)) || // does not create opposite-facing sectors
  Qr(u, t) && He(u.prev, u, u.next) > 0 && He(t.prev, t, t.next) > 0);
}
function He(u, t, e) {
  return (t.y - u.y) * (e.x - t.x) - (t.x - u.x) * (e.y - t.y);
}
function Qr(u, t) {
  return u.x === t.x && u.y === t.y;
}
function Ch(u, t, e, n) {
  var s = pr(He(u, t, e)), i = pr(He(u, t, n)), r = pr(He(e, n, u)), o = pr(He(e, n, t));
  return !!(s !== i && r !== o || s === 0 && fr(u, e, t) || i === 0 && fr(u, n, t) || r === 0 && fr(e, u, n) || o === 0 && fr(e, t, n));
}
function fr(u, t, e) {
  return t.x <= Math.max(u.x, e.x) && t.x >= Math.min(u.x, e.x) && t.y <= Math.max(u.y, e.y) && t.y >= Math.min(u.y, e.y);
}
function pr(u) {
  return u > 0 ? 1 : u < 0 ? -1 : 0;
}
function Jf(u, t) {
  var e = u;
  do {
    if (e.i !== u.i && e.next.i !== u.i && e.i !== t.i && e.next.i !== t.i && Ch(e, e.next, u, t))
      return true;
    e = e.next;
  } while (e !== u);
  return false;
}
function li(u, t) {
  return He(u.prev, u, u.next) < 0 ? He(u, t, u.next) >= 0 && He(u, u.prev, t) >= 0 : He(u, t, u.prev) < 0 || He(u, u.next, t) < 0;
}
function $f(u, t) {
  var e = u, n = false, s = (u.x + t.x) / 2, i = (u.y + t.y) / 2;
  do
    e.y > i != e.next.y > i && e.next.y !== e.y && s < (e.next.x - e.x) * (i - e.y) / (e.next.y - e.y) + e.x && (n = !n), e = e.next;
  while (e !== u);
  return n;
}
function Th(u, t) {
  var e = new Ta(u.i, u.x, u.y), n = new Ta(t.i, t.x, t.y), s = u.next, i = t.prev;
  return u.next = t, t.prev = u, e.next = s, s.prev = e, n.next = e, e.prev = n, i.next = n, n.prev = i, n;
}
function dc(u, t, e, n) {
  var s = new Ta(u, t, e);
  return n ? (s.next = n.next, s.prev = n, n.next.prev = s, n.next = s) : (s.prev = s, s.next = s), s;
}
function ci(u) {
  u.next.prev = u.prev, u.prev.next = u.next, u.prevZ && (u.prevZ.nextZ = u.nextZ), u.nextZ && (u.nextZ.prevZ = u.prevZ);
}
function Ta(u, t, e) {
  this.i = u, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
}
Zr.deviation = function(u, t, e, n) {
  var s = t && t.length, i = s ? t[0] * e : u.length, r = Math.abs(ba(u, 0, i, e));
  if (s)
    for (var o = 0, l = t.length; o < l; o++) {
      var h = t[o] * e, d = o < l - 1 ? t[o + 1] * e : u.length;
      r -= Math.abs(ba(u, h, d, e));
    }
  var m = 0;
  for (o = 0; o < n.length; o += 3) {
    var f = n[o] * e, g = n[o + 1] * e, I = n[o + 2] * e;
    m += Math.abs(
      (u[f] - u[I]) * (u[g + 1] - u[f + 1]) - (u[f] - u[g]) * (u[I + 1] - u[f + 1])
    );
  }
  return r === 0 && m === 0 ? 0 : Math.abs((m - r) / r);
};
function ba(u, t, e, n) {
  for (var s = 0, i = t, r = e - n; i < e; i += n)
    s += (u[r] - u[i]) * (u[i + 1] + u[r + 1]), r = i;
  return s;
}
Zr.flatten = function(u) {
  for (var t = u[0][0].length, e = { vertices: [], holes: [], dimensions: t }, n = 0, s = 0; s < u.length; s++) {
    for (var i = 0; i < u[s].length; i++)
      for (var r = 0; r < t; r++)
        e.vertices.push(u[s][i][r]);
    s > 0 && (n += u[s - 1].length, e.holes.push(n));
  }
  return e;
};
var ep = Ua.exports;
var tp = yh(ep);
var np = {
  name: "CopyShader",
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
  )
};
var Is = class {
  constructor() {
    this.isPass = true, this.enabled = true, this.needsSwap = true, this.clear = false, this.renderToScreen = false;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
};
var sp = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var ip = class extends BufferGeometry {
  constructor() {
    super(), this.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
  }
};
var rp = new ip();
var bh = class {
  constructor(t) {
    this._mesh = new Mesh(rp, t);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(t) {
    t.render(this._mesh, sp);
  }
  get material() {
    return this._mesh.material;
  }
  set material(t) {
    this._mesh.material = t;
  }
};
var xh = class extends Is {
  constructor(t, e) {
    super(), this.textureID = e !== void 0 ? e : "tDiffuse", t instanceof ShaderMaterial ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = UniformsUtils.clone(t.uniforms), this.material = new ShaderMaterial({
      name: t.name !== void 0 ? t.name : "unspecified",
      defines: Object.assign({}, t.defines),
      uniforms: this.uniforms,
      vertexShader: t.vertexShader,
      fragmentShader: t.fragmentShader
    })), this.fsQuad = new bh(this.material);
  }
  render(t, e, n) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
};
var fc = class extends Is {
  constructor(t, e) {
    super(), this.scene = t, this.camera = e, this.clear = true, this.needsSwap = false, this.inverse = false;
  }
  render(t, e, n) {
    const s = t.getContext(), i = t.state;
    i.buffers.color.setMask(false), i.buffers.depth.setMask(false), i.buffers.color.setLocked(true), i.buffers.depth.setLocked(true);
    let r, o;
    this.inverse ? (r = 0, o = 1) : (r = 1, o = 0), i.buffers.stencil.setTest(true), i.buffers.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), i.buffers.stencil.setFunc(s.ALWAYS, r, 4294967295), i.buffers.stencil.setClear(o), i.buffers.stencil.setLocked(true), t.setRenderTarget(n), this.clear && t.clear(), t.render(this.scene, this.camera), t.setRenderTarget(e), this.clear && t.clear(), t.render(this.scene, this.camera), i.buffers.color.setLocked(false), i.buffers.depth.setLocked(false), i.buffers.color.setMask(true), i.buffers.depth.setMask(true), i.buffers.stencil.setLocked(false), i.buffers.stencil.setFunc(s.EQUAL, 1, 4294967295), i.buffers.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), i.buffers.stencil.setLocked(true);
  }
};
var op = class extends Is {
  constructor() {
    super(), this.needsSwap = false;
  }
  render(t) {
    t.state.buffers.stencil.setLocked(false), t.state.buffers.stencil.setTest(false);
  }
};
var ap = class {
  constructor(t, e) {
    if (this.renderer = t, this._pixelRatio = t.getPixelRatio(), e === void 0) {
      const n = t.getSize(new Vector2());
      this._width = n.width, this._height = n.height, e = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType }), e.texture.name = "EffectComposer.rt1";
    } else
      this._width = e.width, this._height = e.height;
    this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = true, this.passes = [], this.copyPass = new xh(np), this.copyPass.material.blending = NoBlending, this.clock = new Clock();
  }
  swapBuffers() {
    const t = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = t;
  }
  addPass(t) {
    this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(t, e) {
    this.passes.splice(e, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(t) {
    const e = this.passes.indexOf(t);
    e !== -1 && this.passes.splice(e, 1);
  }
  isLastEnabledPass(t) {
    for (let e = t + 1; e < this.passes.length; e++)
      if (this.passes[e].enabled)
        return false;
    return true;
  }
  render(t) {
    t === void 0 && (t = this.clock.getDelta());
    const e = this.renderer.getRenderTarget();
    let n = false;
    for (let s = 0, i = this.passes.length; s < i; s++) {
      const r = this.passes[s];
      if (r.enabled !== false) {
        if (r.renderToScreen = this.renderToScreen && this.isLastEnabledPass(s), r.render(this.renderer, this.writeBuffer, this.readBuffer, t, n), r.needsSwap) {
          if (n) {
            const o = this.renderer.getContext(), l = this.renderer.state.buffers.stencil;
            l.setFunc(o.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), l.setFunc(o.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        fc !== void 0 && (r instanceof fc ? n = true : r instanceof op && (n = false));
      }
    }
    this.renderer.setRenderTarget(e);
  }
  reset(t) {
    if (t === void 0) {
      const e = this.renderer.getSize(new Vector2());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = e.width, this._height = e.height, t = this.renderTarget1.clone(), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  setSize(t, e) {
    this._width = t, this._height = e;
    const n = this._width * this._pixelRatio, s = this._height * this._pixelRatio;
    this.renderTarget1.setSize(n, s), this.renderTarget2.setSize(n, s);
    for (let i = 0; i < this.passes.length; i++)
      this.passes[i].setSize(n, s);
  }
  setPixelRatio(t) {
    this._pixelRatio = t, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
};
var lp = class extends Is {
  constructor(t, e, n = null, s = null, i = null) {
    super(), this.scene = t, this.camera = e, this.overrideMaterial = n, this.clearColor = s, this.clearAlpha = i, this.clear = true, this.clearDepth = false, this.needsSwap = false, this._oldClearColor = new Color();
  }
  render(t, e, n) {
    const s = t.autoClear;
    t.autoClear = false;
    let i, r;
    this.overrideMaterial !== null && (r = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (t.getClearColor(this._oldClearColor), t.setClearColor(this.clearColor)), this.clearAlpha !== null && (i = t.getClearAlpha(), t.setClearAlpha(this.clearAlpha)), this.clearDepth == true && t.clearDepth(), t.setRenderTarget(this.renderToScreen ? null : n), this.clear === true && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), t.render(this.scene, this.camera), this.clearColor !== null && t.setClearColor(this._oldClearColor), this.clearAlpha !== null && t.setClearAlpha(i), this.overrideMaterial !== null && (this.scene.overrideMaterial = r), t.autoClear = s;
  }
};
var fi = new BufferGeometry();
fi.setAttribute("position", new BufferAttribute(new Float32Array([
  -1,
  -1,
  3,
  -1,
  -1,
  3
]), 2));
fi.setAttribute("uv", new BufferAttribute(new Float32Array([
  0,
  0,
  2,
  0,
  0,
  2
]), 2));
fi.boundingSphere = new Sphere();
fi.computeBoundingSphere = function() {
};
var cp = new OrthographicCamera();
var mr = class {
  constructor(t) {
    this._mesh = new Mesh(fi, t), this._mesh.frustumCulled = false;
  }
  render(t) {
    t.render(this._mesh, cp);
  }
  get material() {
    return this._mesh.material;
  }
  set material(t) {
    this._mesh.material = t;
  }
  dispose() {
    this._mesh.material.dispose(), this._mesh.geometry.dispose();
  }
};
var hp = {
  uniforms: {
    sceneDiffuse: {
      value: null
    },
    sceneDepth: {
      value: null
    },
    sceneNormal: {
      value: null
    },
    projMat: {
      value: new Matrix4()
    },
    viewMat: {
      value: new Matrix4()
    },
    projViewMat: {
      value: new Matrix4()
    },
    projectionMatrixInv: {
      value: new Matrix4()
    },
    viewMatrixInv: {
      value: new Matrix4()
    },
    cameraPos: {
      value: new Vector3()
    },
    resolution: {
      value: new Vector2()
    },
    time: {
      value: 0
    },
    samples: {
      value: []
    },
    samplesR: {
      value: []
    },
    bluenoise: {
      value: null
    },
    distanceFalloff: {
      value: 1
    },
    radius: {
      value: 5
    },
    near: {
      value: 0.1
    },
    far: {
      value: 1e3
    },
    logDepth: {
      value: false
    },
    ortho: {
      value: false
    },
    screenSpaceRadius: {
      value: false
    }
  },
  vertexShader: (
    /* glsl */
    `
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = vec4(position, 1);
}`
  ),
  fragmentShader: (
    /* glsl */
    `
    #define SAMPLES 16
    #define FSAMPLES 16.0
uniform sampler2D sceneDiffuse;
uniform sampler2D sceneNormal;
uniform highp sampler2D sceneDepth;
uniform mat4 projectionMatrixInv;
uniform mat4 viewMatrixInv;
uniform mat4 projMat;
uniform mat4 viewMat;
uniform mat4 projViewMat;
uniform vec3 cameraPos;
uniform vec2 resolution;
uniform float time;
uniform vec3[SAMPLES] samples;
uniform float[SAMPLES] samplesR;
uniform float radius;
uniform float distanceFalloff;
uniform float near;
uniform float far;
uniform bool logDepth;
uniform bool ortho;
uniform bool screenSpaceRadius;
uniform sampler2D bluenoise;
    varying vec2 vUv;
    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)
    {
        return (zFar * zNear) / (zFar - d * (zFar - zNear));
    }
    highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {
      return nearZ + (farZ - nearZ) * d;
    }
    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {
      float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;
      float a = farZ / (farZ - nearZ);
      float b = farZ * nearZ / (nearZ - farZ);
      float linDepth = a + b / depth;
      return ortho ? linearize_depth_ortho(
        linDepth,
        nearZ,
        farZ
      ) :linearize_depth(linDepth, nearZ, farZ);
    }

    vec3 getWorldPosLog(vec3 posS) {
      vec2 uv = posS.xy;
      float z = posS.z;
      float nearZ =near;
      float farZ = far;
      float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
      float a = farZ / (farZ - nearZ);
      float b = farZ * nearZ / (nearZ - farZ);
      float linDepth = a + b / depth;
      vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
      vec4 wpos = viewMatrixInv * projectionMatrixInv * clipVec;
      return wpos.xyz / wpos.w;
    }
    vec3 getWorldPos(float depth, vec2 coord) {
      #ifdef LOGDEPTH
        return getWorldPosLog(vec3(coord, depth));
      #endif
      float z = depth * 2.0 - 1.0;
      vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
      vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
      // Perspective division
     vec4 worldSpacePosition = viewMatrixInv * viewSpacePosition;
     worldSpacePosition.xyz /= worldSpacePosition.w;
      return worldSpacePosition.xyz;
  }

  vec3 computeNormal(vec3 worldPos, vec2 vUv) {
    ivec2 p = ivec2(vUv * resolution);
    float c0 = texelFetch(sceneDepth, p, 0).x;
    float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;
    float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;
    float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;
    float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;
    float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;
    float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;
    float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;
    float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;

    float dl = abs((2.0 * l1 - l2) - c0);
    float dr = abs((2.0 * r1 - r2) - c0);
    float db = abs((2.0 * b1 - b2) - c0);
    float dt = abs((2.0 * t1 - t2) - c0);

    vec3 ce = getWorldPos(c0, vUv).xyz;

    vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz
                          : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;
    vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz
                          : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;

    return normalize(cross(dpdx, dpdy));
}

void main() {
      vec4 diffuse = texture2D(sceneDiffuse, vUv);
      float depth = texture2D(sceneDepth, vUv).x;
      if (depth == 1.0) {
        gl_FragColor = vec4(vec3(1.0), 1.0);
        return;
      }
      vec3 worldPos = getWorldPos(depth, vUv);
    //  vec3 normal = texture2D(sceneNormal, vUv).rgb;//computeNormal(worldPos, vUv);
      #ifdef HALFRES
        vec3 normal = texture2D(sceneNormal, vUv).rgb;
      #else
        vec3 normal = computeNormal(worldPos, vUv);
      #endif
      vec4 noise = texture2D(bluenoise, gl_FragCoord.xy / 128.0);
      vec3 randomVec = normalize(noise.rgb * 2.0 - 1.0);
      vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal));
      vec3 bitangent = cross(normal, tangent);
      mat3 tbn = mat3(tangent, bitangent, normal);
      float occluded = 0.0;
      float totalWeight = 0.0;
     /* float radiusScreen = distance(
        worldPos,
        getWorldPos(depth, vUv + 
          vec2(48.0, 0.0) / resolution)
      );/*vUv.x < 0.5 ? radius : min(distance(
        worldPos,
        getWorldPos(depth, vUv + 
          vec2(100.0, 0.0) / resolution)
      ), radius);
      float distanceFalloffScreen = radiusScreen * 0.2;*/
      float radiusToUse = screenSpaceRadius ? distance(
        worldPos,
        getWorldPos(depth, vUv +
          vec2(radius, 0.0) / resolution)
      ) : radius;
      float distanceFalloffToUse =screenSpaceRadius ?
          radiusToUse * distanceFalloff
      : distanceFalloff;
      float bias = (0.1 / near) * fwidth(distance(worldPos, cameraPos)) / radiusToUse;
      for(float i = 0.0; i < FSAMPLES; i++) {
        vec3 sampleDirection = 
        tbn * 
        samples[int(i)];
        ;
        float moveAmt = samplesR[int(mod(i + noise.a * FSAMPLES, FSAMPLES))];
        vec3 samplePos = worldPos + radiusToUse * moveAmt * sampleDirection;
        vec4 offset = projViewMat * vec4(samplePos, 1.0);
        offset.xyz /= offset.w;
        offset.xyz = offset.xyz * 0.5 + 0.5;
        float sampleDepth = textureLod(sceneDepth, offset.xy, 0.0).x;
        /*float distSample = logDepth ? linearize_depth_log(sampleDepth, near, far) 
         (ortho ?  linearize_depth_ortho(sampleDepth, near, far) : linearize_depth(sampleDepth, near, far));*/
        #ifdef LOGDEPTH
        float distSample = linearize_depth_log(sampleDepth, near, far);
        #else
        float distSample = ortho ? linearize_depth_ortho(sampleDepth, near, far) : linearize_depth(sampleDepth, near, far);
        #endif
        float distWorld = ortho ? linearize_depth_ortho(offset.z, near, far) : linearize_depth(offset.z, near, far);
        float rangeCheck = smoothstep(0.0, 1.0, distanceFalloffToUse / (abs(distSample - distWorld)));
        vec2 diff = gl_FragCoord.xy - ( offset.xy * resolution);
        float weight = dot(sampleDirection, normal);
          occluded += rangeCheck * weight * 
            (distSample + bias
               < distWorld ? 1.0 : 0.0) * (
          (dot(
            diff,
            diff
             
            ) < 1.0 || (sampleDepth == depth) || (
              offset.x < 0.0 || offset.x > 1.0 || offset.y < 0.0 || offset.y > 1.0
            ) ? 0.0 : 1.0)
          );
          totalWeight += weight;
      }
      float occ = clamp(1.0 - occluded / totalWeight, 0.0, 1.0);
      gl_FragColor = vec4(0.5 + 0.5 * normal, occ);
}`
  )
};
var up = {
  uniforms: {
    sceneDiffuse: {
      value: null
    },
    sceneDepth: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    projMat: {
      value: new Matrix4()
    },
    viewMat: {
      value: new Matrix4()
    },
    projectionMatrixInv: {
      value: new Matrix4()
    },
    viewMatrixInv: {
      value: new Matrix4()
    },
    cameraPos: {
      value: new Vector3()
    },
    resolution: {
      value: new Vector2()
    },
    color: {
      value: new Vector3(0, 0, 0)
    },
    blueNoise: {
      value: null
    },
    downsampledDepth: {
      value: null
    },
    time: {
      value: 0
    },
    intensity: {
      value: 10
    },
    renderMode: {
      value: 0
    },
    gammaCorrection: {
      value: false
    },
    logDepth: {
      value: false
    },
    ortho: {
      value: false
    },
    near: {
      value: 0.1
    },
    far: {
      value: 1e3
    },
    screenSpaceRadius: {
      value: false
    },
    radius: {
      value: 0
    },
    distanceFalloff: {
      value: 1
    }
  },
  vertexShader: (
    /* glsl */
    `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = vec4(position, 1);
		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform sampler2D sceneDiffuse;
    uniform sampler2D sceneDepth;
    uniform sampler2D downsampledDepth;
    uniform sampler2D tDiffuse;
    uniform sampler2D blueNoise;
    uniform vec2 resolution;
    uniform vec3 color;
    uniform mat4 projectionMatrixInv;
    uniform mat4 viewMatrixInv;
    uniform float intensity;
    uniform float renderMode;
    uniform float near;
    uniform float far;
    uniform bool gammaCorrection;
    uniform bool logDepth;
    uniform bool ortho;
    uniform bool screenSpaceRadius;
    uniform float radius;
    uniform float distanceFalloff;
    varying vec2 vUv;
    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)
    {
        return (zFar * zNear) / (zFar - d * (zFar - zNear));
    }
    highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {
      return nearZ + (farZ - nearZ) * d;
    }
    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {
      float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;
      float a = farZ / (farZ - nearZ);
      float b = farZ * nearZ / (nearZ - farZ);
      float linDepth = a + b / depth;
      return ortho ? linearize_depth_ortho(
        linDepth,
        nearZ,
        farZ
      ) :linearize_depth(linDepth, nearZ, farZ);
    }
    vec3 getWorldPosLog(vec3 posS) {
        vec2 uv = posS.xy;
        float z = posS.z;
        float nearZ =near;
        float farZ = far;
        float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
        float a = farZ / (farZ - nearZ);
        float b = farZ * nearZ / (nearZ - farZ);
        float linDepth = a + b / depth;
        vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
        vec4 wpos = viewMatrixInv * projectionMatrixInv * clipVec;
        return wpos.xyz / wpos.w;
      }
      vec3 getWorldPos(float depth, vec2 coord) {
       // if (logDepth) {
        #ifdef LOGDEPTH
          return getWorldPosLog(vec3(coord, depth));
        #endif
      //  }
        float z = depth * 2.0 - 1.0;
        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
        // Perspective division
       vec4 worldSpacePosition = viewMatrixInv * viewSpacePosition;
       worldSpacePosition.xyz /= worldSpacePosition.w;
        return worldSpacePosition.xyz;
    }
  
    vec3 computeNormal(vec3 worldPos, vec2 vUv) {
      ivec2 p = ivec2(vUv * resolution);
      float c0 = texelFetch(sceneDepth, p, 0).x;
      float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;
      float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;
      float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;
      float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;
      float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;
      float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;
      float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;
      float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;
  
      float dl = abs((2.0 * l1 - l2) - c0);
      float dr = abs((2.0 * r1 - r2) - c0);
      float db = abs((2.0 * b1 - b2) - c0);
      float dt = abs((2.0 * t1 - t2) - c0);
  
      vec3 ce = getWorldPos(c0, vUv).xyz;
  
      vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz
                            : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;
      vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz
                            : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;
  
      return normalize(cross(dpdx, dpdy));
  }

    #include <common>
    #include <dithering_pars_fragment>
    void main() {
        //vec4 texel = texture2D(tDiffuse, vUv);//vec3(0.0);
        vec4 sceneTexel = texture2D(sceneDiffuse, vUv);

        #ifdef HALFRES 
        float depth = texture2D(
            sceneDepth,
            vUv
        ).x;
        vec4 texel;
        if (depth == 1.0) {
            texel = vec4(0.0, 0.0, 0.0, 1.0);
        } else {
        vec3 worldPos = getWorldPos(depth, vUv);
        vec3 normal = computeNormal(getWorldPos(depth, vUv), vUv);
       // vec4 texel = texture2D(tDiffuse, vUv);
       // Find closest depth;
       float totalWeight = 0.0;
       float radiusToUse = screenSpaceRadius ? distance(
        worldPos,
        getWorldPos(depth, vUv +
          vec2(radius, 0.0) / resolution)
      ) : radius;
      float distanceFalloffToUse =screenSpaceRadius ?
          radiusToUse * distanceFalloff
      : distanceFalloff;
        for(float x = -1.0; x <= 1.0; x++) {
            for(float y = -1.0; y <= 1.0; y++) {
                vec2 offset = vec2(x, y);
                ivec2 p = ivec2(
                    (vUv * resolution * 0.5) + offset
                );
                vec2 pUv = vec2(p) / (resolution * 0.5);
                float sampleDepth = texelFetch(downsampledDepth,p, 0).x;
                vec4 sampleInfo = texelFetch(tDiffuse, p, 0);
                vec3 normalSample = sampleInfo.xyz * 2.0 - 1.0;
                vec3 worldPosSample = getWorldPos(sampleDepth, pUv);
                float tangentPlaneDist = abs(dot(worldPos - worldPosSample, normal));
                float rangeCheck = exp(-1.0 * tangentPlaneDist * (1.0 / distanceFalloffToUse)) * max(dot(normal, normalSample), 0.0);
                float weight = rangeCheck;
                totalWeight += weight;
                texel += sampleInfo * weight;
            }
        }
        if (totalWeight == 0.0) {
            texel = texture2D(tDiffuse, vUv);
        } else {
            texel /= totalWeight;
        }
    }
        #else
        vec4 texel = texture2D(tDiffuse, vUv);
        #endif

     
        float finalAo = pow(texel.a, intensity);
        if (renderMode == 0.0) {
            gl_FragColor = vec4( mix(sceneTexel.rgb, color * sceneTexel.rgb, 1.0 - finalAo), sceneTexel.a);
        } else if (renderMode == 1.0) {
            gl_FragColor = vec4( mix(vec3(1.0), color * sceneTexel.rgb, 1.0 - finalAo), sceneTexel.a);
        } else if (renderMode == 2.0) {
            gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);
        } else if (renderMode == 3.0) {
            if (vUv.x < 0.5) {
                gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);
            } else if (abs(vUv.x - 0.5) < 1.0 / resolution.x) {
                gl_FragColor = vec4(1.0);
            } else {
                gl_FragColor = vec4( mix(sceneTexel.rgb, color * sceneTexel.rgb, 1.0 - finalAo), sceneTexel.a);
            }
        } else if (renderMode == 4.0) {
            if (vUv.x < 0.5) {
                gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);
            } else if (abs(vUv.x - 0.5) < 1.0 / resolution.x) {
                gl_FragColor = vec4(1.0);
            } else {
                gl_FragColor = vec4( mix(vec3(1.0), color * sceneTexel.rgb, 1.0 - finalAo), sceneTexel.a);
            }
        }
        #include <dithering_fragment>
        if (gammaCorrection) {
            gl_FragColor = LinearTosRGB(gl_FragColor);
        }
    }
    `
  )
};
var dp = {
  uniforms: {
    sceneDiffuse: {
      value: null
    },
    sceneDepth: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    projMat: {
      value: new Matrix4()
    },
    viewMat: {
      value: new Matrix4()
    },
    projectionMatrixInv: {
      value: new Matrix4()
    },
    viewMatrixInv: {
      value: new Matrix4()
    },
    cameraPos: {
      value: new Vector3()
    },
    resolution: {
      value: new Vector2()
    },
    time: {
      value: 0
    },
    r: {
      value: 5
    },
    blueNoise: {
      value: null
    },
    radius: {
      value: 12
    },
    worldRadius: {
      value: 5
    },
    index: {
      value: 0
    },
    poissonDisk: {
      value: []
    },
    distanceFalloff: {
      value: 1
    },
    near: {
      value: 0.1
    },
    far: {
      value: 1e3
    },
    logDepth: {
      value: false
    },
    screenSpaceRadius: {
      value: false
    }
  },
  vertexShader: (
    /* glsl */
    `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = vec4(position, 1.0);
		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform sampler2D sceneDiffuse;
    uniform highp sampler2D sceneDepth;
    uniform sampler2D tDiffuse;
    uniform sampler2D blueNoise;
    uniform mat4 projectionMatrixInv;
    uniform mat4 viewMatrixInv;
    uniform vec2 resolution;
    uniform float r;
    uniform float radius;
     uniform float worldRadius;
    uniform float index;
     uniform float near;
     uniform float far;
     uniform float distanceFalloff;
     uniform bool logDepth;
     uniform bool screenSpaceRadius;
    varying vec2 vUv;

    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)
    {
        highp float z_n = 2.0 * d - 1.0;
        return 2.0 * zNear * zFar / (zFar + zNear - z_n * (zFar - zNear));
    }
    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {
     float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;
     float a = farZ / (farZ - nearZ);
     float b = farZ * nearZ / (nearZ - farZ);
     float linDepth = a + b / depth;
     return linearize_depth(linDepth, nearZ, farZ);
   }
   highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {
     return nearZ + (farZ - nearZ) * d;
   }
   vec3 getWorldPosLog(vec3 posS) {
     vec2 uv = posS.xy;
     float z = posS.z;
     float nearZ =near;
     float farZ = far;
     float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
     float a = farZ / (farZ - nearZ);
     float b = farZ * nearZ / (nearZ - farZ);
     float linDepth = a + b / depth;
     vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
     vec4 wpos = viewMatrixInv * projectionMatrixInv * clipVec;
     return wpos.xyz / wpos.w;
   }
    vec3 getWorldPos(float depth, vec2 coord) {
     #ifdef LOGDEPTH
          return getWorldPosLog(vec3(coord, depth));
     #endif
        
        float z = depth * 2.0 - 1.0;
        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
        // Perspective division
       vec4 worldSpacePosition = viewMatrixInv * viewSpacePosition;
       worldSpacePosition.xyz /= worldSpacePosition.w;
        return worldSpacePosition.xyz;
    }
    #include <common>
    #define NUM_SAMPLES 16
    uniform vec2 poissonDisk[NUM_SAMPLES];
    void main() {
        const float pi = 3.14159;
        vec2 texelSize = vec2(1.0 / resolution.x, 1.0 / resolution.y);
        vec2 uv = vUv;
        vec4 data = texture2D(tDiffuse, vUv);
        float occlusion = data.a;
        float baseOcc = data.a;
        vec3 normal = data.rgb * 2.0 - 1.0;
        float count = 1.0;
        float d = texture2D(sceneDepth, vUv).x;
        vec3 worldPos = getWorldPos(d, vUv);
        float size = radius;
        float angle;
        if (index == 0.0) {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).x * PI2;
        } else if (index == 1.0) {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).y * PI2;
        } else if (index == 2.0) {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).z * PI2;
        } else {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).w * PI2;
        }

        mat2 rotationMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
        float radiusToUse = screenSpaceRadius ? distance(
          worldPos,
          getWorldPos(d, vUv +
            vec2(worldRadius, 0.0) / resolution)
        ) : worldRadius;
        float distanceFalloffToUse =screenSpaceRadius ?
            radiusToUse * distanceFalloff
        : distanceFalloff;


        for(int i = 0; i < NUM_SAMPLES; i++) {
            vec2 offset = (rotationMatrix * poissonDisk[i]) * texelSize * size;
            vec4 dataSample = texture2D(tDiffuse, uv + offset);
            float occSample = dataSample.a;
            vec3 normalSample = dataSample.rgb * 2.0 - 1.0;
            float dSample = texture2D(sceneDepth, uv + offset).x;
            vec3 worldPosSample = getWorldPos(dSample, uv + offset);
            float tangentPlaneDist = abs(dot(worldPos - worldPosSample, normal));
            float rangeCheck = exp(-1.0 * tangentPlaneDist * (1.0 / distanceFalloffToUse)) * max(dot(normal, normalSample), 0.0) * (1.0 - abs(occSample - baseOcc));
            occlusion += occSample * rangeCheck;
            count += rangeCheck;
        }
        occlusion /= count;
        gl_FragColor = vec4(0.5 + 0.5 * normal, occlusion);
    }
    `
  )
};
var fp = {
  uniforms: {
    sceneDepth: {
      value: null
    },
    resolution: {
      value: new Vector2()
    },
    near: {
      value: 0.1
    },
    far: {
      value: 1e3
    },
    viewMatrixInv: {
      value: new Matrix4()
    },
    projectionMatrixInv: {
      value: new Matrix4()
    },
    logDepth: {
      value: false
    }
  },
  vertexShader: (
    /* glsl */
    `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = vec4(position, 1);
    }`
  ),
  fragmentShader: (
    /* glsl */
    `
    uniform sampler2D sceneDepth;
    uniform vec2 resolution;
    uniform float near;
    uniform float far;
    uniform bool logDepth;
    uniform mat4 viewMatrixInv;
    uniform mat4 projectionMatrixInv;
    varying vec2 vUv;
    layout(location = 1) out vec4 gNormal;
    vec3 getWorldPosLog(vec3 posS) {
        vec2 uv = posS.xy;
        float z = posS.z;
        float nearZ =near;
        float farZ = far;
        float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
        float a = farZ / (farZ - nearZ);
        float b = farZ * nearZ / (nearZ - farZ);
        float linDepth = a + b / depth;
        vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
        vec4 wpos = viewMatrixInv * projectionMatrixInv * clipVec;
        return wpos.xyz / wpos.w;
      }
      vec3 getWorldPos(float depth, vec2 coord) {
        if (logDepth) {
          return getWorldPosLog(vec3(coord, depth));
        }
        float z = depth * 2.0 - 1.0;
        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
        // Perspective division
       vec4 worldSpacePosition = viewMatrixInv * viewSpacePosition;
       worldSpacePosition.xyz /= worldSpacePosition.w;
        return worldSpacePosition.xyz;
    }
  
    vec3 computeNormal(vec3 worldPos, vec2 vUv) {
      ivec2 p = ivec2(vUv * resolution);
      float c0 = texelFetch(sceneDepth, p, 0).x;
      float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;
      float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;
      float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;
      float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;
      float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;
      float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;
      float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;
      float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;
  
      float dl = abs((2.0 * l1 - l2) - c0);
      float dr = abs((2.0 * r1 - r2) - c0);
      float db = abs((2.0 * b1 - b2) - c0);
      float dt = abs((2.0 * t1 - t2) - c0);
  
      vec3 ce = getWorldPos(c0, vUv).xyz;
  
      vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz
                            : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;
      vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz
                            : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;
  
      return normalize(cross(dpdx, dpdy));
  }
    void main() {
        vec2 uv = vUv - vec2(0.5) / resolution;
        vec2 pixelSize = vec2(1.0) / resolution;
        vec2[] uvSamples = vec2[4](
            uv,
            uv + vec2(pixelSize.x, 0.0),
            uv + vec2(0.0, pixelSize.y),
            uv + pixelSize
        );
        float depth00 = texture2D(sceneDepth, uvSamples[0]).r;
        float depth10 = texture2D(sceneDepth, uvSamples[1]).r;
        float depth01 = texture2D(sceneDepth, uvSamples[2]).r;
        float depth11 = texture2D(sceneDepth, uvSamples[3]).r;
        float minDepth = min(min(depth00, depth10), min(depth01, depth11));
        float maxDepth = max(max(depth00, depth10), max(depth01, depth11));
        float targetDepth = minDepth;
        // Checkerboard pattern to avoid artifacts
        if (mod(gl_FragCoord.x + gl_FragCoord.y, 2.0) > 0.5) { 
            targetDepth = maxDepth;
        }
        int chosenIndex = 0;
        float[] samples = float[4](depth00, depth10, depth01, depth11);
        for(int i = 0; i < 4; ++i) {
            if (samples[i] == targetDepth) {
                chosenIndex = i;
                break;
            }
        }
        gl_FragColor = vec4(samples[chosenIndex], 0.0, 0.0, 1.0);
        gNormal = vec4(computeNormal(
            getWorldPos(samples[chosenIndex], uvSamples[chosenIndex]), uvSamples[chosenIndex]
        ), 0.0);
       /* float[] samples = float[4](depth00, depth10, depth01, depth11);
        float c = 0.25 * (depth00 + depth10 + depth01 + depth11);
        float[] distances = float[4](depth00, depth10, depth01, depth11);
        float maxDistance = max(max(distances[0], distances[1]), max(distances[2], distances[3]));

        int remaining[3];
        int rejected[3];
        int i, j, k;

        for(i = 0, j = 0, k = 0; i < 4; ++i) {
            if (distances[i] < maxDistance) {
                remaining[j++] = i;
            } else {
                rejected[k++] = i;
            }
        }
        for(;j < 3;++j) {
            remaining[j] = rejected[--k];
        }
        vec3 s = vec3(
            samples[remaining[0]],
            samples[remaining[1]],
            samples[remaining[2]]
        );
        c = (s.x + s.y + s.z) / 3.0;

        distances[0] = abs(c - s.x);
        distances[1] = abs(c - s.y);
        distances[2] = abs(c - s.z);

        float minDistance = min(min(distances[0], distances[1]), distances[2]);

        for(i = 0; i < 3; ++i) {
            if (distances[i] == minDistance) {
                break;
            }
        }*/
      /*  gl_FragColor = vec4(samples[remaining[i]], 0.0, 0.0, 0.0);
        gNormal = vec4(computeNormal(
            getWorldPos(samples[remaining[i]], uvSamples[remaining[i]]), uvSamples[remaining[i]]
        ), 0.0);*/
    }`
  )
};
var Sh = "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";
Uint8Array.from(atob(Sh), (u) => u.charCodeAt(0));
var pp = Uint8Array.from(atob(Sh), (u) => u.charCodeAt(0));
function Ah(u, t, e) {
  if (t.getQueryParameter(u, t.QUERY_RESULT_AVAILABLE)) {
    const i = t.getQueryParameter(u, t.QUERY_RESULT) / 1e6;
    e.lastTime = i;
  } else
    setTimeout(() => {
      Ah(u, t, e);
    }, 1);
}
var mp = class extends Is {
  /**
   * 
   * @param {THREE.Scene} scene
   * @param {THREE.Camera} camera 
   * @param {number} width 
   * @param {number} height
   *  
   * @property {THREE.Scene} scene
   * @property {THREE.Camera} camera
   * @property {number} width
   * @property {number} height
   */
  constructor(t, e, n = 512, s = 512) {
    super(), this.width = n, this.height = s, this.clear = true, this.camera = e, this.scene = t, this.configuration = new Proxy({
      aoSamples: 16,
      aoRadius: 5,
      denoiseSamples: 8,
      denoiseRadius: 12,
      distanceFalloff: 1,
      intensity: 5,
      denoiseIterations: 2,
      renderMode: 0,
      color: new Color(0, 0, 0),
      gammaCorrection: true,
      logarithmicDepthBuffer: false,
      screenSpaceRadius: false,
      halfRes: false,
      depthAwareUpsampling: true
    }, {
      set: (i, r, o) => {
        const l = i[r];
        return i[r] = o, r === "aoSamples" && l !== o && this.configureAOPass(this.configuration.logarithmicDepthBuffer), r === "denoiseSamples" && l !== o && this.configureDenoisePass(this.configuration.logarithmicDepthBuffer), r === "halfRes" && l !== o && (this.configureAOPass(this.configuration.logarithmicDepthBuffer), this.configureHalfResTargets(), this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer), this.setSize(this.width, this.height)), r === "depthAwareUpsampling" && l !== o && this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer), true;
      }
    }), this.samples = [], this.samplesR = [], this.samplesDenoise = [], this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer), this.configureSampleDependentPasses(), this.configureHalfResTargets(), this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: NearestFilter
    }), this.beautyRenderTarget.depthTexture = new DepthTexture(this.width, this.height, UnsignedIntType), this.beautyRenderTarget.depthTexture.format = DepthFormat, this.writeTargetInternal = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      depthBuffer: false
    }), this.readTargetInternal = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      depthBuffer: false
    }), this.bluenoise = new DataTexture(pp, 128, 128), this.bluenoise.colorSpace = NoColorSpace, this.bluenoise.wrapS = RepeatWrapping, this.bluenoise.wrapT = RepeatWrapping, this.bluenoise.minFilter = NearestFilter, this.bluenoise.magFilter = NearestFilter, this.bluenoise.needsUpdate = true, this.lastTime = 0, this._r = new Vector2(), this._c = new Color();
  }
  configureHalfResTargets() {
    this.configuration.halfRes ? (this.depthDownsampleTarget = /*new THREE.WebGLRenderTarget(this.width / 2, this.height / 2, {
        minFilter: THREE.NearestFilter,
        magFilter: THREE.NearestFilter,
        depthBuffer: false,
        format: THREE.RedFormat,
        type: THREE.FloatType
    });*/
    new WebGLMultipleRenderTargets(this.width / 2, this.height / 2, 2), this.depthDownsampleTarget.texture[0].format = RedFormat, this.depthDownsampleTarget.texture[0].type = FloatType, this.depthDownsampleTarget.texture[0].minFilter = NearestFilter, this.depthDownsampleTarget.texture[0].magFilter = NearestFilter, this.depthDownsampleTarget.texture[0].depthBuffer = false, this.depthDownsampleTarget.texture[1].format = RGBAFormat, this.depthDownsampleTarget.texture[1].type = HalfFloatType, this.depthDownsampleTarget.texture[1].minFilter = NearestFilter, this.depthDownsampleTarget.texture[1].magFilter = NearestFilter, this.depthDownsampleTarget.texture[1].depthBuffer = false, this.depthDownsampleQuad = new mr(new ShaderMaterial(fp))) : (this.depthDownsampleTarget && (this.depthDownsampleTarget.dispose(), this.depthDownsampleTarget = null), this.depthDownsampleQuad && (this.depthDownsampleQuad.dispose(), this.depthDownsampleQuad = null));
  }
  configureSampleDependentPasses() {
    this.configureAOPass(this.configuration.logarithmicDepthBuffer), this.configureDenoisePass(this.configuration.logarithmicDepthBuffer);
  }
  configureAOPass(t = false) {
    this.samples = this.generateHemisphereSamples(this.configuration.aoSamples), this.samplesR = this.generateHemisphereSamplesR(this.configuration.aoSamples);
    const e = {
      ...hp
    };
    e.fragmentShader = e.fragmentShader.replace("16", this.configuration.aoSamples).replace("16.0", this.configuration.aoSamples + ".0"), t && (e.fragmentShader = `#define LOGDEPTH
` + e.fragmentShader), this.configuration.halfRes && (e.fragmentShader = `#define HALFRES
` + e.fragmentShader), this.effectShaderQuad ? (this.effectShaderQuad.material.dispose(), this.effectShaderQuad.material = new ShaderMaterial(e)) : this.effectShaderQuad = new mr(new ShaderMaterial(e));
  }
  configureDenoisePass(t = false) {
    this.samplesDenoise = this.generateDenoiseSamples(this.configuration.denoiseSamples, 11);
    const e = {
      ...dp
    };
    e.fragmentShader = e.fragmentShader.replace("16", this.configuration.denoiseSamples), t && (e.fragmentShader = `#define LOGDEPTH
` + e.fragmentShader), this.poissonBlurQuad ? (this.poissonBlurQuad.material.dispose(), this.poissonBlurQuad.material = new ShaderMaterial(e)) : this.poissonBlurQuad = new mr(new ShaderMaterial(e));
  }
  configureEffectCompositer(t = false) {
    const e = {
      ...up
    };
    t && (e.fragmentShader = `#define LOGDEPTH
` + e.fragmentShader), this.configuration.halfRes && this.configuration.depthAwareUpsampling && (e.fragmentShader = `#define HALFRES
` + e.fragmentShader), this.effectCompositerQuad ? (this.effectCompositerQuad.material.dispose(), this.effectCompositerQuad.material = new ShaderMaterial(e)) : this.effectCompositerQuad = new mr(new ShaderMaterial(e));
  }
  /**
       * 
       * @param {Number} n 
       * @returns {THREE.Vector3[]}
       */
  generateHemisphereSamples(t) {
    const e = [];
    for (let n = 0; n < t; n++) {
      const s = 2.399963 * n, i = Math.sqrt(n + 0.5) / Math.sqrt(t), r = i * Math.cos(s), o = i * Math.sin(s), l = Math.sqrt(1 - (r * r + o * o));
      e.push(new Vector3(r, o, l));
    }
    return e;
  }
  /**
       * 
       * @param {number} n 
       * @returns {number[]}
       */
  generateHemisphereSamplesR(t) {
    let e = [];
    for (let n = 0; n < t; n++)
      e.push((n + 1) / t);
    return e;
  }
  /**
       * 
       * @param {number} numSamples 
       * @param {number} numRings 
       * @returns {THREE.Vector2[]}
       */
  generateDenoiseSamples(t, e) {
    const n = 2 * Math.PI * e / t, s = 1 / t, i = s, r = [];
    let o = s, l = 0;
    for (let h = 0; h < t; h++)
      r.push(new Vector2(Math.cos(l), Math.sin(l)).multiplyScalar(Math.pow(o, 0.75))), o += i, l += n;
    return r;
  }
  setSize(t, e) {
    this.width = t, this.height = e;
    const n = this.configuration.halfRes ? 0.5 : 1;
    this.beautyRenderTarget.setSize(t, e), this.writeTargetInternal.setSize(t * n, e * n), this.readTargetInternal.setSize(t * n, e * n), this.configuration.halfRes && this.depthDownsampleTarget.setSize(t * n, e * n);
  }
  render(t, e, n, s, i) {
    t.capabilities.logarithmicDepthBuffer !== this.configuration.logarithmicDepthBuffer && (this.configuration.logarithmicDepthBuffer = t.capabilities.logarithmicDepthBuffer, this.configureAOPass(this.configuration.logarithmicDepthBuffer), this.configureDenoisePass(this.configuration.logarithmicDepthBuffer), this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer));
    let r, o, l;
    this.debugMode && (r = t.getContext(), o = r.getExtension("EXT_disjoint_timer_query_webgl2"), o === null && (console.error("EXT_disjoint_timer_query_webgl2 not available, disabling debug mode."), this.debugMode = false)), t.setRenderTarget(this.beautyRenderTarget), t.render(this.scene, this.camera), this.debugMode && (l = r.createQuery(), r.beginQuery(o.TIME_ELAPSED_EXT, l));
    const h = t.xr.enabled;
    t.xr.enabled = false, this.camera.updateMatrixWorld(), this._r.set(this.width, this.height);
    let d = this.configuration.aoRadius;
    this.configuration.halfRes && this.configuration.screenSpaceRadius && (d *= 0.5), this.configuration.halfRes && (t.setRenderTarget(this.depthDownsampleTarget), this.depthDownsampleQuad.material.uniforms.sceneDepth.value = this.beautyRenderTarget.depthTexture, this.depthDownsampleQuad.material.uniforms.resolution.value = this._r, this.depthDownsampleQuad.material.uniforms.near.value = this.camera.near, this.depthDownsampleQuad.material.uniforms.far.value = this.camera.far, this.depthDownsampleQuad.material.uniforms.projectionMatrixInv.value = this.camera.projectionMatrixInverse, this.depthDownsampleQuad.material.uniforms.viewMatrixInv.value = this.camera.matrixWorld, this.depthDownsampleQuad.material.uniforms.logDepth.value = this.configuration.logarithmicDepthBuffer, this.depthDownsampleQuad.render(t)), this.effectShaderQuad.material.uniforms.sceneDiffuse.value = this.beautyRenderTarget.texture, this.effectShaderQuad.material.uniforms.sceneDepth.value = this.configuration.halfRes ? this.depthDownsampleTarget.texture[0] : this.beautyRenderTarget.depthTexture, this.effectShaderQuad.material.uniforms.sceneNormal.value = this.configuration.halfRes ? this.depthDownsampleTarget.texture[1] : null, this.effectShaderQuad.material.uniforms.projMat.value = this.camera.projectionMatrix, this.effectShaderQuad.material.uniforms.viewMat.value = this.camera.matrixWorldInverse, this.effectShaderQuad.material.uniforms.projViewMat.value = this.camera.projectionMatrix.clone().multiply(this.camera.matrixWorldInverse.clone()), this.effectShaderQuad.material.uniforms.projectionMatrixInv.value = this.camera.projectionMatrixInverse, this.effectShaderQuad.material.uniforms.viewMatrixInv.value = this.camera.matrixWorld, this.effectShaderQuad.material.uniforms.cameraPos.value = this.camera.position, this.effectShaderQuad.material.uniforms.resolution.value = this.configuration.halfRes ? this._r.clone().multiplyScalar(0.5).floor() : this._r, this.effectShaderQuad.material.uniforms.time.value = performance.now() / 1e3, this.effectShaderQuad.material.uniforms.samples.value = this.samples, this.effectShaderQuad.material.uniforms.samplesR.value = this.samplesR, this.effectShaderQuad.material.uniforms.bluenoise.value = this.bluenoise, this.effectShaderQuad.material.uniforms.radius.value = d, this.effectShaderQuad.material.uniforms.distanceFalloff.value = this.configuration.distanceFalloff, this.effectShaderQuad.material.uniforms.near.value = this.camera.near, this.effectShaderQuad.material.uniforms.far.value = this.camera.far, this.effectShaderQuad.material.uniforms.logDepth.value = t.capabilities.logarithmicDepthBuffer, this.effectShaderQuad.material.uniforms.ortho.value = this.camera.isOrthographicCamera, this.effectShaderQuad.material.uniforms.screenSpaceRadius.value = this.configuration.screenSpaceRadius, t.setRenderTarget(this.writeTargetInternal), this.effectShaderQuad.render(t);
    for (let m = 0; m < this.configuration.denoiseIterations; m++)
      [this.writeTargetInternal, this.readTargetInternal] = [
        this.readTargetInternal,
        this.writeTargetInternal
      ], this.poissonBlurQuad.material.uniforms.tDiffuse.value = this.readTargetInternal.texture, this.poissonBlurQuad.material.uniforms.sceneDepth.value = this.configuration.halfRes ? this.depthDownsampleTarget.texture[0] : this.beautyRenderTarget.depthTexture, this.poissonBlurQuad.material.uniforms.projMat.value = this.camera.projectionMatrix, this.poissonBlurQuad.material.uniforms.viewMat.value = this.camera.matrixWorldInverse, this.poissonBlurQuad.material.uniforms.projectionMatrixInv.value = this.camera.projectionMatrixInverse, this.poissonBlurQuad.material.uniforms.viewMatrixInv.value = this.camera.matrixWorld, this.poissonBlurQuad.material.uniforms.cameraPos.value = this.camera.position, this.poissonBlurQuad.material.uniforms.resolution.value = this.configuration.halfRes ? this._r.clone().multiplyScalar(0.5).floor() : this._r, this.poissonBlurQuad.material.uniforms.time.value = performance.now() / 1e3, this.poissonBlurQuad.material.uniforms.blueNoise.value = this.bluenoise, this.poissonBlurQuad.material.uniforms.radius.value = this.configuration.denoiseRadius * (this.configuration.halfRes ? 0.5 : 1), this.poissonBlurQuad.material.uniforms.worldRadius.value = d, this.poissonBlurQuad.material.uniforms.distanceFalloff.value = this.configuration.distanceFalloff, this.poissonBlurQuad.material.uniforms.index.value = m, this.poissonBlurQuad.material.uniforms.poissonDisk.value = this.samplesDenoise, this.poissonBlurQuad.material.uniforms.near.value = this.camera.near, this.poissonBlurQuad.material.uniforms.far.value = this.camera.far, this.poissonBlurQuad.material.uniforms.logDepth.value = t.capabilities.logarithmicDepthBuffer, this.poissonBlurQuad.material.uniforms.screenSpaceRadius.value = this.configuration.screenSpaceRadius, t.setRenderTarget(this.writeTargetInternal), this.poissonBlurQuad.render(t);
    this.effectCompositerQuad.material.uniforms.sceneDiffuse.value = this.beautyRenderTarget.texture, this.effectCompositerQuad.material.uniforms.sceneDepth.value = this.beautyRenderTarget.depthTexture, this.effectCompositerQuad.material.uniforms.near.value = this.camera.near, this.effectCompositerQuad.material.uniforms.far.value = this.camera.far, this.effectCompositerQuad.material.uniforms.projectionMatrixInv.value = this.camera.projectionMatrixInverse, this.effectCompositerQuad.material.uniforms.viewMatrixInv.value = this.camera.matrixWorld, this.effectCompositerQuad.material.uniforms.logDepth.value = t.capabilities.logarithmicDepthBuffer, this.effectCompositerQuad.material.uniforms.ortho.value = this.camera.isOrthographicCamera, this.effectCompositerQuad.material.uniforms.downsampledDepth.value = this.configuration.halfRes ? this.depthDownsampleTarget.texture[0] : this.beautyRenderTarget.depthTexture, this.effectCompositerQuad.material.uniforms.resolution.value = this._r, this.effectCompositerQuad.material.uniforms.blueNoise.value = this.bluenoise, this.effectCompositerQuad.material.uniforms.intensity.value = this.configuration.intensity, this.effectCompositerQuad.material.uniforms.renderMode.value = this.configuration.renderMode, this.effectCompositerQuad.material.uniforms.screenSpaceRadius.value = this.configuration.screenSpaceRadius, this.effectCompositerQuad.material.uniforms.radius.value = d, this.effectCompositerQuad.material.uniforms.distanceFalloff.value = this.configuration.distanceFalloff, this.effectCompositerQuad.material.uniforms.gammaCorrection.value = this.configuration.gammaCorrection, this.effectCompositerQuad.material.uniforms.tDiffuse.value = this.writeTargetInternal.texture, this.effectCompositerQuad.material.uniforms.color.value = this._c.copy(this.configuration.color).convertSRGBToLinear(), t.setRenderTarget(this.renderToScreen ? null : e), this.effectCompositerQuad.render(t), this.debugMode && (r.endQuery(o.TIME_ELAPSED_EXT), Ah(l, r, this)), t.xr.enabled = h;
  }
  /**
       * Enables the debug mode of the AO, meaning the lastTime value will be updated.
       */
  enableDebugMode() {
    this.debugMode = true;
  }
  /**
       * Disables the debug mode of the AO, meaning the lastTime value will not be updated.
       */
  disableDebugMode() {
    this.debugMode = false;
  }
  /**
       * Sets the display mode of the AO
       * @param {"Combined" | "AO" | "No AO" | "Split" | "Split AO"} mode - The display mode. 
       */
  setDisplayMode(t) {
    this.configuration.renderMode = [
      "Combined",
      "AO",
      "No AO",
      "Split",
      "Split AO"
    ].indexOf(t);
  }
  /**
       * 
       * @param {"Performance" | "Low" | "Medium" | "High" | "Ultra"} mode 
       */
  setQualityMode(t) {
    t === "Performance" ? (this.configuration.aoSamples = 8, this.configuration.denoiseSamples = 4, this.configuration.denoiseRadius = 12) : t === "Low" ? (this.configuration.aoSamples = 16, this.configuration.denoiseSamples = 4, this.configuration.denoiseRadius = 12) : t === "Medium" ? (this.configuration.aoSamples = 16, this.configuration.denoiseSamples = 8, this.configuration.denoiseRadius = 12) : t === "High" ? (this.configuration.aoSamples = 64, this.configuration.denoiseSamples = 8, this.configuration.denoiseRadius = 6) : t === "Ultra" && (this.configuration.aoSamples = 64, this.configuration.denoiseSamples = 16, this.configuration.denoiseRadius = 6);
  }
};
var gp = {
  name: "GammaCorrectionShader",
  uniforms: {
    tDiffuse: { value: null }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 tex = texture2D( tDiffuse, vUv );

			gl_FragColor = sRGBTransferOETF( tex );

		}`
  )
};
function Ep() {
  return new ShaderMaterial({
    side: 2,
    clipping: true,
    uniforms: {},
    vertexShader: `
    varying vec4 vColor;
    
    #include <clipping_planes_pars_vertex>
  
    void main() {
       #include <begin_vertex>
    
       vec4 absPosition = vec4(position, 1.0);
       vec3 trueNormal = normal;
       
       #ifdef USE_INSTANCING
          absPosition = instanceMatrix * absPosition;
          trueNormal = (instanceMatrix * vec4(normal, 0.)).xyz;
       #endif
       
       absPosition = modelMatrix * absPosition;
       trueNormal = (normalize(modelMatrix * vec4(trueNormal, 0.))).xyz;
       
       vec3 planePosition = absPosition.xyz / 40.;
       float d = abs(dot(trueNormal, planePosition));
       vColor = vec4(abs(trueNormal), d);
       gl_Position = projectionMatrix * viewMatrix * absPosition;
       
       #include <project_vertex>
       #include <clipping_planes_vertex>
    }
    `,
    fragmentShader: `
    varying vec4 vColor;
    
    #include <clipping_planes_pars_fragment>
  
    void main() {
      #include <clipping_planes_fragment>
      gl_FragColor = vColor;
    }
    `
  });
}
function vp() {
  return new ShaderMaterial({
    side: 2,
    clipping: true,
    uniforms: {},
    vertexShader: `
    varying vec3 vCameraPosition;
    varying vec3 vPosition;
    varying vec3 vNormal;
    
    #include <clipping_planes_pars_vertex>
  
    void main() {
       #include <begin_vertex>
       
       vec4 absPosition = vec4(position, 1.0);
       vNormal = normal;
       
       #ifdef USE_INSTANCING
          absPosition = instanceMatrix * absPosition;
          vNormal = (instanceMatrix * vec4(normal, 0.)).xyz;
       #endif
       
       absPosition = modelMatrix * absPosition;
       vNormal = (normalize(modelMatrix * vec4(vNormal, 0.))).xyz;
       
       gl_Position = projectionMatrix * viewMatrix * absPosition;
       
       vCameraPosition = cameraPosition;
       vPosition = absPosition.xyz;
       
       #include <project_vertex>
       #include <clipping_planes_vertex>
    }
    `,
    fragmentShader: `
    varying vec3 vCameraPosition;
    varying vec3 vPosition;
    varying vec3 vNormal;
    
    #include <clipping_planes_pars_fragment>
  
    void main() {
      #include <clipping_planes_fragment>
      vec3 cameraPixelVec = normalize(vCameraPosition - vPosition);
      float difference = abs(dot(vNormal, cameraPixelVec));
      
      // This achieves a double gloss effect: when the surface is perpendicular and when it's parallel
      difference = abs((difference * 2.) - 1.);
      
      gl_FragColor = vec4(difference, difference, difference, 1.);
    }
    `
  });
}
var Ip = class extends Is {
  constructor(e, n, s, i, r) {
    super();
    T(this, "components");
    T(this, "resolution");
    T(this, "renderScene");
    T(this, "renderCamera");
    T(this, "fsQuad");
    T(this, "normalOverrideMaterial");
    T(this, "glossOverrideMaterial");
    T(this, "planeBuffer");
    T(this, "glossBuffer");
    T(this, "outlineBuffer");
    T(this, "excludedMeshes", []);
    T(this, "outlinedMeshes", {});
    T(this, "_outlineScene", new Scene());
    T(this, "_outlineEnabled", false);
    T(this, "_lineColor", 10066329);
    T(this, "_opacity", 0.4);
    T(this, "_tolerance", 3);
    T(this, "_glossEnabled", true);
    T(this, "_glossExponent", 1.9);
    T(this, "_minGloss", -0.1);
    T(this, "_maxGloss", 0.1);
    T(this, "_outlinesNeedsUpdate", false);
    if (!s.renderer)
      throw new Error("The given world must have a renderer!");
    this.components = n, this.renderScene = i, this.renderCamera = r, this.resolution = new Vector2(e.x, e.y), this.fsQuad = new bh(), this.fsQuad.material = this.createOutlinePostProcessMaterial(), this.planeBuffer = this.newRenderTarget(), this.glossBuffer = this.newRenderTarget(), this.outlineBuffer = this.newRenderTarget();
    const o = Ep();
    o.clippingPlanes = s.renderer.clippingPlanes, this.normalOverrideMaterial = o;
    const l = vp();
    l.clippingPlanes = s.renderer.clippingPlanes, this.glossOverrideMaterial = l;
  }
  get lineColor() {
    return this._lineColor;
  }
  set lineColor(e) {
    this._lineColor = e, this.fsQuad.material.uniforms.lineColor.value.set(e);
  }
  get tolerance() {
    return this._tolerance;
  }
  set tolerance(e) {
    this._tolerance = e;
    const n = this.fsQuad.material;
    n.uniforms.tolerance.value = e;
  }
  get opacity() {
    return this._opacity;
  }
  set opacity(e) {
    this._opacity = e;
    const n = this.fsQuad.material;
    n.uniforms.opacity.value = e;
  }
  get glossEnabled() {
    return this._glossEnabled;
  }
  set glossEnabled(e) {
    if (e === this._glossEnabled)
      return;
    this._glossEnabled = e;
    const n = this.fsQuad.material;
    n.uniforms.glossEnabled.value = e ? 1 : 0;
  }
  get glossExponent() {
    return this._glossExponent;
  }
  set glossExponent(e) {
    this._glossExponent = e;
    const n = this.fsQuad.material;
    n.uniforms.glossExponent.value = e;
  }
  get minGloss() {
    return this._minGloss;
  }
  set minGloss(e) {
    this._minGloss = e;
    const n = this.fsQuad.material;
    n.uniforms.minGloss.value = e;
  }
  get maxGloss() {
    return new MeshBasicMaterial().color.convertLinearToSRGB(), this._maxGloss;
  }
  set maxGloss(e) {
    this._maxGloss = e;
    const n = this.fsQuad.material;
    n.uniforms.maxGloss.value = e;
  }
  get outlineEnabled() {
    return this._outlineEnabled;
  }
  set outlineEnabled(e) {
    if (e === this._outlineEnabled)
      return;
    this._outlineEnabled = e;
    const n = this.fsQuad.material;
    n.uniforms.outlineEnabled.value = e ? 1 : 0;
  }
  async dispose() {
    this.planeBuffer.dispose(), this.glossBuffer.dispose(), this.outlineBuffer.dispose(), this.normalOverrideMaterial.dispose(), this.glossOverrideMaterial.dispose(), this.fsQuad.dispose(), this.excludedMeshes = [], this._outlineScene.children = [];
    const e = this.components.get(rn);
    for (const n in this.outlinedMeshes) {
      const s = this.outlinedMeshes[n];
      for (const i of s.meshes)
        e.destroy(i, true, true);
      s.material.dispose();
    }
  }
  setSize(e, n) {
    this.planeBuffer.setSize(e, n), this.glossBuffer.setSize(e, n), this.outlineBuffer.setSize(e, n), this.resolution.set(e, n), this.fsQuad.material.uniforms.screenSize.value.set(
      this.resolution.x,
      this.resolution.y,
      1 / this.resolution.x,
      1 / this.resolution.y
    );
  }
  render(e, n, s) {
    const i = n.depthBuffer;
    n.depthBuffer = false;
    const r = this.renderScene.overrideMaterial, o = this.renderScene.background;
    this.renderScene.background = null;
    for (const h of this.excludedMeshes)
      h.visible = false;
    if (e.setRenderTarget(this.planeBuffer), this.renderScene.overrideMaterial = this.normalOverrideMaterial, e.render(this.renderScene, this.renderCamera), this._glossEnabled && (e.setRenderTarget(this.glossBuffer), this.renderScene.overrideMaterial = this.glossOverrideMaterial, e.render(this.renderScene, this.renderCamera)), this.renderScene.overrideMaterial = r, this._outlineEnabled) {
      let h = false;
      for (const d in this.outlinedMeshes) {
        const m = this.outlinedMeshes[d];
        for (const f of m.meshes)
          h = true, f.userData.materialPreOutline = f.material, f.material = m.material, f.userData.groupsPreOutline = f.geometry.groups, f.geometry.groups = [], f instanceof InstancedMesh && (f.userData.colorPreOutline = f.instanceColor, f.instanceColor = null), f.userData.parentPreOutline = f.parent, this._outlineScene.add(f);
      }
      (h || this._outlinesNeedsUpdate) && (e.setRenderTarget(this.outlineBuffer), e.render(this._outlineScene, this.renderCamera), this._outlinesNeedsUpdate = h);
      for (const d in this.outlinedMeshes) {
        const m = this.outlinedMeshes[d];
        for (const f of m.meshes)
          f.material = f.userData.materialPreOutline, f.geometry.groups = f.userData.groupsPreOutline, f instanceof InstancedMesh && (f.instanceColor = f.userData.colorPreOutline), f.userData.parentPreOutline && f.userData.parentPreOutline.add(f), f.userData.materialPreOutline = void 0, f.userData.groupsPreOutline = void 0, f.userData.colorPreOutline = void 0, f.userData.parentPreOutline = void 0;
      }
    }
    for (const h of this.excludedMeshes)
      h.visible = true;
    this.renderScene.background = o;
    const l = this.fsQuad.material;
    l.uniforms.planeBuffer.value = this.planeBuffer.texture, l.uniforms.glossBuffer.value = this.glossBuffer.texture, l.uniforms.outlineBuffer.value = this.outlineBuffer.texture, l.uniforms.sceneColorBuffer.value = s.texture, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), this.fsQuad.render(e)), n.depthBuffer = i;
  }
  get vertexShader() {
    return `
	  varying vec2 vUv;
	  void main() {
	  	vUv = uv;
	  	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
	  }
	`;
  }
  get fragmentShader() {
    return `
	  uniform sampler2D sceneColorBuffer;
	  uniform sampler2D planeBuffer;
	  uniform sampler2D glossBuffer;
	  uniform sampler2D outlineBuffer;
	  uniform vec4 screenSize;
	  uniform vec3 lineColor;
	  
	  uniform float outlineEnabled;
	  
      uniform int width;
	  uniform float opacity;
      uniform float tolerance;
      uniform float glossExponent;
      uniform float minGloss;
      uniform float maxGloss;
      uniform float glossEnabled;

	  varying vec2 vUv;

	  vec4 getValue(sampler2D buffer, int x, int y) {
	  	return texture2D(buffer, vUv + screenSize.zw * vec2(x, y));
	  }

      float normalDiff(vec3 normal1, vec3 normal2) {
        return ((dot(normal1, normal2) - 1.) * -1.) / 2.;
      }

      // Returns 0 if it's background, 1 if it's not
      float getIsBackground(vec3 normal) {
        float background = 1.0;
        background *= step(normal.x, 0.);
        background *= step(normal.y, 0.);
        background *= step(normal.z, 0.);
        background = (background - 1.) * -1.;
        return background;
      }

	  void main() {
	  
	    vec4 sceneColor = getValue(sceneColorBuffer, 0, 0);
	    vec3 normSceneColor = normalize(sceneColor.rgb);
  
        vec4 plane = getValue(planeBuffer, 0, 0);
	    vec3 normal = plane.xyz;
        float distance = plane.w;
  
        vec3 normalTop = getValue(planeBuffer, 0, width).rgb;
        vec3 normalBottom = getValue(planeBuffer, 0, -width).rgb;
        vec3 normalRight = getValue(planeBuffer, width, 0).rgb;
        vec3 normalLeft = getValue(planeBuffer, -width, 0).rgb;
        vec3 normalTopRight = getValue(planeBuffer, width, width).rgb;
        vec3 normalTopLeft = getValue(planeBuffer, -width, width).rgb;
        vec3 normalBottomRight = getValue(planeBuffer, width, -width).rgb;
        vec3 normalBottomLeft = getValue(planeBuffer, -width, -width).rgb;
  
        float distanceTop = getValue(planeBuffer, 0, width).a;
        float distanceBottom = getValue(planeBuffer, 0, -width).a;
        float distanceRight = getValue(planeBuffer, width, 0).a;
        float distanceLeft = getValue(planeBuffer, -width, 0).a;
        float distanceTopRight = getValue(planeBuffer, width, width).a;
        float distanceTopLeft = getValue(planeBuffer, -width, width).a;
        float distanceBottomRight = getValue(planeBuffer, width, -width).a;
        float distanceBottomLeft = getValue(planeBuffer, -width, -width).a;
        
        vec3 sceneColorTop = normalize(getValue(sceneColorBuffer, 1, 0).rgb);
        vec3 sceneColorBottom = normalize(getValue(sceneColorBuffer, -1, 0).rgb);
        vec3 sceneColorLeft = normalize(getValue(sceneColorBuffer, 0, -1).rgb);
        vec3 sceneColorRight = normalize(getValue(sceneColorBuffer, 0, 1).rgb);
        vec3 sceneColorTopRight = normalize(getValue(sceneColorBuffer, 1, 1).rgb);
        vec3 sceneColorBottomRight = normalize(getValue(sceneColorBuffer, -1, 1).rgb);
        vec3 sceneColorTopLeft = normalize(getValue(sceneColorBuffer, 1, 1).rgb);
        vec3 sceneColorBottomLeft = normalize(getValue(sceneColorBuffer, -1, 1).rgb);

        // Checks if the planes of this texel and the neighbour texels are different

        float planeDiff = 0.0;

        planeDiff += step(0.001, normalDiff(normal, normalTop));
        planeDiff += step(0.001, normalDiff(normal, normalBottom));
        planeDiff += step(0.001, normalDiff(normal, normalLeft));
        planeDiff += step(0.001, normalDiff(normal, normalRight));
        planeDiff += step(0.001, normalDiff(normal, normalTopRight));
        planeDiff += step(0.001, normalDiff(normal, normalTopLeft));
        planeDiff += step(0.001, normalDiff(normal, normalBottomRight));
        planeDiff += step(0.001, normalDiff(normal, normalBottomLeft));
        
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorTop));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorBottom));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorLeft));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorRight));
       	planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorTopRight));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorTopLeft));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorBottomRight));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorBottomLeft));

        planeDiff += step(0.001, abs(distance - distanceTop));
        planeDiff += step(0.001, abs(distance - distanceBottom));
        planeDiff += step(0.001, abs(distance - distanceLeft));
        planeDiff += step(0.001, abs(distance - distanceRight));
        planeDiff += step(0.001, abs(distance - distanceTopRight));
        planeDiff += step(0.001, abs(distance - distanceTopLeft));
        planeDiff += step(0.001, abs(distance - distanceBottomRight));
        planeDiff += step(0.001, abs(distance - distanceBottomLeft));

        // Add extra background outline

        int width2 = width + 1;
        vec3 normalTop2 = getValue(planeBuffer, 0, width2).rgb;
        vec3 normalBottom2 = getValue(planeBuffer, 0, -width2).rgb;
        vec3 normalRight2 = getValue(planeBuffer, width2, 0).rgb;
        vec3 normalLeft2 = getValue(planeBuffer, -width2, 0).rgb;
        vec3 normalTopRight2 = getValue(planeBuffer, width2, width2).rgb;
        vec3 normalTopLeft2 = getValue(planeBuffer, -width2, width2).rgb;
        vec3 normalBottomRight2 = getValue(planeBuffer, width2, -width2).rgb;
        vec3 normalBottomLeft2 = getValue(planeBuffer, -width2, -width2).rgb;

        planeDiff += -(getIsBackground(normalTop2) - 1.);
        planeDiff += -(getIsBackground(normalBottom2) - 1.);
        planeDiff += -(getIsBackground(normalRight2) - 1.);
        planeDiff += -(getIsBackground(normalLeft2) - 1.);
        planeDiff += -(getIsBackground(normalTopRight2) - 1.);
        planeDiff += -(getIsBackground(normalBottomRight2) - 1.);
        planeDiff += -(getIsBackground(normalBottomRight2) - 1.);
        planeDiff += -(getIsBackground(normalBottomLeft2) - 1.);

        // Tolerance sets the minimum amount of differences to consider
        // this texel an edge

        float line = step(tolerance, planeDiff);

        // Exclude background and apply opacity

        float background = getIsBackground(normal);
        line *= background;
        line *= opacity;
        
        // Add gloss
        
        vec3 gloss = getValue(glossBuffer, 0, 0).xyz;
        float diffGloss = abs(maxGloss - minGloss);
        vec3 glossExpVector = vec3(glossExponent,glossExponent,glossExponent);
        gloss = min(pow(gloss, glossExpVector), vec3(1.,1.,1.));
        gloss *= diffGloss;
        gloss += minGloss;
        vec4 glossedColor = sceneColor + vec4(gloss, 1.) * glossEnabled;
        
        vec4 corrected = mix(sceneColor, glossedColor, background);
        
        // Draw lines
        
        corrected = mix(corrected, vec4(lineColor, 1.), line);
        
        // Add outline
        
        vec4 outlinePreview =getValue(outlineBuffer, 0, 0);
        float outlineColorCorrection = 1. / max(0.2, outlinePreview.a);
        vec3 outlineColor = outlinePreview.rgb * outlineColorCorrection;
        
        // thickness between 10 and 2, opacity between 1 and 0.2
	    int outlineThickness = int(outlinePreview.a * 10.);
	    
	    float outlineDiff = 0.;
        
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 1, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, -1, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, -1).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, 1).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, outlineThickness, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, -outlineThickness, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, -outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, outlineThickness, outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, -outlineThickness, outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, -outlineThickness, -outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, outlineThickness, -outlineThickness).a);
        
        float outLine = step(4., outlineDiff) * step(outlineDiff, 12.) * outlineEnabled;
        corrected = mix(corrected, vec4(outlineColor, 1.), outLine);
        
        gl_FragColor = corrected;
	}
			`;
  }
  createOutlinePostProcessMaterial() {
    return new ShaderMaterial({
      uniforms: {
        opacity: { value: this._opacity },
        debugVisualize: { value: 0 },
        sceneColorBuffer: { value: null },
        tolerance: { value: this._tolerance },
        planeBuffer: { value: null },
        glossBuffer: { value: null },
        outlineBuffer: { value: null },
        glossEnabled: { value: 1 },
        minGloss: { value: this._minGloss },
        maxGloss: { value: this._maxGloss },
        outlineEnabled: { value: 0 },
        glossExponent: { value: this._glossExponent },
        width: { value: 1 },
        lineColor: { value: new Color(this._lineColor) },
        screenSize: {
          value: new Vector4(
            this.resolution.x,
            this.resolution.y,
            1 / this.resolution.x,
            1 / this.resolution.y
          )
        }
      },
      vertexShader: this.vertexShader,
      fragmentShader: this.fragmentShader
    });
  }
  newRenderTarget() {
    const e = new WebGLRenderTarget(
      this.resolution.x,
      this.resolution.y
    );
    return e.texture.colorSpace = "srgb-linear", e.texture.format = RGBAFormat, e.texture.type = HalfFloatType, e.texture.minFilter = NearestFilter, e.texture.magFilter = NearestFilter, e.texture.generateMipmaps = false, e.stencilBuffer = false, e;
  }
};
var yp = class {
  constructor(t, e, n) {
    T(this, "overrideClippingPlanes", false);
    T(this, "composer");
    T(this, "_enabled", false);
    T(this, "_initialized", false);
    T(this, "_n8ao");
    T(this, "_customEffects");
    T(this, "_basePass");
    T(this, "_gammaPass");
    T(this, "_depthTexture");
    T(this, "_settings", {
      gamma: true,
      custom: true,
      ao: false
    });
    T(this, "_renderer");
    T(this, "_components");
    T(this, "_world");
    T(this, "_renderTarget");
    if (!n.renderer)
      throw new Error("The given world must have a renderer!");
    this._components = t, this._renderer = e, this._world = n, this._renderTarget = new WebGLRenderTarget(
      window.innerWidth,
      window.innerHeight
    ), this._renderTarget.texture.colorSpace = "srgb-linear", this.composer = new ap(e, this._renderTarget), this.composer.setSize(window.innerWidth, window.innerHeight);
  }
  get basePass() {
    if (!this._basePass)
      throw new Error("Custom effects not initialized!");
    return this._basePass;
  }
  get gammaPass() {
    if (!this._gammaPass)
      throw new Error("Custom effects not initialized!");
    return this._gammaPass;
  }
  get customEffects() {
    if (!this._customEffects)
      throw new Error("Custom effects not initialized!");
    return this._customEffects;
  }
  get n8ao() {
    if (!this._n8ao)
      throw new Error("Custom effects not initialized!");
    return this._n8ao;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    this._initialized || this.initialize(), this._enabled = t;
  }
  get settings() {
    return { ...this._settings };
  }
  dispose() {
    var t, e, n, s;
    this._renderTarget.dispose(), (t = this._depthTexture) == null || t.dispose(), (e = this._customEffects) == null || e.dispose(), (n = this._gammaPass) == null || n.dispose(), (s = this._n8ao) == null || s.dispose();
  }
  setPasses(t) {
    let e = false;
    for (const n in t) {
      const s = n;
      if (this.settings[s] !== t[s]) {
        e = true;
        break;
      }
    }
    if (e) {
      for (const n in t) {
        const s = n;
        this._settings[s] !== void 0 && (this._settings[s] = t[s]);
      }
      this.updatePasses();
    }
  }
  setSize(t, e) {
    this._initialized && (this.composer.setSize(t, e), this.basePass.setSize(t, e), this.n8ao.setSize(t, e), this.customEffects.setSize(t, e), this.gammaPass.setSize(t, e));
  }
  update() {
    this._enabled && this.composer.render();
  }
  updateCamera() {
    const t = this._world.camera.three;
    this._n8ao && (this._n8ao.camera = t), this._customEffects && (this._customEffects.renderCamera = t), this._basePass && (this._basePass.camera = t);
  }
  initialize() {
    if (!this._world.renderer)
      throw new Error("The given world must have a renderer!");
    const t = this._world.scene.three, e = this._world.camera.three;
    if (!(t instanceof Scene))
      throw new Error("The given scene must have a THREE.Scene as core!");
    const n = this._world.camera;
    n.projection && n.projection.onChanged.add(() => {
      this.updateCamera();
    });
    const s = this._world.renderer;
    this.overrideClippingPlanes || (this._renderer.clippingPlanes = s.clippingPlanes), this._renderer.outputColorSpace = "srgb", this._renderer.toneMapping = NoToneMapping, this.newBasePass(t, e), this.newSaoPass(t, e), this.newGammaPass(), this.newCustomPass(t, e), this._initialized = true, this.updatePasses();
  }
  updateProjection(t) {
    this.composer.passes.forEach((e) => {
      e.camera = t;
    }), this.update();
  }
  updatePasses() {
    for (const t of this.composer.passes)
      this.composer.removePass(t);
    this._basePass && this.composer.addPass(this.basePass), this._settings.gamma && this.composer.addPass(this.gammaPass), this._settings.ao && this.composer.addPass(this.n8ao), this._settings.custom && this.composer.addPass(this.customEffects);
  }
  newCustomPass(t, e) {
    this._customEffects = new Ip(
      new Vector2(window.innerWidth, window.innerHeight),
      this._components,
      this._world,
      t,
      e
    );
  }
  newGammaPass() {
    this._gammaPass = new xh(gp);
  }
  newSaoPass(t, e) {
    if (!this._world.renderer)
      throw new Error("The given world must have a renderer!");
    const { width: n, height: s } = this._world.renderer.getSize();
    this._n8ao = new mp(t, e, n, s);
    const { configuration: i } = this._n8ao;
    i.aoSamples = 16, i.denoiseSamples = 1, i.denoiseRadius = 13, i.aoRadius = 1, i.distanceFalloff = 4, i.aoRadius = 1, i.intensity = 4, i.halfRes = true, i.color = new Color().setHex(13421772, "srgb-linear");
  }
  newBasePass(t, e) {
    this._basePass = new lp(t, e);
  }
};
var xa = class extends Bf {
  constructor(e, n, s) {
    super(e, n, s);
    T(this, "_postproduction");
    this.onResize.add((i) => this.resizePostproduction(i)), this.onWorldChanged.add(() => {
      this.currentWorld && (this._postproduction && this._postproduction.dispose(), this._postproduction = new yp(
        e,
        this.three,
        this.currentWorld
      ), this.setPostproductionSize());
    });
  }
  /** Helper object to handle the postproduction effects applied. */
  get postproduction() {
    if (!this._postproduction)
      throw new Error("Renderer not initialized yet with a world!");
    return this._postproduction;
  }
  update() {
    if (!this.enabled || !this.currentWorld)
      return;
    this.onBeforeUpdate.trigger();
    const e = this.currentWorld.scene.three, n = this.currentWorld.camera.three;
    this.postproduction.enabled ? this.postproduction.composer.render() : this.three.render(e, n), e instanceof Scene && this.three2D.render(e, n), this.onAfterUpdate.trigger();
  }
  /** {@link Disposable.dispose}. */
  dispose() {
    super.dispose(), this.postproduction.dispose();
  }
  resizePostproduction(e) {
    this.postproduction && this.setPostproductionSize(e);
  }
  setPostproductionSize(e) {
    if (!this.container)
      return;
    const n = e ? e.x : this.container.clientWidth, s = e ? e.y : this.container.clientHeight;
    this.postproduction.setSize(n, s);
  }
};
var wp = class {
  constructor(t, e, n, s) {
    T(this, "mesh", new Mesh(new BufferGeometry()));
    T(this, "world");
    T(this, "styleName");
    T(this, "_precission", 1e4);
    T(this, "_tempVector", new Vector3());
    T(this, "_plane");
    T(this, "_geometry");
    T(this, "_plane2DCoordinateSystem", new Matrix4());
    T(this, "_planeAxis");
    this.world = t, this.mesh.material = s, this.mesh.frustumCulled = false, this._plane = e;
    const { x: i, y: r, z: o } = e.normal;
    Math.abs(i) === 1 ? this._planeAxis = "x" : Math.abs(r) === 1 ? this._planeAxis = "y" : Math.abs(o) === 1 && (this._planeAxis = "z"), this._geometry = n, this.mesh.geometry.attributes.position = n.attributes.position;
    const l = e.normal.clone().multiplyScalar(0.01);
    this.mesh.position.copy(l), this.visible = true;
  }
  get visible() {
    return this.mesh.parent !== null;
  }
  set visible(t) {
    const e = this.getStyle();
    t ? (this.world.scene.three.add(this.mesh), e && e.meshes.add(this.mesh)) : (this.mesh.removeFromParent(), e && e.meshes.delete(this.mesh));
  }
  set geometry(t) {
    this._geometry = t, this.mesh.geometry.attributes.position = t.attributes.position;
  }
  dispose() {
    const t = this.getStyle();
    t && t.meshes.delete(this.mesh), this.mesh.geometry.dispose(), this.mesh.removeFromParent(), this.mesh.geometry = null, this.mesh = null, this._plane = null, this._geometry = null;
  }
  update(t) {
    const e = this._geometry.attributes.position.array;
    if (!e)
      return;
    this.updatePlane2DCoordinateSystem();
    const n = [];
    let s = 0;
    for (let i = 0; i < t.length; i++) {
      const r = t[i], o = [];
      for (let h = s; h < r; h += 2)
        o.push(h * 3);
      const l = this.computeFill(o, e);
      for (const h of l)
        n.push(h);
      s = r;
    }
    this.mesh.geometry.setIndex(n);
  }
  computeFill(t, e) {
    const n = /* @__PURE__ */ new Map(), s = {}, i = /* @__PURE__ */ new Map();
    let r = 0;
    const o = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Set(), d = this._precission;
    for (let f = 0; f < t.length; f++) {
      const g = t[f];
      let I = 0, y = 0, x = 0, A = 0;
      const F = e[g], P = e[g + 1], b = e[g + 2], O = e[g + 3], k = e[g + 4], Y = e[g + 5];
      if (this._tempVector.set(F, P, b), this._tempVector.applyMatrix4(this._plane2DCoordinateSystem), I = Math.trunc(this._tempVector.x * d) / d, y = Math.trunc(this._tempVector.y * d) / d, this._tempVector.set(O, k, Y), this._tempVector.applyMatrix4(this._plane2DCoordinateSystem), x = Math.trunc(this._tempVector.x * d) / d, A = Math.trunc(this._tempVector.y * d) / d, I === x && y === A)
        continue;
      const H = `${I}|${y}`, K = `${x}|${A}`;
      n.has(H) || n.set(H, g / 3), n.has(K) || n.set(K, g / 3 + 1);
      const Z = n.get(H), q = n.get(K);
      s[Z] = [I, y], s[q] = [x, A];
      const ne = l.has(Z), se = o.has(Z), ue = l.has(q), me = o.has(q);
      if (!ne && !se && !ue && !me)
        l.set(Z, r), o.set(q, r), h.add(r), i.set(r, [Z, q]), r++;
      else if (ne && me) {
        const Ee = l.get(Z), de = o.get(q);
        if (Ee !== de) {
          const we = i.get(de), Ke = i.get(Ee);
          if (!we || !Ke)
            continue;
          i.delete(Ee), h.delete(Ee), o.set(Ke[Ke.length - 1], de), o.delete(we[we.length - 1]);
          for (const Nt of Ke)
            we.push(Nt);
        } else
          h.delete(de);
        l.delete(Z), o.delete(q);
      } else if (se && ue) {
        const Ee = l.get(q), de = o.get(Z);
        if (Ee !== de) {
          const we = i.get(de), Ke = i.get(Ee);
          if (!we || !Ke)
            continue;
          i.delete(Ee), h.delete(Ee), o.set(Ke[Ke.length - 1], de), o.delete(we[we.length - 1]);
          for (const Nt of Ke)
            we.push(Nt);
        } else
          h.delete(de);
        l.delete(q), o.delete(Z);
      } else if (ne && ue) {
        const Ee = l.get(q), de = l.get(Z), Le = i.get(de), we = i.get(Ee);
        if (!Le || !we)
          continue;
        i.delete(Ee), h.delete(Ee), l.delete(Le[0]), l.delete(we[0]), o.delete(we[we.length - 1]), l.set(we[we.length - 1], de), we.reverse(), Le.splice(0, 0, ...we);
      } else if (se && me) {
        const Ee = o.get(q), de = o.get(Z), Le = i.get(de), we = i.get(Ee);
        if (!Le || !we)
          continue;
        i.delete(Ee), h.delete(Ee), o.delete(Le[Le.length - 1]), o.delete(we[we.length - 1]), l.delete(we[0]), o.set(we[0], de), we.reverse(), Le.push(...we);
      } else if (ne) {
        const Ee = l.get(Z), de = i.get(Ee);
        if (!de)
          continue;
        de.unshift(q), l.delete(Z), l.set(q, Ee);
      } else if (se) {
        const Ee = o.get(Z), de = i.get(Ee);
        if (!de)
          continue;
        de.push(q), o.delete(Z), o.set(q, Ee);
      } else if (ue) {
        const Ee = l.get(q), de = i.get(Ee);
        if (!de)
          continue;
        de.unshift(Z), l.delete(q), l.set(Z, Ee);
      } else if (me) {
        const Ee = o.get(q), de = i.get(Ee);
        if (!de)
          continue;
        de.push(Z), o.delete(q), o.set(Z, Ee);
      }
    }
    const m = [];
    for (const [f, g] of i) {
      if (h.has(f))
        continue;
      const I = [], y = /* @__PURE__ */ new Map();
      let x = 0;
      for (const F of g) {
        const P = s[F];
        I.push(P[0], P[1]), y.set(x++, F);
      }
      const A = tp(I);
      for (const F of A) {
        const P = y.get(F);
        if (P === void 0)
          throw new Error("Map error!");
        m.push(P);
      }
    }
    return m;
  }
  updatePlane2DCoordinateSystem() {
    this._plane2DCoordinateSystem = new Matrix4();
    const t = new Vector3(1, 0, 0), e = new Vector3(0, 1, 0), n = this._plane.normal, s = new Vector3();
    this._plane.coplanarPoint(s), this._planeAxis === "x" ? t.crossVectors(e, n) : this._planeAxis === "y" ? e.crossVectors(n, t) : this._planeAxis === "z" || (t.crossVectors(e, n).normalize(), e.crossVectors(n, t)), this._plane2DCoordinateSystem.fromArray([
      t.x,
      t.y,
      t.z,
      0,
      e.x,
      e.y,
      e.z,
      0,
      n.x,
      n.y,
      n.z,
      0,
      s.x,
      s.y,
      s.z,
      1
    ]), this._plane2DCoordinateSystem.invert();
  }
  getStyle() {
    if (!this.world.renderer)
      return null;
    const t = this.world.renderer instanceof xa;
    return this.styleName && t ? this.world.renderer.postproduction.customEffects.outlinedMeshes[this.styleName] : null;
  }
};
var Cp = class {
  constructor(t, e, n) {
    T(this, "onDisposed", new $());
    T(this, "onAfterUpdate", new $());
    T(this, "onBeforeUpdate", new $());
    T(this, "enabled", true);
    T(this, "fillNeedsUpdate", false);
    T(this, "components");
    T(this, "world");
    T(this, "_edges", {});
    T(this, "_visible", true);
    T(this, "_inverseMatrix", new Matrix4());
    T(this, "_localPlane", new Plane());
    T(this, "_tempLine", new Line3());
    T(this, "_tempVector", new Vector3());
    T(this, "_plane");
    this.components = t, this.world = e, this._plane = n;
  }
  /** {@link Hideable.visible} */
  get visible() {
    return this._visible;
  }
  set visible(t) {
    for (const e in this._edges) {
      const n = this._edges[e];
      t ? this.world.scene.three.add(n.mesh) : n.mesh.removeFromParent(), n.fill && (n.fill.visible = t);
    }
  }
  /** {@link Updateable.update} */
  update() {
    const e = this.components.get(ms).styles.list;
    this.updateDeletedEdges(e);
    for (const n in e)
      this.drawEdges(n);
    this.fillNeedsUpdate = false;
  }
  /** {@link Component.get} */
  get() {
    return this._edges;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    const t = Object.keys(this._edges);
    for (const e of t)
      this.disposeEdge(e);
    this.onDisposed.trigger(), this.onDisposed.reset();
  }
  newEdgesMesh(t) {
    const s = this.components.get(ms).styles.list[t].lineMaterial, i = new BufferGeometry(), r = new Float32Array(3e5), o = new BufferAttribute(r, 3, false);
    o.setUsage(DynamicDrawUsage), i.setAttribute("position", o);
    const l = new LineSegments(i, s);
    return l.frustumCulled = false, l;
  }
  newFillMesh(t, e) {
    const i = this.components.get(ms).styles.list[t], r = i.fillMaterial;
    if (r) {
      const o = new wp(
        this.world,
        this._plane,
        e,
        r
      );
      return this.newFillOutline(t, o, i), o;
    }
  }
  newFillOutline(t, e, n) {
    if (!n.outlineMaterial || !this.world.renderer)
      return;
    const s = this.world.renderer;
    if (s instanceof xa) {
      const r = s.postproduction.customEffects.outlinedMeshes;
      r[t] || (r[t] = {
        meshes: /* @__PURE__ */ new Set(),
        material: n.outlineMaterial
      }), e.styleName = t;
    }
  }
  // Source: https://gkjohnson.github.io/three-mesh-bvh/example/bundle/clippedEdges.html
  drawEdges(t) {
    const n = this.components.get(ms).styles.list[t];
    this._edges[t] || this.initializeStyle(t);
    const s = this._edges[t];
    let i = 0;
    const r = s.mesh.geometry.attributes.position;
    r.array.fill(0);
    const o = [];
    let l = 0;
    for (const m of n.meshes)
      if (m.geometry) {
        if (!m.geometry.boundsTree)
          throw new Error("Bounds tree not found for clipping edges subset.");
        if (m instanceof InstancedMesh) {
          if (m.count === 0)
            continue;
          const f = m;
          for (let g = 0; g < f.count; g++) {
            const I = f instanceof Js, y = f, x = n.fragments[y.fragment.id];
            if (I && x) {
              const P = y.fragment.getItemID(g);
              if (P === null || !x.has(P))
                continue;
            }
            const A = new Mesh(m.geometry);
            A.matrix.copy(m.matrix);
            const F = new Matrix4();
            f.getMatrixAt(g, F), A.applyMatrix4(F), A.applyMatrix4(m.matrix), A.updateMatrix(), A.updateMatrixWorld(), this._inverseMatrix.copy(A.matrixWorld).invert(), this._localPlane.copy(this._plane).applyMatrix4(this._inverseMatrix), i = this.shapecast(A, r, i), i !== l && (o.push(i), l = i);
          }
        } else
          this._inverseMatrix.copy(m.matrixWorld).invert(), this._localPlane.copy(this._plane).applyMatrix4(this._inverseMatrix), i = this.shapecast(m, r, i), i !== l && (o.push(i), l = i);
      }
    s.mesh.geometry.setDrawRange(0, i), s.mesh.position.copy(this._plane.normal).multiplyScalar(1e-4), r.needsUpdate = true;
    const d = s.mesh.geometry.attributes.position;
    Number.isNaN(d.array[0]) || (s.mesh.parent || this.world.scene.three.add(s.mesh), this.fillNeedsUpdate && s.fill && (s.fill.geometry = s.mesh.geometry, s.fill.update(o)));
  }
  initializeStyle(t) {
    const e = this.newEdgesMesh(t), n = e.geometry, s = this.newFillMesh(t, n);
    this._edges[t] = { mesh: e, name: t, fill: s };
  }
  shapecast(t, e, n) {
    return t.geometry.boundsTree.shapecast({
      intersectsBounds: (s) => this._localPlane.intersectsBox(s),
      // @ts-ignore
      intersectsTriangle: (s) => {
        let i = 0;
        if (this._tempLine.start.copy(s.a), this._tempLine.end.copy(s.b), this._localPlane.intersectLine(this._tempLine, this._tempVector)) {
          const r = this._tempVector.applyMatrix4(t.matrixWorld);
          e.setXYZ(n, r.x, r.y, r.z), i++, n++;
        }
        if (this._tempLine.start.copy(s.b), this._tempLine.end.copy(s.c), this._localPlane.intersectLine(this._tempLine, this._tempVector)) {
          const r = this._tempVector.applyMatrix4(t.matrixWorld);
          e.setXYZ(n, r.x, r.y, r.z), i++, n++;
        }
        if (this._tempLine.start.copy(s.c), this._tempLine.end.copy(s.a), this._localPlane.intersectLine(this._tempLine, this._tempVector)) {
          const r = this._tempVector.applyMatrix4(t.matrixWorld);
          e.setXYZ(n, r.x, r.y, r.z), i++, n++;
        }
        i !== 2 && (n -= i);
      }
    }), n;
  }
  updateDeletedEdges(t) {
    const e = Object.keys(this._edges);
    for (const n of e)
      t[n] === void 0 && (this.disposeEdge(n), this.disposeOutline(n));
  }
  disposeOutline(t) {
    if (!this.world.renderer)
      return;
    const e = this.world.renderer;
    if (e instanceof xa) {
      const n = e.postproduction.customEffects.outlinedMeshes;
      delete n[t];
    }
  }
  disposeEdge(t) {
    const e = this.components.get(rn), n = this._edges[t];
    n.fill && n.fill.dispose(), e.destroy(n.mesh, false), delete this._edges[t];
  }
};
var hi = class extends jr {
  constructor(e, n, s, i, r, o = 5, l = true) {
    super(e, n, s, i, r, o, l);
    T(this, "edges");
    T(this, "edgesMaxUpdateRate", 50);
    T(this, "_visible", true);
    T(this, "_edgesVisible", true);
    T(this, "updateFill", () => {
      this.edges.fillNeedsUpdate = true, this.edges.update(), this.edges.visible = this._visible;
    });
    this.edges = new Cp(e, n, this.three), this.toggleControls(true), this.edges.visible = true, this.onDraggingEnded.add(() => {
      this.updateFill();
    }), this.onDraggingStarted.add(() => this.edges.visible = false);
  }
  get visible() {
    return this._visible;
  }
  set visible(e) {
    super.visible = e, this.toggleControls(e);
  }
  set enabled(e) {
    this._enabled = e, this.world.renderer && this.world.renderer.setPlane(e, this.three);
  }
  get enabled() {
    return super.enabled;
  }
  dispose() {
    super.dispose(), this.edges.dispose();
  }
};
var Tp = class {
  constructor() {
    T(this, "onDisposed", new $());
    T(this, "enabled", true);
    T(this, "list", {});
    T(this, "_defaultLineMaterial", new LineBasicMaterial({
      color: 0,
      linewidth: 1e-3
    }));
    T(this, "onAfterUpdate", new $());
    T(this, "onBeforeUpdate", new $());
  }
  update(t) {
    this.onBeforeUpdate.trigger(this.list), this.onAfterUpdate.trigger(this.list);
  }
  // Creates a new style that applies to all clipping edges for generic models
  create(t, e, n, s, i, r) {
    if (!n.renderer)
      throw new Error("The given world doesn't have a renderer!");
    s || (s = this._defaultLineMaterial);
    for (const h of e)
      h.geometry.boundsTree || h.geometry.computeBoundsTree();
    const o = n.renderer;
    s.clippingPlanes = o.clippingPlanes;
    const l = {
      name: t,
      lineMaterial: s,
      meshes: e,
      fillMaterial: i,
      outlineMaterial: r,
      fragments: {}
    };
    return this.list[t] = l, l;
  }
  dispose() {
    const t = Object.keys(this.list);
    for (const e of t)
      this.deleteStyle(e);
    this.list = {}, this.onDisposed.trigger(), this.onDisposed.reset();
  }
  deleteStyle(t, e = true) {
    var s, i;
    const n = this.list[t];
    n && (n.meshes.clear(), e && (n.lineMaterial.dispose(), (s = n.fillMaterial) == null || s.dispose(), (i = n.outlineMaterial) == null || i.dispose())), delete this.list[t];
  }
};
var Or = class Or2 extends Re {
  constructor(e) {
    super(e);
    T(this, "onDisposed", new $());
    T(this, "enabled", true);
    T(this, "styles");
    T(this, "fillsNeedUpdate", false);
    T(this, "_visible", true);
    this.components.list.set(Or2.uuid, this), this.styles = new Tp();
  }
  get visible() {
    return this._visible;
  }
  set visible(e) {
    this._visible = e;
    const n = this.components.get(Sr);
    for (const s of n.list)
      s instanceof hi && (s.edges.visible = e);
  }
  dispose() {
    this.styles.dispose(), this.onDisposed.trigger();
  }
  /**
   * Updates all the lines of the {@link ClippingEdges}.
   */
  async update(e = false) {
    if (!this.enabled)
      return;
    const n = this.components.get(Sr);
    for (const s of n.list)
      s instanceof hi && (e || this.fillsNeedUpdate ? s.updateFill() : s.update());
    this.fillsNeedUpdate = false;
  }
};
T(Or, "uuid", "24dfc306-a3c4-410f-8071-babc4afa5e4d");
var ms = Or;
var bp = {
  name: "HorizontalBlurShader",
  uniforms: {
    tDiffuse: { value: null },
    h: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float h;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
};
var xp = {
  name: "VerticalBlurShader",
  uniforms: {
    tDiffuse: { value: null },
    v: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float v;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
};
var vn = class vn2 extends Re {
  constructor(e) {
    super(e);
    T(this, "onDisposed", new $());
    T(this, "enabled", true);
    T(this, "cameraHeight", 10);
    T(this, "darkness", 1.2);
    T(this, "opacity", 1);
    T(this, "resolution", 512);
    T(this, "amount", 3.5);
    T(this, "planeColor", 16777215);
    T(this, "shadowOffset", 0);
    T(this, "shadowExtraScaleFactor", 1.5);
    T(this, "list", {});
    T(this, "tempMaterial", new MeshBasicMaterial({ visible: false }));
    T(this, "depthMaterial", new MeshDepthMaterial());
    this.components.add(vn2.uuid, this), this.initializeDepthMaterial();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const e in this.list)
      this.deleteShadow(e);
    this.tempMaterial.dispose(), this.depthMaterial.dispose(), this.components = null, this.onDisposed.trigger(vn2.uuid), this.onDisposed.reset();
  }
  /**
   * Creates a blurred dropped shadow of the given mesh.
   *
   * @param model - the mesh whose shadow to generate.
   * @param id - the name of this shadow.
   */
  create(e, n, s) {
    if (this.list[n])
      throw new Error(`There is already a shadow with ID ${n}`);
    const { size: i, center: r, min: o } = this.getSizeCenterMin(e), l = this.createShadow(n, i, s);
    return this.initializeShadow(l, r, o), this.createPlanes(l, i), this.bakeShadow(e, l), l.root;
  }
  /**
   * Deletes the specified shadow (if it exists).
   *
   * @param id - the name of this shadow.
   */
  deleteShadow(e) {
    const n = this.components.get(rn), s = this.list[e];
    if (delete this.list[e], !s)
      throw new Error(`No shadow with ID ${e} was found.`);
    n.destroy(s.root), n.destroy(s.blurPlane), s.rt.dispose(), s.rtBlur.dispose();
  }
  createPlanes(e, n) {
    const s = new PlaneGeometry(n.x, n.z).rotateX(
      Math.PI / 2
    );
    this.createBasePlane(e, s), vn2.createBlurPlane(e, s);
  }
  initializeShadow(e, n, s) {
    this.initializeRoot(e, n, s), vn2.initializeRenderTargets(e), vn2.initializeCamera(e);
  }
  bakeShadow(e, n) {
    const s = n.world.scene.three;
    if (!(s instanceof Scene))
      throw new Error("The core of the scene of the world must be a scene!");
    if (!n.world.renderer)
      throw new Error("The given world must have a renderer!");
    const i = n.world.renderer.three, r = e.map((d) => !!d.parent);
    for (let d = 0; d < e.length; d++)
      r[d] || s.add(e[d]);
    const o = s.children.filter(
      (d) => !e.includes(d) && d !== n.root
    );
    for (let d = o.length - 1; d >= 0; d--)
      s.remove(o[d]);
    const l = s.background;
    s.background = null, s.overrideMaterial = this.depthMaterial;
    const h = [];
    for (const d of e)
      h.push(d.visible), d.visible = true;
    i.setRenderTarget(n.rt), i.render(s, n.camera), s.overrideMaterial = null, this.blurShadow(n, this.amount), this.blurShadow(n, this.amount * 0.4), i.setRenderTarget(null), s.background = l;
    for (let d = 0; d < e.length; d++)
      e[d].visible = h[d];
    for (let d = o.length - 1; d >= 0; d--)
      s.add(o[d]);
    for (let d = 0; d < e.length; d++)
      r[d] || s.remove(e[d]);
  }
  static initializeCamera(e) {
    e.camera.rotation.x = Math.PI / 2, e.root.add(e.camera);
  }
  static initializeRenderTargets(e) {
    e.rt.texture.generateMipmaps = false, e.rtBlur.texture.generateMipmaps = false;
  }
  initializeRoot(e, n, s) {
    const i = e.world.scene.three;
    e.root.position.set(n.x, s.y - this.shadowOffset, n.z), i.add(e.root);
  }
  // Plane simulating the "ground". This is not needed for BIM models generally
  // private createGroundColorPlane(_shadow: Shadow, planeGeometry: BufferGeometry) {
  //   const fillPlaneMaterial = new MeshBasicMaterial({
  //     color: this.planeColor,
  //     opacity: this.opacity,
  //     transparent: true,
  //     depthWrite: false,
  //     clippingPlanes: this.context.getClippingPlanes()
  //   });
  //   const fillPlane = new Mesh(planeGeometry, fillPlaneMaterial);
  //   fillPlane.rotateX(Math.PI);
  //   fillPlane.renderOrder = -1;
  //   shadow.root.add(fillPlane);
  // }
  createBasePlane(e, n) {
    const s = this.createPlaneMaterial(e), i = new Mesh(n, s);
    i.renderOrder = 2, e.root.add(i), i.scale.y = -1;
  }
  static createBlurPlane(e, n) {
    e.blurPlane.geometry = n, e.blurPlane.visible = false, e.root.add(e.blurPlane);
  }
  createPlaneMaterial(e) {
    if (!e.world.renderer)
      throw new Error("The given world must have a renderer!");
    const n = e.world.renderer.three;
    return new MeshBasicMaterial({
      map: e.rt.texture,
      opacity: this.opacity,
      transparent: true,
      depthWrite: false,
      clippingPlanes: n.clippingPlanes
    });
  }
  // like MeshDepthMaterial, but goes from black to transparent
  initializeDepthMaterial() {
    this.depthMaterial.depthTest = false, this.depthMaterial.depthWrite = false;
    const e = "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );", n = "gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * darkness );";
    this.depthMaterial.userData.darkness = { value: this.darkness }, this.depthMaterial.onBeforeCompile = (s) => {
      s.uniforms.darkness = this.depthMaterial.userData.darkness, s.fragmentShader = /* glsl */
      `
						uniform float darkness;
						${s.fragmentShader.replace(e, n)}
					`;
    };
  }
  createShadow(e, n, s) {
    return this.list[e] = {
      root: new Group(),
      world: s,
      rt: new WebGLRenderTarget(this.resolution, this.resolution),
      rtBlur: new WebGLRenderTarget(this.resolution, this.resolution),
      blurPlane: new Mesh(),
      camera: this.createCamera(n)
    }, this.list[e];
  }
  createCamera(e) {
    return new OrthographicCamera(
      -e.x / 2,
      e.x / 2,
      e.z / 2,
      -e.z / 2,
      0,
      this.cameraHeight
    );
  }
  getSizeCenterMin(e) {
    const n = e[0].parent, s = new Group();
    s.children = e;
    const i = new Box3().setFromObject(s);
    n == null || n.add(...e);
    const r = new Vector3();
    i.getSize(r), r.x *= this.shadowExtraScaleFactor, r.z *= this.shadowExtraScaleFactor;
    const o = new Vector3();
    i.getCenter(o);
    const l = i.min;
    return { size: r, center: o, min: l };
  }
  blurShadow(e, n) {
    if (!e.world.renderer)
      throw new Error("The given world must have a renderer!");
    const s = new ShaderMaterial(
      bp
    );
    s.depthTest = false;
    const i = new ShaderMaterial(xp);
    i.depthTest = false, e.blurPlane.visible = true, e.blurPlane.material = s, e.blurPlane.material.uniforms.tDiffuse.value = e.rt.texture, s.uniforms.h.value = n * 1 / 256;
    const r = e.world.renderer.three;
    r.setRenderTarget(e.rtBlur), r.render(e.blurPlane, e.camera), e.blurPlane.material = i, e.blurPlane.material.uniforms.tDiffuse.value = e.rtBlur.texture, i.uniforms.v.value = n * 1 / 256, r.setRenderTarget(e.rt), r.render(e.blurPlane, e.camera), e.blurPlane.visible = false;
  }
};
T(vn, "uuid", "f833a09a-a3ab-4c58-b03e-da5298c7a1b6");
var pc = vn;
var Sp = [
  "Station",
  "Radius",
  "Length",
  "InitialKP",
  "FinalKP",
  "KP",
  "Slope",
  "Height",
  "InitialKPV",
  "FinalKPV"
];
var Dr = class Dr2 extends Re {
  constructor(e) {
    super(e);
    T(this, "enabled", true);
    T(this, "world", null);
    T(this, "_list", /* @__PURE__ */ new Map());
    T(this, "_markerKey", 0);
    T(this, "type", "horizontal");
    T(this, "divisionLength", 100);
    e.add(Dr2.uuid, this);
  }
  addKPStation(e, n, s) {
    const i = this.components.get(nn), r = document.createElement("div"), o = document.createElement("div");
    r.appendChild(o), o.innerHTML = n, o.style.color = i.color, o.style.borderBottom = "1px dotted white", o.style.width = "160px", o.style.textAlign = "left";
    const l = new ft(e, r), h = new Vector3();
    h.x = s.geometry.attributes.position.getX(
      s.geometry.attributes.position.count - 1
    ), h.y = s.geometry.attributes.position.getY(
      s.geometry.attributes.position.count - 1
    ), h.z = s.geometry.attributes.position.getZ(
      s.geometry.attributes.position.count - 1
    );
    const d = new Vector3();
    d.x = s.geometry.attributes.position.getX(
      s.geometry.attributes.position.count - 2
    ), d.y = s.geometry.attributes.position.getY(
      s.geometry.attributes.position.count - 2
    ), d.z = s.geometry.attributes.position.getZ(
      s.geometry.attributes.position.count - 2
    );
    const m = new Vector3();
    m.x = (h.x + d.x) / 2, m.y = (h.y + d.y) / 2, m.z = (h.z + d.z) / 2, l.three.position.copy(m);
    const f = new Vector3();
    f.subVectors(h, d).normalize();
    const g = new Quaternion();
    g.setFromUnitVectors(new Vector3(0, 1, 0), f);
    const I = new Euler().setFromQuaternion(g).z, y = MathUtils.radToDeg(I);
    o.style.transform = `rotate(${-y - 90}deg) translate(-35%, -50%)`;
    const x = this._markerKey.toString();
    i.setupEvents(e, true), i.getWorldMarkerList(e).set(x, {
      label: l,
      key: x,
      merged: false,
      static: false
    }), this._markerKey++, this.save(x, "KP");
  }
  addVerticalMarker(e, n, s, i, r) {
    const o = this.components.get(nn), l = document.createElement("span");
    l.innerHTML = n, l.style.color = o.color;
    const h = new ft(e, l, r);
    if (i === "Height") {
      const f = document.createElement("span");
      f.innerHTML = n, f.style.color = o.color;
      const { position: g } = s.geometry.attributes, y = (g.array.length / 3 - 1) * 3, x = g.array.slice(y, y + 3);
      h.three.position.set(x[0], x[1] + 10, x[2]);
    } else if (i === "InitialKPV") {
      const { position: f } = s.geometry.attributes, g = f.getX(0), I = f.getY(0), y = f.getZ(0);
      h.three.position.set(g - 20, I, y);
    } else if (i === "FinalKPV") {
      const { position: f } = s.geometry.attributes, g = f.getX(s.geometry.attributes.position.count - 1), I = f.getY(s.geometry.attributes.position.count - 1), y = f.getZ(s.geometry.attributes.position.count - 1);
      h.three.position.set(g + 20, I, y);
    } else if (i === "Slope") {
      l.style.color = "grey";
      const { position: f } = s.geometry.attributes, g = new Vector3();
      g.x = f.getX(0), g.y = f.getY(0), g.z = f.getZ(0);
      const I = new Vector3();
      I.x = f.getX(f.count - 1), I.y = f.getY(f.count - 1), I.z = f.getZ(f.count - 1);
      const y = new Vector3();
      y.addVectors(g, I).multiplyScalar(0.5), h.three.position.set(y.x, y.y - 10, y.z);
    }
    const d = this._markerKey.toString();
    return o.setupEvents(e, true), o.getWorldMarkerList(e).set(d, {
      label: h,
      key: d,
      type: i,
      merged: false,
      static: false
    }), this._markerKey++, this.save(d, i), h;
  }
  addCivilMarker(e, n, s, i) {
    const r = this.components.get(nn), o = document.createElement("span");
    o.innerHTML = n, o.style.color = r.color;
    const l = new ft(e, o);
    if (i === "InitialKP") {
      const m = s.geometry.attributes.position.getX(0), f = s.geometry.attributes.position.getY(0), g = s.geometry.attributes.position.getZ(0);
      l.three.position.set(m + 2, f + 2, g);
    } else if (i === "FinalKP") {
      const m = s.geometry.attributes.position.getX(
        s.geometry.attributes.position.count - 1
      ), f = s.geometry.attributes.position.getY(
        s.geometry.attributes.position.count - 1
      ), g = s.geometry.attributes.position.getZ(
        s.geometry.attributes.position.count - 1
      );
      l.three.position.set(m + 2, f - 2, g);
    } else if (i === "Length") {
      const m = new Vector3();
      m.x = s.geometry.attributes.position.getX(0), m.y = s.geometry.attributes.position.getY(0), m.z = s.geometry.attributes.position.getZ(0);
      const f = new Vector3();
      f.x = s.geometry.attributes.position.getX(
        s.geometry.attributes.position.count - 1
      ), f.y = s.geometry.attributes.position.getY(
        s.geometry.attributes.position.count - 1
      ), f.z = s.geometry.attributes.position.getZ(
        s.geometry.attributes.position.count - 1
      );
      const g = m.distanceTo(f);
      l.three.element.innerText = g.toFixed(2);
      const I = f.clone().add(m).divideScalar(2);
      l.three.position.copy(I);
    }
    const h = this._markerKey.toString();
    return r.setupEvents(e, true), r.getWorldMarkerList(e).set(h, {
      label: l,
      key: h,
      type: i,
      merged: false,
      static: false
    }), this._markerKey++, this.save(h, i), l;
  }
  showKPStations(e) {
    if (!this.world)
      throw new Error("A world is needed for this component to work!");
    if (this.type === "horizontal") {
      const n = this.generateStartAndEndKP(e);
      for (const [, i] of n)
        this.addKPStation(this.world, i.value, i.normal);
      const s = this.generateConstantKP(e);
      for (const [, i] of s)
        this.addKPStation(this.world, i.value, i.normal);
    }
  }
  showCurveLength(e, n) {
    if (!this.world)
      throw new Error("A world is needed for this component to work!");
    const s = this.components.get(nn), i = e.length, r = `${n.toFixed(2)} m`, o = Math.round(i / 2), l = e[o], h = s.create(this.world, r, l, true);
    h !== void 0 && this.save(h, "Radius");
  }
  showLineLength(e, n) {
    if (!this.world)
      throw new Error("A world is needed for this component to work!");
    const s = this.components.get(nn), i = new Vector3();
    i.x = e.geometry.getAttribute("position").getX(0), i.y = e.geometry.getAttribute("position").getY(0), i.z = e.geometry.getAttribute("position").getZ(0);
    const r = new Vector3();
    r.x = e.geometry.getAttribute("position").getX(1), r.y = e.geometry.getAttribute("position").getY(1), r.z = e.geometry.getAttribute("position").getZ(1);
    const o = `${n.toFixed(2)} m`, l = new Vector3();
    l.addVectors(i, r).multiplyScalar(0.5);
    const h = s.create(this.world, o, l, true);
    h !== void 0 && this.save(h, "Radius");
  }
  showCurveRadius(e, n) {
    if (!this.world)
      throw new Error("A world is needed for this component to work!");
    const s = this.components.get(nn), i = new Vector3();
    i.x = e.geometry.getAttribute("position").getX(0), i.y = e.geometry.getAttribute("position").getY(0), i.z = e.geometry.getAttribute("position").getZ(0);
    const r = new Vector3();
    r.x = e.geometry.getAttribute("position").getX(1), r.y = e.geometry.getAttribute("position").getY(1), r.z = e.geometry.getAttribute("position").getZ(1);
    const o = `R = ${n.toFixed(2)} m`, l = new Vector3();
    l.addVectors(i, r).multiplyScalar(0.5);
    const h = s.create(this.world, o, l, true);
    h !== void 0 && this.save(h, "Radius");
  }
  deleteByType(e = Sp) {
    const n = this.components.get(nn);
    for (const s of e) {
      const i = this._list.get(s);
      if (i) {
        for (const r of i)
          n.delete(r);
        this._list.delete(s);
      }
    }
  }
  generateStartAndEndKP(e) {
    const { alignment: n } = e.curve, s = /* @__PURE__ */ new Map();
    for (const i of n.horizontal) {
      const r = i.getLength();
      if (s.size > 0) {
        const o = i.index - 1, h = s.get(o).distance + r, d = i.mesh.geometry.getAttribute("position"), m = d.count - 1, f = new Vector3();
        f.x = d.getX(m), f.y = d.getY(m), f.z = d.getZ(m);
        const g = this.createNormalLine(i.mesh);
        s.set(i.index, {
          value: this.getShortendKPValue(h),
          distance: h,
          point: f,
          normal: g
        });
      } else {
        const o = i.mesh.geometry.getAttribute("position"), l = o.count - 1, h = new Vector3();
        h.x = o.getX(l), h.y = o.getY(l), h.z = o.getZ(l);
        const d = this.createNormalLine(i.mesh);
        s.set(i.index, {
          value: this.getShortendKPValue(r),
          distance: r,
          point: h,
          normal: d
        });
      }
    }
    return s;
  }
  createNormalLine(e) {
    const n = e.geometry.attributes.position.count - 1, s = n - 1, i = new Vector3();
    i.x = e.geometry.attributes.position.getX(n), i.y = e.geometry.attributes.position.getY(n), i.z = e.geometry.attributes.position.getZ(n);
    const r = new Vector3();
    r.x = e.geometry.attributes.position.getX(s), r.y = e.geometry.attributes.position.getY(s), r.z = e.geometry.attributes.position.getZ(s);
    const l = new Vector3().subVectors(
      i,
      r
    ).clone().applyAxisAngle(new Vector3(0, 0, 1), Math.PI * 0.5).normalize(), h = new BufferGeometry().setFromPoints([
      l.clone().setLength(10).add(i),
      l.clone().setLength(-10).add(i)
    ]);
    return new Line(h);
  }
  generateConstantKP(e) {
    const { alignment: n } = e.curve, s = /* @__PURE__ */ new Map(), i = n.getLength("horizontal"), r = Math.floor(i / this.divisionLength);
    for (let o = 0; o < r; o++) {
      const l = o / r, h = n.getPointAt(l, "horizontal"), d = i * l, m = this.getNormal(n, h);
      s.set(o, {
        value: this.getShortendKPValue(d),
        distance: d,
        point: h,
        normal: m
      });
    }
    return s;
  }
  // TODO: Move Generation of Points to Previous Method Call
  getNormal(e, n) {
    const s = [], i = {
      start: new Vector3(),
      end: new Vector3()
    };
    for (let d = 0; d < e.horizontal.length; d++) {
      const f = e.horizontal[d].mesh.geometry.attributes.position, g = f.count;
      for (let I = 0; I < g; I++) {
        const y = f.getX(I), x = f.getY(I), A = f.getZ(I);
        s.push(new Vector3(y, x, A));
      }
    }
    for (let d = 0; d < s.length - 1; d++) {
      const m = s[d], f = s[d + 1], g = m.distanceTo(n), I = f.distanceTo(n), y = m.distanceTo(f);
      Math.abs(g + I - y) < 1e-5 && (i.start = m, i.end = f);
    }
    const o = new Vector3().subVectors(
      i.end,
      i.start
    ).clone().applyAxisAngle(new Vector3(0, 0, 1), Math.PI * 0.5).normalize(), l = new BufferGeometry().setFromPoints([
      o.clone().setLength(10).add(n),
      o.clone().setLength(-10).add(n)
    ]);
    return new Line(
      l,
      new LineBasicMaterial({ color: 16711680 })
    );
  }
  getShortendKPValue(e) {
    const n = e.toFixed(2), [s, i] = n.toString().split("."), r = i || "00";
    if (parseInt(s, 10) > 1e3 && parseInt(s, 10) < 1e4) {
      const [o, ...l] = s;
      return `${o}+${l.join("")}.${r}`;
    }
    if (parseInt(s, 10) > 1e4) {
      const [o, l, ...h] = s;
      return `${o}${l}+${h.join("")}.${r}`;
    }
    return `0+${s.padStart(3, "0")}.${r}`;
  }
  save(e, n) {
    this._list.has(n) || this._list.set(n, /* @__PURE__ */ new Set()), this._list.get(n).add(e);
  }
};
T(Dr, "uuid", "0af12c32-81ee-4100-a030-e9ae546f6170");
var kn = Dr;
var Rh = class extends Re {
  constructor(e) {
    super(e);
    T(this, "enabled", true);
    T(this, "_highlighter");
    T(this, "onHighlight", new $());
    T(this, "onMarkerChange", new $());
    T(this, "mouseMarkers");
    T(this, "onMarkerHidden", new $());
    T(this, "_curves", []);
    T(this, "_previousAlignment", null);
    T(this, "_world", null);
    T(this, "updateLinesResolution", (e2) => {
      var n;
      (n = this._highlighter) == null || n.setResolution(e2);
    });
    T(this, "onMouseMove", (e2) => {
      var o, l, h;
      if (!this._world)
        throw new Error("No world was given for this navigator!");
      if (!this._world.renderer)
        return;
      const s = this._world.renderer.three.domElement.parentElement, i = this._world.camera.three, r = (o = this._highlighter) == null ? void 0 : o.castRay(e2, i, s, this._curves);
      if (r) {
        const { object: d } = r;
        (l = this._highlighter) == null || l.hover(d), this.updateMarker(r, "hover");
        return;
      }
      this.mouseMarkers && (this.mouseMarkers.hover.visible = false), (h = this._highlighter) == null || h.unHover(), this.onMarkerHidden.trigger({ type: "hover" });
    });
    T(this, "onClick", (e2) => {
      var o, l;
      if (!this._world)
        throw new Error("No world was given for this navigator!");
      if (!this._world.renderer)
        return;
      const s = this._world.renderer.three.domElement.parentElement, i = this._world.camera.three, r = (o = this._highlighter) == null ? void 0 : o.castRay(e2, i, s, this._curves);
      if (r) {
        const h = r, d = h.object;
        if ((l = this._highlighter) == null || l.select(d), this.updateMarker(h, "select"), this._world.camera.hasCameraControls() && (d.geometry.boundingBox || d.geometry.computeBoundingBox(), d.geometry.boundingBox)) {
          const m = this.getScaledBox(d.geometry.boundingBox, 2);
          this._world.camera.controls.fitToBox(m, true);
        }
        this.onHighlight.trigger({ mesh: d, point: h.point }), this._previousAlignment !== d.curve.alignment && (this.components.get(kn).showKPStations(d), this._previousAlignment = d.curve.alignment);
      }
    });
    T(this, "onControlsUpdated", () => {
      if (!this._world)
        throw new Error("No world was given for this navigator!");
      if (!(this._world.camera.three instanceof OrthographicCamera) || !this._highlighter)
        return;
      const { zoom: e2, left: n, right: s, top: i, bottom: r } = this._world.camera.three, o = n - s, l = i - r, d = Math.max(o, l) / e2, m = 40, { caster: f } = this._highlighter;
      f.params.Line.threshold = d / m;
    });
  }
  get highlighter() {
    if (!this._highlighter)
      throw new Error(
        "Highlighter not initialized. You must set a world first!"
      );
    return this._highlighter;
  }
  get world() {
    return this._world;
  }
  set world(e) {
    var s, i, r;
    if (e === this._world || (this._world && this.setupEvents(false), this._world = e, (s = this._highlighter) == null || s.dispose(), (i = this.mouseMarkers) == null || i.hover.dispose(), (r = this.mouseMarkers) == null || r.select.dispose(), !e))
      return;
    const n = e.scene.three;
    this._highlighter = new Fr(n, this.view), this.mouseMarkers = {
      select: this.newMouseMarker("#ffffff", e),
      hover: this.newMouseMarker("#575757", e)
    }, this.setupEvents(true);
  }
  async draw(e, n) {
    if (!e.civilData)
      throw new Error("The provided model doesn't have civil data!");
    if (!this._world)
      throw new Error("No world was given for this navigator!");
    const { alignments: s } = e.civilData, i = n || s.values(), r = this._world.scene.three, o = new Box3();
    o.makeEmpty(), o.min.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), o.max.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    for (const h of i) {
      if (!h)
        throw new Error("Alignment not found!");
      for (const d of h[this.view])
        if (r.add(d.mesh), this._curves.push(d.mesh), !o.isEmpty())
          o.expandByObject(d.mesh);
        else {
          d.mesh.geometry.computeBoundingBox();
          const m = d.mesh.geometry.boundingBox;
          m instanceof Box3 && o.copy(m).applyMatrix4(d.mesh.matrixWorld);
        }
    }
    const l = this.getScaledBox(o, 1.2);
    this._world.camera.hasCameraControls() && await this._world.camera.controls.fitToBox(l, false);
  }
  async dispose() {
    var e;
    (e = this._highlighter) == null || e.dispose(), this.clear(), this.onHighlight.reset(), this._curves = [];
  }
  clear() {
    var e, n;
    (e = this._highlighter) == null || e.unSelect(), (n = this._highlighter) == null || n.unHover();
    for (const s of this._curves)
      s.removeFromParent();
    this._curves = [];
  }
  setMarker(e, n, s) {
    if (!this._curves.length)
      return;
    const i = e.getCurveAt(n, this.view), r = e.getPointAt(n, this.view), { index: o } = i.curve.getSegmentAt(i.percentage);
    this.setMouseMarker(r, i.curve.mesh, o, s);
  }
  setDefSegments(e) {
    const n = [], s = [], i = (r, o) => {
      const l = o[1] - r[1], h = o[0] - r[0];
      return l / h;
    };
    for (let r = 0; r < e.length; r++) {
      const o = e[r];
      let l, h, d, m;
      for (let I = 0; I < Object.keys(o).length / 3; I++)
        if (o[I * 3] !== void 0 && o[I * 3 + 1] !== void 0) {
          l = o[I * 3], h = o[I * 3 + 1];
          break;
        }
      for (let I = Object.keys(o).length / 3 - 1; I >= 0; I--)
        if (o[I * 3] !== void 0 && o[I * 3 + 1] !== void 0) {
          d = o[I * 3], m = o[I * 3 + 1];
          break;
        }
      const g = (i(
        // @ts-ignore
        [l, h],
        // @ts-ignore
        [d, m]
      ) * 100).toFixed(2);
      s.push({ slope: g });
    }
    for (const r of e)
      for (let o = 0; o < r.length - 3; o += 3) {
        const l = r[o], h = r[o + 1], d = r[o + 2], m = r[o + 3], f = r[o + 4], g = r[o + 5];
        n.push({
          start: new Vector3(l, h, d),
          end: new Vector3(m, f, g)
        });
      }
    return { defSegments: n, slope: s };
  }
  hideMarker(e) {
    this.mouseMarkers && (this.mouseMarkers[e].visible = false);
  }
  setupEvents(e) {
    var i, r;
    if (!this._world)
      throw new Error("No world was given for this navigator!");
    if (this._world.isDisposing || !this._world.renderer)
      return;
    const s = this._world.renderer.three.domElement.parentElement;
    (i = this._world.renderer) == null || i.onResize.remove(this.updateLinesResolution), s.removeEventListener("mousemove", this.onMouseMove), s.removeEventListener("click", this.onClick), this._world.camera.hasCameraControls() && this._world.camera.controls.removeEventListener("update", this.onControlsUpdated), e && (s.addEventListener("mousemove", this.onMouseMove), s.addEventListener("click", this.onClick), (r = this._world.renderer) == null || r.onResize.add(this.updateLinesResolution), this._world.camera.hasCameraControls() && this._world.camera.controls.addEventListener("update", this.onControlsUpdated));
  }
  newMouseMarker(e, n) {
    if (!this._world)
      throw new Error("No world was given for this navigator!");
    const s = n.scene.three, i = document.createElement("div"), r = document.createElement("div");
    i.appendChild(r), r.style.backgroundColor = e, r.style.width = "3rem", r.style.height = "3px";
    const o = new ft(this._world, i, s);
    return o.visible = false, o;
  }
  setMouseMarker(e, n, s, i) {
    if (s === void 0 || !this.mouseMarkers)
      return;
    this.mouseMarkers[i].visible = true;
    const r = this.mouseMarkers[i].three;
    r.position.copy(e);
    const o = n, { startPoint: l, endPoint: h } = o.curve.getSegment(s), d = Math.atan2(
      h.y - l.y,
      h.x - l.x
    ), m = r.element.children[0], f = 90 - d / Math.PI * 180;
    m.style.transform = `rotate(${f}deg)`;
  }
  updateMarker(e, n) {
    const { point: s, index: i, object: r } = e, o = r, l = o.curve, h = o.curve.alignment, d = h.getPercentageAt(s, this.view), m = s.clone();
    this.setMouseMarker(m, o, i, n), d !== null && this.onMarkerChange.trigger({ alignment: h, percentage: d, type: n, curve: l });
  }
  getScaledBox(e, n) {
    const s = new Box3(), i = new Vector3(), r = new Vector3();
    return e.getCenter(r), e.getSize(i), i.multiplyScalar(n), s.setFromCenterAndSize(r, i), s;
  }
};
var Ap = class {
  constructor(t, e, n) {
    T(this, "components");
    T(this, "_scene");
    T(this, "_world");
    T(this, "offset", 10);
    T(this, "markupLines", []);
    T(this, "currentCurveMesh");
    T(this, "markupMaterial", new LineBasicMaterial({
      color: 6842472
    }));
    this.components = t, this._scene = e, this._world = n;
  }
  showCurveInfo(t) {
    switch (this.disposeMarkups(), this.currentCurveMesh = t, t.curve.data.TYPE) {
      case "LINE":
        this.showLineInfo(t, this.offset);
        break;
      case "CIRCULARARC":
        this.showCircularArcInfo(t, this.offset);
        break;
      case "CLOTHOID":
        this.showClothoidInfo(t, this.offset);
        break;
      default:
        console.log("Unknown curve type:", t.curve.data.TYPE);
        break;
    }
  }
  updateOffset(t, e, n) {
    const i = Math.max(t.height, t.width) / (e * 150);
    i !== this.offset && (this.offset = i, n && this.currentCurveMesh && this.showCurveInfo(this.currentCurveMesh));
  }
  dispose() {
    for (const t of this.markupLines)
      t.removeFromParent();
    this.disposeMarkups(), this.markupMaterial.dispose();
  }
  disposeMarkups() {
    for (const t of this.markupLines)
      t.geometry.dispose(), t.removeFromParent();
    this.markupLines = [];
  }
  unSelect() {
    this.disposeMarkups();
  }
  calculateTangent(t, e) {
    const s = e * 3, i = Math.max(0, s - 3), r = Math.min(
      t.length - 3,
      s + 3
    ), o = new Vector3().fromArray(t, i);
    return new Vector3().fromArray(t, r).clone().sub(o).normalize();
  }
  calculateParallelCurve(t, e, n) {
    const s = [];
    for (let i = 0; i < e; i++) {
      const o = this.calculateTangent(t, i).clone().applyAxisAngle(new Vector3(0, 0, 1), Math.PI / 2);
      o.normalize();
      const l = o.clone().multiplyScalar(n), h = i * 3, d = new Vector3().fromArray(t, h).add(l);
      s.push(d);
    }
    return s;
  }
  calculateDimensionLines(t, e) {
    const n = [], s = t.geometry.attributes.position.array, i = e.geometry.attributes.position.array;
    if (s.length < 6 && i.length < 6)
      throw new Error("Line must have at least two vertices");
    const r = new Vector3(
      s[0],
      s[1],
      s[2]
    ), o = new Vector3(
      i[0],
      i[1],
      i[2]
    ), l = [], h = s.length - 3, d = new Vector3(
      s[h],
      s[h + 1],
      s[h + 2]
    ), m = i.length - 3, f = new Vector3(
      i[m],
      i[m + 1],
      i[m + 2]
    );
    return n.push(r, o), l.push(d, f), { startDimensionPoints: n, endDimensionPoints: l };
  }
  offsetDimensionLine(t, e) {
    const s = new Vector3().copy(t[t.length - 1]).sub(t[0]).normalize().clone().multiplyScalar(e);
    return t.map((r) => r.clone().add(s));
  }
  showLineInfo(t, e) {
    const n = this.components.get(kn);
    n.world = this._world, n.deleteByType(["Length", "Radius"]);
    const s = t.geometry.attributes.position.array, i = this.calculateParallelCurve(
      s,
      s.length / 3,
      e
    ), r = new BufferGeometry().setFromPoints(
      i
    ), o = new Line(
      r,
      this.markupMaterial
    );
    n.showLineLength(o, t.curve.getLength()), this._scene.add(o), this.markupLines.push(o);
    const { startDimensionPoints: l, endDimensionPoints: h } = this.calculateDimensionLines(t, o), d = this.offsetDimensionLine(
      l,
      e * 0.1
    ), m = this.offsetDimensionLine(
      h,
      e * 0.1
    ), f = new BufferGeometry().setFromPoints(
      d
    ), g = new BufferGeometry().setFromPoints(
      m
    ), I = new Line(
      f,
      this.markupMaterial
    );
    this._scene.add(I), this.markupLines.push(I);
    const y = new Line(
      g,
      this.markupMaterial
    );
    this._scene.add(y), this.markupLines.push(y);
  }
  showClothoidInfo(t, e) {
    const n = this.components.get(kn);
    n.world = this._world, n.deleteByType(["Length", "Radius"]);
    const s = t.geometry.attributes.position.array, i = this.calculateParallelCurve(
      s,
      s.length / 3,
      e
    ), r = new BufferGeometry().setFromPoints(
      i
    );
    n.showCurveLength(i, t.curve.getLength());
    const o = new Line(
      r,
      this.markupMaterial
    );
    this._scene.add(o), this.markupLines.push(o);
    const { startDimensionPoints: l, endDimensionPoints: h } = this.calculateDimensionLines(t, o), d = this.offsetDimensionLine(
      l,
      e * 0.1
    ), m = this.offsetDimensionLine(
      h,
      e * 0.1
    ), f = new BufferGeometry().setFromPoints(
      d
    ), g = new BufferGeometry().setFromPoints(
      m
    ), I = new Line(
      f,
      this.markupMaterial
    );
    this._scene.add(I), this.markupLines.push(I);
    const y = new Line(
      g,
      this.markupMaterial
    );
    this._scene.add(y), this.markupLines.push(y);
  }
  showCircularArcInfo(t, e) {
    const n = this.components.get(kn);
    n.world = this._world, n.deleteByType(["Length", "Radius"]);
    const s = t.curve.data.RADIUS, i = t.geometry.attributes.position.array, r = t.geometry.attributes.position.count, o = [], l = new Vector3(
      i[0],
      i[1],
      i[2]
    ), h = (r - 1) * 3, d = new Vector3(
      i[h],
      i[h + 1],
      i[h + 2]
    ), m = r / 2 * 3, f = new Vector3(
      i[m],
      i[m + 1],
      i[m + 2]
    ), g = d.clone().sub(l).normalize(), I = new Vector3(
      -g.y,
      g.x,
      0
    );
    I.multiplyScalar(s);
    const y = f.clone().add(I);
    o.push(f), o.push(y);
    const x = new BufferGeometry().setFromPoints(o), A = new Line(x, this.markupMaterial);
    n.showCurveRadius(A, Math.abs(s)), this._scene.add(A), this.markupLines.push(A);
    const F = [];
    for (let se = 0; se < r; se++) {
      const ue = this.calculateTangent(i, se), me = t.curve.data.RADIUS, Ie = new Vector3(
        ue.y,
        -ue.x,
        0
      );
      Ie.normalize(), me < 0 && Ie.negate();
      const Ee = Ie.clone().multiplyScalar(e), de = se * 3, Le = new Vector3(
        i[de] + Ee.x,
        i[de + 1] + Ee.y,
        i[de + 2] + Ee.z
      );
      F.push(Le);
    }
    const P = new BufferGeometry().setFromPoints(
      F
    );
    n.showCurveLength(F, t.curve.getLength());
    const b = new Line(
      P,
      this.markupMaterial
    );
    this._scene.add(b), this.markupLines.push(b);
    const { startDimensionPoints: O, endDimensionPoints: k } = this.calculateDimensionLines(t, b), Y = this.offsetDimensionLine(
      O,
      e * 0.1
    ), H = this.offsetDimensionLine(
      k,
      e * 0.1
    ), K = new BufferGeometry().setFromPoints(
      Y
    ), Z = new BufferGeometry().setFromPoints(
      H
    ), q = new Line(
      K,
      this.markupMaterial
    );
    this._scene.add(q), this.markupLines.push(q);
    const ne = new Line(
      Z,
      this.markupMaterial
    );
    this._scene.add(ne), this.markupLines.push(ne);
  }
};
var Lr = class Lr2 extends Rh {
  constructor(e) {
    super(e);
    T(this, "view", "horizontal");
    T(this, "planHighlighter");
    this.components.add(Lr2.uuid, this), this.onHighlight.add(({ mesh: n }) => {
      !this._highlighter || !this.planHighlighter || this.planHighlighter.showCurveInfo(n);
    });
  }
  get world() {
    return super.world;
  }
  set world(e) {
    var n;
    super.world = e, e && ((n = this.planHighlighter) == null || n.dispose(), this.planHighlighter = new Ap(
      this.components,
      e.scene.three,
      e
    ));
  }
};
T(Lr, "uuid", "3096dea0-5bc2-41c7-abce-9089b6c9431b");
var mc = Lr;
var Nr = class Nr2 extends Rh {
  constructor(e) {
    super(e);
    T(this, "view", "vertical");
    T(this, "enabled", true);
    this.components.add(Nr2.uuid, this);
  }
  get world() {
    return super.world;
  }
  set world(e) {
    this.world !== e && (super.world = e, this._highlighter && this._highlighter.onSelect.add((n) => {
      if (!this.world)
        throw new Error("A world is needed to work with this component!");
      const s = this.components.get(kn);
      s.deleteByType(["Slope", "Height", "InitialKPV", "FinalKPV"]);
      const { alignment: i } = n.curve, r = [];
      for (const d of i.vertical) {
        const m = d.mesh.geometry.attributes.position.array;
        r.push(m);
      }
      const { defSegments: o, slope: l } = this.setDefSegments(r), h = this.world.scene.three;
      for (let d = 0; d < i.vertical.length; d++) {
        const m = i.vertical[d];
        s.addVerticalMarker(
          this.world,
          `S: ${l[d].slope}%`,
          m.mesh,
          "Slope",
          h
        ), s.addVerticalMarker(
          this.world,
          `H: ${o[d].end.y.toFixed(2)}`,
          m.mesh,
          "Height",
          h
        );
      }
      s.addVerticalMarker(
        this.world,
        "KP: 0",
        i.vertical[0].mesh,
        "InitialKPV",
        h
      ), s.addVerticalMarker(
        this.world,
        `KP: ${i.vertical.length}`,
        i.vertical[i.vertical.length - 1].mesh,
        "FinalKPV",
        h
      );
    }));
  }
};
T(Nr, "uuid", "097eea29-2d5a-431a-a247-204d44670621");
var gc = Nr;
var _r = class _r2 extends Re {
  constructor(e) {
    super(e);
    T(this, "onHighlight", new $());
    T(this, "enabled", true);
    T(this, "_highlighter");
    T(this, "mouseMarkers");
    T(this, "onMarkerChange", new $());
    T(this, "onMarkerHidden", new $());
    T(this, "_curves", []);
    T(this, "_world", null);
    T(this, "updateLinesResolution", (e2) => {
      var n;
      (n = this.highlighter) == null || n.setResolution(e2);
    });
    T(this, "onClick", (e2) => {
      if (!this.enabled || !this._highlighter)
        return;
      if (!this.world)
        throw new Error("No world found!");
      if (!this.world.renderer)
        return;
      const n = this.world.renderer.three.domElement, s = this.world.camera.three, i = this._highlighter.castRay(e2, s, n, this._curves);
      if (i) {
        const r = i.object;
        this._highlighter.select(r), this.updateMarker(i, "select");
        const { point: o, index: l } = i;
        l !== void 0 && this.onHighlight.trigger({ curve: r, point: o, index: l });
        return;
      }
      this._highlighter.unSelect(), this.mouseMarkers && (this.mouseMarkers.hover.visible = false), this.onMarkerHidden.trigger({ type: "hover" });
    });
    T(this, "onMouseMove", async (e2) => {
      if (!this.enabled || !this._highlighter)
        return;
      if (!this.world)
        throw new Error("No world found!");
      if (!this.world.renderer)
        return;
      const n = this.world.renderer.three.domElement, s = this.world.camera.three, i = this._highlighter.castRay(e2, s, n, this._curves);
      if (i) {
        this._highlighter.hover(i.object), this.updateMarker(i, "hover");
        return;
      }
      this._highlighter.unHover();
    });
    this.components.add(_r2.uuid, this);
  }
  get world() {
    return this._world;
  }
  set world(e) {
    var s, i, r;
    if (e === this._world || (this._world && this.setupEvents(false), this._world = e, (s = this._highlighter) == null || s.dispose(), (i = this.mouseMarkers) == null || i.hover.dispose(), (r = this.mouseMarkers) == null || r.select.dispose(), !e))
      return;
    const n = e.scene.three;
    this._highlighter = new Fr(n, "absolute"), this.mouseMarkers = {
      select: this.newMouseMarker("#ffffff", e),
      hover: this.newMouseMarker("#575757", e)
    }, this.setupEvents(true);
  }
  get highlighter() {
    if (!this._highlighter)
      throw new Error("Navigator not initialized!");
    return this._highlighter;
  }
  draw(e) {
    if (!e.civilData)
      throw new Error("Model must have civil data!");
    if (!this.world)
      throw new Error("A world must be given before drawing an alignment!");
    const n = this.world.scene.three;
    for (const [s, i] of e.civilData.alignments)
      for (const { mesh: r } of i.absolute)
        n.add(r), this._curves.push(r);
  }
  newMouseMarker(e, n) {
    const s = n.scene.three, i = document.createElement("div");
    i.style.backgroundColor = e, i.style.width = "1rem", i.style.height = "1rem", i.style.borderRadius = "1rem";
    const r = new ft(n, i, s);
    return r.visible = false, r;
  }
  setMarker(e, n, s) {
    if (!this.mouseMarkers)
      throw new Error(
        "No mouse markers found! Initialize the world before using this."
      );
    const i = e.getPointAt(n, "absolute");
    this.mouseMarkers[s].visible = true, this.mouseMarkers[s].three.position.copy(i);
  }
  hideMarker(e) {
    if (!this.mouseMarkers)
      throw new Error(
        "No mouse markers found! Initialize the world before using this."
      );
    const n = this.mouseMarkers[e].three;
    n.visible = false;
  }
  setupEvents(e) {
    var s, i;
    if (!this.world)
      throw new Error("No world found!");
    if (this.world.isDisposing || !this.world.renderer)
      return;
    const n = this.world.renderer.three.domElement;
    (s = this.world.renderer) == null || s.onResize.remove(this.updateLinesResolution), n.removeEventListener("click", this.onClick), n.removeEventListener("mousemove", this.onMouseMove), e && (n.addEventListener("click", this.onClick), n.addEventListener("mousemove", this.onMouseMove), (i = this.world.renderer) == null || i.onResize.add(this.updateLinesResolution));
  }
  updateMarker(e, n) {
    if (!this.mouseMarkers)
      return;
    const { point: s, object: i } = e, r = i, o = r.curve, l = r.curve.alignment, h = l.getPercentageAt(s, "absolute");
    this.mouseMarkers[n].visible = true, this.mouseMarkers[n].three.position.copy(s), h !== null && this.onMarkerChange.trigger({ alignment: l, percentage: h, type: n, curve: o });
  }
};
T(_r, "uuid", "0a59c09e-2b49-474a-9320-99f51f40f182");
var Ec = _r;
var Ur = class Ur2 extends Re {
  constructor(e) {
    super(e);
    T(this, "world", null);
    T(this, "enabled", true);
    T(this, "plane");
    T(this, "_world3D", null);
    this.components.add(Ur2.uuid, this);
  }
  get world3D() {
    return this._world3D;
  }
  set world3D(e) {
    var i;
    if (this._world3D = e, (i = this.plane) == null || i.dispose(), !e)
      return;
    const n = this.components.get(Sr), s = n.Type;
    n.Type = hi, this.plane = n.createFromNormalAndCoplanarPoint(
      e,
      new Vector3(1, 0, 0),
      new Vector3()
    ), n.Type = s, this.plane.visible = false, this.plane.enabled = false;
  }
  async set(e, n) {
    if (!this.world || !this.plane)
      throw new Error("You must set a world before using this component");
    this.plane.enabled = true;
    const s = e.curve.getPercentageAt(n);
    if (s === null)
      return;
    const { startPoint: i, endPoint: r } = e.curve.getSegmentAt(s);
    if (e.geometry.index === null)
      throw new Error("Geometry must be indexed!");
    const o = new Vector3();
    o.subVectors(r, i), o.normalize(), this.plane.setFromNormalAndCoplanarPoint(o, n), this.plane.edges.update();
    const l = this.plane.helper.matrix.clone();
    l.invert();
    const h = this.world.scene.three, d = this.plane.edges.get();
    for (const m in d) {
      const { mesh: f } = d[m];
      f.position.set(0, 0, 0), f.rotation.set(0, 0, 0), f.updateMatrix(), f.applyMatrix4(l), f.parent !== h && h.add(f);
    }
    this.plane.enabled = false;
  }
};
T(Ur, "uuid", "96b2c87e-d90b-4639-8257-8f01136fe324");
var vc = Ur;
function Vn() {
  const u = document.createElement("div");
  return u.style.backgroundColor = "black", u.style.color = "white", u.style.padding = "8px", u.style.borderRadius = "8px", u.style.fontFamily = "sans-serif", u;
}
var gs = class gs2 {
  constructor(t, e, n) {
    T(this, "label");
    T(this, "boundingBox", new Mesh());
    T(this, "world");
    T(this, "components");
    T(this, "_length");
    T(this, "_visible", true);
    T(this, "_start");
    T(this, "_end");
    T(this, "_root", new Group());
    T(this, "_endpoints", []);
    T(this, "_line");
    this.components = t, this.world = e, this._start = n.start, this._end = n.end, this._length = this.getLength(), this._line = this.createLine(n), this.newEndpointElement(n.endpointElement), this.newEndpointElement(n.endpointElement.cloneNode(true)), this.label = this.newText(), this._root.renderOrder = 2, this.world.scene.three.add(this._root);
  }
  get visible() {
    return this._visible;
  }
  set visible(t) {
    this._visible = t, this.label.visible = t, this._endpoints[0].visible = t, this._endpoints[1].visible = t;
    const [e, n] = this._endpoints, s = e.three, i = n.three, r = this.label.three;
    t ? (this.world.scene.three.add(this._root), this._root.add(r, s, i)) : (r.removeFromParent(), s.removeFromParent(), i.removeFromParent(), this._root.removeFromParent());
  }
  get endPoint() {
    return this._end;
  }
  set endPoint(t) {
    this._end = t;
    const e = this._line.geometry.attributes.position;
    e.setXYZ(1, t.x, t.y, t.z), e.needsUpdate = true, this._endpoints[1].three.position.copy(t), this.updateLabel();
  }
  get startPoint() {
    return this._start;
  }
  set startPoint(t) {
    this._start = t;
    const e = this._line.geometry.attributes.position;
    e.setXYZ(0, t.x, t.y, t.z), e.needsUpdate = true, this._endpoints[0].three.position.copy(t), this.updateLabel();
  }
  get _center() {
    let t = this._end.clone().sub(this._start);
    const e = t.length() * 0.5;
    return t = t.normalize().multiplyScalar(e), this._start.clone().add(t);
  }
  dispose() {
    const t = this.components.get(rn);
    this.visible = false, t.destroy(this._root), t.destroy(this._line);
    for (const e of this._endpoints)
      e.dispose();
    this._endpoints.length = 0, this.label.dispose(), this.boundingBox && t.destroy(this.boundingBox), this.components = null;
  }
  createBoundingBox() {
    this.boundingBox.geometry = new BoxGeometry(1, 1, this._length), this.boundingBox.position.copy(this._center), this.boundingBox.lookAt(this._end), this.boundingBox.visible = false, this._root.add(this.boundingBox);
  }
  toggleLabel() {
    this.label.toggleVisibility();
  }
  newEndpointElement(t) {
    const n = this._endpoints.length === 0 ? this._start : this._end, s = new ft(this.world, t);
    s.three.position.copy(n), this._endpoints.push(s), this._root.add(s.three);
  }
  updateLabel() {
    this._length = this.getLength(), this.label.three.element.textContent = this.getTextContent(), this.label.three.position.copy(this._center), this._line.computeLineDistances();
  }
  createLine(t) {
    const e = new BufferGeometry();
    e.setFromPoints([t.start, t.end]);
    const n = new Line(e, t.lineMaterial);
    return this._root.add(n), n;
  }
  newText() {
    const t = Vn();
    t.textContent = this.getTextContent();
    const e = new ft(this.world, t);
    return e.three.position.copy(this._center), this._root.add(e.three), e;
  }
  getTextContent() {
    return `${this._length / gs2.scale} ${gs2.units}`;
  }
  getLength() {
    return parseFloat(this._start.distanceTo(this._end).toFixed(2));
  }
};
T(gs, "scale", 1), T(gs, "units", "m");
var ui = gs;
var Rp = class {
  constructor(t, e, n) {
    T(this, "enabled", true);
    T(this, "visible", true);
    T(this, "points", []);
    T(this, "workingPlane", null);
    T(this, "labelMarker");
    T(this, "world");
    T(this, "components");
    T(this, "onDisposed", new $());
    T(this, "_rotationMatrix", null);
    T(this, "_dimensionLines", []);
    T(this, "_defaultLineMaterial", new LineBasicMaterial({ color: "red" }));
    T(this, "onAreaComputed", new $());
    T(this, "onWorkingPlaneComputed", new $());
    T(this, "onPointAdded", new $());
    T(this, "onPointRemoved", new $());
    this.world = e, this.components = t;
    const s = Vn();
    this.labelMarker = new ft(e, s), this.labelMarker.visible = false, this.onPointAdded.add((i) => {
      this.points.length === 3 && !this._dimensionLines[2] && (this.addDimensionLine(i, this.points[0]), this.labelMarker.visible = true);
    }), n == null || n.forEach((i) => this.setPoint(i));
  }
  setPoint(t, e) {
    let n;
    if (e ? n = e : n = this.points.length === 0 ? 0 : this.points.length, n === 0) {
      this.points[0] = t;
      return;
    }
    if (n < 0 || n > this.points.length)
      return;
    const s = this.points.length > n;
    this.points[n] = t, this.onPointAdded.trigger(t), s || this.addDimensionLine(this.points[n - 1], t);
    const { previousLine: i, nextLine: r } = this.getLinesBetweenIndex(n);
    i && (i.endPoint = t), r && (r.startPoint = t);
  }
  removePoint(t) {
    if (this.points.length === 3)
      return;
    this.points.splice(t, 1);
    const { previousLine: e, nextLine: n } = this.getLinesBetweenIndex(t);
    n && (e.endPoint = n.endPoint), n == null || n.dispose(), this._dimensionLines.splice(t, 1), this.onPointRemoved.trigger();
  }
  toggleLabel() {
    this.labelMarker.toggleVisibility();
  }
  addDimensionLine(t, e) {
    const n = document.createElement("div");
    n.className = "w-2 h-2 bg-red-600 rounded-full";
    const s = new ui(this.components, this.world, {
      start: t,
      end: e,
      lineMaterial: this._defaultLineMaterial,
      endpointElement: n
    });
    return s.toggleLabel(), this._dimensionLines.length > 1 ? this._dimensionLines.splice(
      this._dimensionLines.length - 1,
      0,
      s
    ) : this._dimensionLines.push(s), s;
  }
  getLinesBetweenIndex(t) {
    const e = t === 0 ? this._dimensionLines.length - 1 : t - 1, n = this._dimensionLines[e], s = this._dimensionLines[t];
    return { previousLine: n, nextLine: s };
  }
  computeWorkingPlane() {
    this.workingPlane = new Plane().setFromCoplanarPoints(
      this.points[0],
      this.points[1],
      this.points[2]
    );
    const t = new Vector3(0, 1, 0), e = this.workingPlane.normal.angleTo(t), n = new Vector3().crossVectors(this.workingPlane.normal, t).normalize();
    this._rotationMatrix = new Matrix4().makeRotationAxis(
      n,
      e
    ), this.onWorkingPlaneComputed.trigger(this.workingPlane);
  }
  computeArea() {
    if (!(this._rotationMatrix && this.workingPlane))
      return this.onAreaComputed.trigger(0), 0;
    let t = 0, e = 0;
    const n = this._rotationMatrix, s = this.points.map((r) => {
      const o = r.clone().applyMatrix4(n), l = new Vector2(
        o.x,
        o.z
      );
      return t += l.x, e += l.y, l;
    }), i = Math.abs(ShapeUtils.area(s));
    return this.labelMarker.three.element.textContent = `${i.toFixed(2)} m²`, this.labelMarker.three.position.set(
      t / s.length,
      -this.workingPlane.constant,
      e / s.length
    ).applyMatrix4(n.clone().invert()), this.onAreaComputed.trigger(i), i;
  }
  dispose() {
    this.onAreaComputed.reset(), this.onWorkingPlaneComputed.reset(), this.onPointAdded.reset(), this.onPointRemoved.reset();
    for (const t of this._dimensionLines)
      t.dispose();
    this.labelMarker.dispose(), this._dimensionLines = [], this.points = [], this._rotationMatrix = null, this.workingPlane = null, this._defaultLineMaterial.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  get() {
    return {
      points: this.points,
      workingPlane: this.workingPlane,
      area: this.computeArea()
    };
  }
};
var Ba = class extends Kd {
  constructor() {
    super(...arguments);
    T(this, "onDisposed", new $());
    T(this, "marker", null);
  }
  dispose() {
    this.marker && this.marker.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  get(e) {
    const n = super.get(e);
    return n ? (this.marker || (this.marker = new ft(e)), this.marker.world !== e && (this.marker.world = e, this.marker.three.removeFromParent(), e.scene.three.add(this.marker.three)), this.marker.visible = true, this.marker.three.position.copy(n)) : this.marker && (this.marker.visible = false), n;
  }
};
var ti = class ti2 extends Re {
  constructor(e) {
    super(e);
    T(this, "onDisposed", new $());
    T(this, "list", []);
    T(this, "world");
    T(this, "_enabled", false);
    T(this, "_vertexPicker");
    T(this, "_currentAreaElement", null);
    T(this, "_clickCount", 0);
    T(this, "create", () => {
      if (!this.enabled)
        return;
      if (!this.world)
        throw new Error("World not defined for the area measurement!");
      const e2 = this._vertexPicker.get(this.world);
      if (e2) {
        if (!this._currentAreaElement) {
          const n = new Rp(this.components, this.world);
          n.onPointAdded.add(() => {
            this._clickCount === 3 && !n.workingPlane && (n.computeWorkingPlane(), this._vertexPicker.workingPlane = n.workingPlane);
          }), n.onPointRemoved.add(() => this._clickCount--), this._currentAreaElement = n;
        }
        this._currentAreaElement.setPoint(e2, this._clickCount), this._currentAreaElement.computeArea(), this._clickCount++;
      }
    });
    T(this, "onMouseMove", () => {
      if (!this.world) {
        console.log("No world given for the area measurement!");
        return;
      }
      const e2 = this._vertexPicker.get(this.world);
      e2 && this._currentAreaElement && (this._currentAreaElement.setPoint(e2, this._clickCount), this._currentAreaElement.computeArea());
    });
    T(this, "onKeydown", (e2) => {
      this.enabled && (e2.key === "z" && e2.ctrlKey && this._currentAreaElement && this._currentAreaElement.removePoint(this._clickCount - 1), e2.key === "Enter" && this._currentAreaElement && this.endCreation(), e2.key === "Escape" && (this._clickCount === 0 && !this._currentAreaElement ? this.enabled = false : this.cancelCreation()));
    });
    this.components.add(ti2.uuid, this), this._vertexPicker = new Ba(e);
  }
  set enabled(e) {
    this._enabled = e, this._vertexPicker.enabled = e, this.setupEvents(e), e || this.cancelCreation();
  }
  get enabled() {
    return this._enabled;
  }
  set workingPlane(e) {
    this._vertexPicker.workingPlane = e;
  }
  get workingPlane() {
    return this._vertexPicker.workingPlane;
  }
  dispose() {
    this.setupEvents(false), this._vertexPicker.dispose(), this._currentAreaElement && this._currentAreaElement.dispose();
    for (const e of this.list)
      e.dispose();
    this.components = null, this.onDisposed.trigger(ti2.uuid), this.onDisposed.reset();
  }
  // TODO: Implement this
  delete() {
  }
  /** Deletes all the dimensions that have been previously created. */
  deleteAll() {
    for (const e of this.list)
      e.dispose();
    this.list = [];
  }
  endCreation() {
    this._currentAreaElement && (this.list.push(this._currentAreaElement), this._currentAreaElement.removePoint(this._clickCount), this._currentAreaElement.computeWorkingPlane(), this._currentAreaElement.computeArea(), this._currentAreaElement = null), this._vertexPicker.workingPlane = null, this._clickCount = 0;
  }
  cancelCreation() {
    this._currentAreaElement && (this._currentAreaElement.dispose(), this._currentAreaElement = null), this._vertexPicker.workingPlane = null, this._clickCount = 0;
  }
  setupEvents(e) {
    if (!this.world)
      throw new Error("The area measurement needs a world to work!");
    if (this.world.isDisposing)
      return;
    if (!this.world.renderer)
      throw new Error("The world of the area measurement needs a renderer!");
    const s = this.world.renderer.three.domElement.parentElement;
    e ? (s.addEventListener("mousemove", this.onMouseMove), window.addEventListener("keydown", this.onKeydown)) : (s.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("keydown", this.onKeydown));
  }
};
T(ti, "uuid", "c453a99e-f054-4781-9060-33df617db4a5");
var Ic = ti;
var Fp = class {
  constructor(t, e) {
    T(this, "enabled", true);
    T(this, "visible", true);
    T(this, "points", []);
    T(this, "world");
    T(this, "onDisposed", new $());
    T(this, "_lineMaterial", new di({
      color: 6629591,
      linewidth: 2
    }));
    T(this, "_lineGeometry", new Rr());
    T(this, "_line", new Ih(this._lineGeometry, this._lineMaterial));
    T(this, "_labelMarker");
    T(this, "onAngleComputed", new $());
    T(this, "onPointAdded", new $());
    this.world = t;
    const n = Vn();
    this._labelMarker = new ft(t, n), this.labelMarker.visible = true, this.onPointAdded.add(() => {
      this.points.length === 1 && t.scene.three.add(this._line), this.points.length === 3 && (this.labelMarker.visible = true);
    }), this.onAngleComputed.add((s) => {
      this.labelMarker.three.element.textContent = `${s.toFixed(2)}°`, this.labelMarker.three.position.copy(
        this.points[1] ?? new Vector3()
      );
    }), e == null || e.forEach((s) => this.setPoint(s));
  }
  set lineMaterial(t) {
    this._lineMaterial.dispose(), this._lineMaterial = t, this._line.material = t, this._lineMaterial.resolution.set(window.innerWidth, window.innerHeight);
  }
  get lineMaterial() {
    return this._lineMaterial;
  }
  set labelMarker(t) {
    this._labelMarker.dispose(), this._labelMarker = t;
  }
  get labelMarker() {
    return this._labelMarker;
  }
  get angle() {
    return {
      points: this.points,
      angle: this.computeAngle()
    };
  }
  setPoint(t, e) {
    let n;
    if (e ? n = e : n = this.points.length === 0 ? 0 : this.points.length, ![0, 1, 2].includes(n))
      return;
    this.points[n] = t, this.onPointAdded.trigger(t);
    const s = this.points.map((i) => [i.x, i.y, i.z]);
    this._lineGeometry.setPositions(s.flat());
  }
  toggleLabel() {
    this.labelMarker.toggleVisibility();
  }
  computeAngle() {
    const t = this.points[0], e = this.points[1], n = this.points[2];
    if (!(t && e && n))
      return 0;
    const s = new Vector3().subVectors(e, t), i = new Vector3().subVectors(e, n), r = MathUtils.radToDeg(s.angleTo(i));
    return this.onAngleComputed.trigger(r), r;
  }
  dispose() {
    this.points = [], this.labelMarker.dispose(), this.onAngleComputed.reset(), this.onPointAdded.reset(), this.labelMarker.dispose(), this._line.removeFromParent(), this._lineMaterial.dispose(), this._lineGeometry.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
var ni = class ni2 extends Re {
  constructor(e) {
    super(e);
    T(this, "onDisposed", new $());
    T(this, "world");
    T(this, "list", []);
    T(this, "_lineMaterial");
    T(this, "_enabled", false);
    T(this, "_vertexPicker");
    T(this, "_currentAngleElement", null);
    T(this, "_clickCount", 0);
    T(this, "create", () => {
      if (!this.enabled)
        return;
      if (!this.world) {
        console.log("No world selected for angle measurement!");
        return;
      }
      const e2 = this._vertexPicker.get(this.world);
      if (e2) {
        if (!this._currentAngleElement) {
          const n = new Fp(this.world);
          n.lineMaterial = this.lineMaterial, this._currentAngleElement = n;
        }
        this._currentAngleElement.setPoint(e2, this._clickCount), this._currentAngleElement.setPoint(
          e2,
          this._clickCount + 1
        ), this._currentAngleElement.setPoint(
          e2,
          this._clickCount + 2
        ), this._currentAngleElement.computeAngle(), this._clickCount++, this._clickCount === 3 && this.endCreation();
      }
    });
    T(this, "onMouseMove", () => {
      if (!this.world) {
        console.log("No world selected for angle measurement!");
        return;
      }
      const e2 = this._vertexPicker.get(this.world);
      e2 && this._currentAngleElement && (this._currentAngleElement.setPoint(e2, this._clickCount), this._currentAngleElement.computeAngle());
    });
    T(this, "onKeyDown", (e2) => {
      this.enabled && e2.key === "Escape" && this.cancelCreation();
    });
    this.components.add(ni2.uuid, this), this._vertexPicker = new Ba(e), this._lineMaterial = new di({
      color: 6629591,
      linewidth: 2
    });
  }
  set lineMaterial(e) {
    this._lineMaterial.dispose(), this._lineMaterial = e, this._lineMaterial.resolution.set(window.innerWidth, window.innerHeight);
  }
  get lineMaterial() {
    return this._lineMaterial;
  }
  set enabled(e) {
    this._enabled = e, this.setupEvents(e), this._vertexPicker.enabled = e, e || this.cancelCreation();
  }
  get enabled() {
    return this._enabled;
  }
  set workingPlane(e) {
    this._vertexPicker.workingPlane = e;
  }
  get workingPlane() {
    return this._vertexPicker.workingPlane;
  }
  dispose() {
    this.setupEvents(false), this._lineMaterial.dispose(), this._vertexPicker.dispose();
    for (const e of this.list)
      e.dispose();
    this._currentAngleElement && this._currentAngleElement.dispose(), this.components = null, this.onDisposed.trigger(ni2.uuid), this.onDisposed.reset();
  }
  // TODO: Implement this
  delete() {
  }
  /** Deletes all the dimensions that have been previously created. */
  deleteAll() {
    for (const e of this.list)
      e.dispose();
    this.list = [];
  }
  endCreation() {
    this._currentAngleElement && (this.list.push(this._currentAngleElement), this._currentAngleElement.computeAngle(), this._currentAngleElement = null), this._clickCount = 0;
  }
  cancelCreation() {
    this._currentAngleElement && (this._currentAngleElement.dispose(), this._currentAngleElement = null), this._clickCount = 0;
  }
  setupEvents(e) {
    if (!this.world)
      throw new Error("No world selected for angle measurement!");
    if (this.world.isDisposing)
      return;
    if (!this.world.renderer)
      throw new Error("The given world doesn't have a renderer!");
    const s = this.world.renderer.three.domElement.parentElement;
    e ? (s.addEventListener("mousemove", this.onMouseMove), window.addEventListener("keydown", this.onKeyDown)) : (s.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("keydown", this.onKeyDown));
  }
};
T(ni, "uuid", "622fb2c9-528c-4b0a-8a0e-6a1375f0a3aa");
var yc = ni;
var si = class si2 extends Re {
  constructor(e) {
    super(e);
    T(this, "onDisposed", new $());
    T(this, "onBeforeUpdate", new $());
    T(this, "onAfterUpdate", new $());
    T(this, "snapDistance", 0.25);
    T(this, "_vertexPicker");
    T(this, "_lineMaterial", new LineBasicMaterial({
      color: "#DC2626",
      linewidth: 2,
      depthTest: false
    }));
    T(this, "list", []);
    T(this, "world");
    T(this, "_visible", true);
    T(this, "_enabled", false);
    T(this, "_temp", {
      isDragging: false,
      start: new Vector3(),
      end: new Vector3(),
      dimension: void 0
    });
    T(this, "create", (e2) => {
      const n = e2 instanceof Object3D ? e2 : void 0;
      if (this._enabled) {
        if (!this._temp.isDragging) {
          this.drawStart(n);
          return;
        }
        this.endCreation();
      }
    });
    T(this, "onMouseMove", () => {
      this.world && this._vertexPicker.get(this.world);
    });
    this.components.add(si2.uuid, this), this._vertexPicker = new Ba(e, {
      previewElement: Vn(),
      snapDistance: this.snapDistance
    });
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    e || this.cancelCreation(), this._enabled = e, this._vertexPicker.enabled = e, this.setupEvents(e);
  }
  get visible() {
    return this._visible;
  }
  set visible(e) {
    this._visible = e;
    for (const n of this.list)
      n.visible = e;
  }
  get color() {
    return this._lineMaterial.color;
  }
  set color(e) {
    this._lineMaterial.color = e;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.enabled = false;
    for (const e of this.list)
      e.dispose();
    this._lineMaterial.dispose(), this.list = [], this._vertexPicker.dispose(), this.onDisposed.trigger(si2.uuid), this.onDisposed.reset();
  }
  async update(e) {
    this._enabled && this._temp.isDragging && this.drawInProcess();
  }
  createOnPoints(e, n) {
    const s = this.drawDimension();
    s.startPoint = e, s.endPoint = n, s.createBoundingBox(), this.list.push(s);
  }
  /** Deletes the dimension that the user is hovering over with the mouse or touch event. */
  delete() {
    if (!this.world)
      throw new Error("World is needed for Length Measurement!");
    if (!this._enabled || this.list.length === 0)
      return;
    const e = this.getBoundingBoxes(), i = this.components.get(Dt).get(this.world).castRay(e);
    if (!i)
      return;
    const r = this.list.find(
      (o) => o.boundingBox === i.object
    );
    if (r) {
      const o = this.list.indexOf(r);
      this.list.splice(o, 1), r.dispose();
    }
  }
  async deleteMeasurement(e) {
    if (e) {
      const n = this.list.indexOf(e);
      this.list.splice(n, 1), e.dispose();
    }
  }
  /** Deletes all the dimensions that have been previously created. */
  deleteAll() {
    for (const e of this.list)
      e.dispose();
    this.list = [];
  }
  /** Cancels the drawing of the current dimension. */
  cancelCreation() {
    var e;
    this._temp.dimension && (this._temp.isDragging = false, (e = this._temp.dimension) == null || e.dispose(), this._temp.dimension = void 0);
  }
  drawStart(e) {
    if (!this.world)
      throw new Error("The length measurement needs a world to work!");
    const n = e ? [e] : void 0, r = this.components.get(Dt).get(this.world).castRay(n), o = this._vertexPicker.get(this.world);
    r && o && (this._temp.isDragging = true, this._temp.start = e ? r.point : o);
  }
  drawInProcess() {
    if (!this.world)
      throw new Error("The length measurement needs a world to work!");
    if (!this.components.get(Dt).get(this.world).castRay())
      return;
    const i = this._vertexPicker.get(this.world);
    i && (this._temp.end = i, this._temp.dimension || (this._temp.dimension = this.drawDimension()), this._temp.dimension.endPoint = this._temp.end);
  }
  endCreation() {
    this._temp.dimension && (this._temp.dimension.createBoundingBox(), this.list.push(this._temp.dimension), this._temp.dimension = void 0, this._temp.isDragging = false);
  }
  drawDimension() {
    if (!this.world)
      throw new Error("The length measurement needs a world to work!");
    return new ui(this.components, this.world, {
      start: this._temp.start,
      end: this._temp.end,
      lineMaterial: this._lineMaterial,
      endpointElement: Vn()
    });
  }
  getBoundingBoxes() {
    return this.list.map((e) => e.boundingBox).filter((e) => e !== void 0);
  }
  setupEvents(e) {
    if (!this.world)
      throw new Error("The length measurement needs a world to work!");
    if (this.world.isDisposing)
      return;
    if (!this.world.renderer)
      throw new Error("The world of the length measurement needs a renderer!");
    const s = this.world.renderer.three.domElement.parentElement;
    s && (s.removeEventListener("mousemove", this.onMouseMove), e && s.addEventListener("mousemove", this.onMouseMove));
  }
};
T(si, "uuid", "2f9bcacf-18a9-4be6-a293-e898eae64ea1");
var Un = si;
var Br = class Br2 extends Re {
  constructor(e) {
    super(e);
    T(this, "label", null);
    T(this, "world");
    T(this, "onVolumeFound", new $());
    T(this, "_enabled", false);
    T(this, "onDisposed", new $());
    T(this, "create", () => {
      if (!this.enabled)
        return;
      if (!this.world)
        throw new Error("World is needed for Volume Measurement!");
      const s = this.components.get(Dt).get(this.world).castRay();
      if (!s || !s.object)
        return;
      const { object: i } = s;
      if (i instanceof Mesh) {
        const r = this.getVolumeOfMesh(i);
        this.onVolumeFound.trigger(r);
      }
    });
    T(this, "onMouseMove", () => {
    });
    T(this, "onKeydown", (e2) => {
    });
    this.components.add(Br2.uuid, this);
  }
  set enabled(e) {
    this._enabled = e, this.setupEvents(e), e || this.cancelCreation();
  }
  get enabled() {
    return this._enabled;
  }
  async dispose() {
    var e;
    this.setupEvents(false), (e = this.label) == null || e.dispose(), this.onDisposed.trigger(), this.onDisposed.reset(), this.components = null;
  }
  delete() {
  }
  /** Deletes all the dimensions that have been previously created. */
  async deleteAll() {
  }
  endCreation() {
  }
  cancelCreation() {
  }
  get() {
  }
  getVolumeFromFragments(e) {
    const n = this.components.get(We), s = new Matrix4(), i = [];
    for (const r in e) {
      const o = n.list.get(r);
      if (!o)
        continue;
      const l = e[r];
      let h = 0;
      for (const f of l) {
        const g = o.getInstancesIDs(f);
        g && (h += g.size);
      }
      const d = new InstancedMesh(
        o.mesh.geometry,
        void 0,
        h
      );
      let m = 0;
      for (const f of l) {
        const g = o.getInstancesIDs(f);
        if (g)
          for (const I of g)
            o.mesh.getMatrixAt(I, s), d.setMatrixAt(m++, s);
      }
      i.push(d);
    }
    return this.getVolumeFromMeshes(i);
  }
  getVolumeFromMeshes(e) {
    if (!this.world)
      throw new Error("World is needed for Volume Measurement!");
    this.label || (this.label = this.newLabel(), this.label.three.removeFromParent());
    let n = 0;
    for (const o of e)
      n += this.getVolumeOfMesh(o);
    this.label.visible = true, this.world.scene.three.add(this.label.three);
    const s = this.components.get($c);
    for (const o of e)
      o.geometry.computeBoundingSphere(), s.addMesh(o);
    const i = s.getSphere();
    s.reset(), this.label.three.position.copy(i.center);
    const r = Math.trunc(n * 100) / 100;
    return this.label.three.element.textContent = r.toString(), n;
  }
  clear() {
    this.label && (this.label.visible = false);
  }
  newLabel() {
    if (!this.world)
      throw new Error("World is needed for Volume Measurement!");
    const e = Vn();
    return new ft(this.world, e);
  }
  setupEvents(e) {
    if (!this.world)
      throw new Error("The volume measurement needs a world to work!");
    if (this.world.isDisposing)
      return;
    if (!this.world.renderer)
      throw new Error("The world of the volume measurement needs a renderer!");
    const s = this.world.renderer.three.domElement.parentElement;
    e ? (s.addEventListener("click", this.create), s.addEventListener("mousemove", this.onMouseMove), window.addEventListener("keydown", this.onKeydown)) : (s.removeEventListener("click", this.create), s.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("keydown", this.onKeydown));
  }
  // https://stackoverflow.com/a/1568551
  getVolumeOfMesh(e) {
    let n = 0;
    const s = new Vector3(), i = new Vector3(), r = new Vector3(), { index: o } = e.geometry, l = e.geometry.attributes.position.array;
    if (!o)
      return console.warn("Geometry must be indexed to compute its volume!"), 0;
    const h = [];
    if (e instanceof InstancedMesh)
      for (let m = 0; m < e.count; m++) {
        const f = new Matrix4();
        e.getMatrixAt(m, f), h.push(f);
      }
    else
      h.push(new Matrix4().identity());
    const { matrixWorld: d } = e;
    for (let m = 0; m < o.array.length - 2; m += 3)
      for (const f of h) {
        const g = f.multiply(d), I = o.array[m] * 3, y = o.array[m + 1] * 3, x = o.array[m + 2] * 3;
        s.set(l[I], l[I + 1], l[I + 2]).applyMatrix4(g), i.set(l[y], l[y + 1], l[y + 2]).applyMatrix4(g), r.set(l[x], l[x + 1], l[x + 2]).applyMatrix4(g), n += this.getSignedVolumeOfTriangle(s, i, r);
      }
    return Math.abs(n);
  }
  getSignedVolumeOfTriangle(e, n, s) {
    const i = s.x * n.y * e.z, r = n.x * s.y * e.z, o = s.x * e.y * n.z, l = e.x * s.y * n.z, h = n.x * e.y * s.z, d = e.x * n.y * s.z;
    return 1 / 6 * (-i + r + o - l - h + d);
  }
};
T(Br, "uuid", "811da532-7af3-4635-b592-1c06ae494af5");
var wc = Br;
var kr = class kr2 extends Re {
  constructor(e) {
    super(e);
    T(this, "selection", []);
    T(this, "preview", new Mesh(
      new BufferGeometry(),
      new MeshBasicMaterial({
        side: 2,
        depthTest: false,
        transparent: true,
        opacity: 0.25,
        color: "#BCF124"
      })
    ));
    T(this, "selectionMaterial", new MeshBasicMaterial({
      side: 2,
      depthTest: false,
      transparent: true,
      color: "#BCF124",
      opacity: 0.75
    }));
    T(this, "world");
    T(this, "onDisposed", new $());
    T(this, "_enabled", false);
    T(this, "_currentSelelection", null);
    T(this, "create", () => {
      if (!this.world)
        throw new Error("No world given to the face measurement!");
      if (!this.enabled || !this._currentSelelection)
        return;
      const e2 = this.world.scene.three, n = new BufferGeometry(), s = new Mesh(n, this.selectionMaterial);
      n.setAttribute(
        "position",
        this.preview.geometry.attributes.position
      ), e2.add(s), n.computeBoundingSphere();
      const { area: i, perimeter: r } = this._currentSelelection, o = this.newLabel(n, i);
      s.add(o.three), this.selection.push({ area: i, perimeter: r, mesh: s, label: o });
    });
    T(this, "onMouseMove", () => {
      if (!this.world)
        throw new Error("The face measurement needs a world to work!");
      if (!this.enabled) {
        this.unselect();
        return;
      }
      const s = this.components.get(Dt).get(this.world).castRay();
      if (!s || !s.object || s.faceIndex === void 0) {
        this.unselect();
        return;
      }
      const { object: i, faceIndex: r } = s;
      i instanceof Mesh || i instanceof InstancedMesh ? this.updateSelection(i, r, s.instanceId) : this.unselect();
    });
    T(this, "onKeydown", (e2) => {
    });
    this.components.add(kr2.uuid, this), this.preview.frustumCulled = false;
  }
  set enabled(e) {
    if (!this.world)
      throw new Error("No world given for the Face measurement!");
    this._enabled = e, this.setupEvents(e), e ? this.world.scene.three.add(this.preview) : (this.preview.removeFromParent(), this.cancelCreation()), this.setVisibility(e);
  }
  get enabled() {
    return this._enabled;
  }
  dispose() {
    this.setupEvents(false), this.deleteAll(), this.preview.removeFromParent(), this.preview.material.dispose(), this.preview.geometry.dispose(), this.selectionMaterial.dispose(), this.onDisposed.trigger(), this.onDisposed.reset(), this.components = null;
  }
  delete() {
    if (!this.world)
      throw new Error("No world given to the face measurement!");
    const e = this.selection.map((l) => l.mesh), i = this.components.get(Dt).get(this.world).castRay(e);
    if (!i || !i.object)
      return;
    const r = this.selection.find((l) => l.mesh === i.object);
    if (!r)
      return;
    r.mesh.removeFromParent(), r.mesh.geometry.dispose(), r.label.dispose();
    const o = this.selection.indexOf(r);
    this.selection.splice(o, 1);
  }
  deleteAll() {
    for (const e of this.selection)
      e.mesh.removeFromParent(), e.mesh.geometry.dispose(), e.label.dispose();
    this.selection = [];
  }
  endCreation() {
  }
  cancelCreation() {
  }
  get() {
    const e = [];
    for (const n of this.selection) {
      const s = n.mesh.geometry, { area: i, perimeter: r } = n, o = s.attributes.position.array;
      e.push({ position: o, area: i, perimeter: r });
    }
    return e;
  }
  set(e) {
    if (!this.world)
      throw new Error("No world given to the face measurement!");
    const n = this.world.scene.three;
    for (const s of e) {
      const i = new BufferGeometry(), r = new Mesh(i, this.selectionMaterial);
      n.add(r);
      const o = new BufferAttribute(s.position, 3);
      i.setAttribute("position", o), i.computeBoundingSphere();
      const { area: l, perimeter: h } = s, d = this.newLabel(i, l);
      r.add(d.three), this.selection.push({ area: l, perimeter: h, mesh: r, label: d });
    }
  }
  setupEvents(e) {
    if (!this.world)
      throw new Error("The face measurement needs a world to work!");
    if (this.world.isDisposing)
      return;
    if (!this.world.renderer)
      throw new Error("The world of the face measurement needs a renderer!");
    const s = this.world.renderer.three.domElement.parentElement;
    s.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("keydown", this.onKeydown), e && (s.addEventListener("mousemove", this.onMouseMove), window.addEventListener("keydown", this.onKeydown));
  }
  setVisibility(e) {
    if (!this.world)
      throw new Error("The face measurement needs a world to work!");
    const n = this.world.scene.three;
    for (const s of this.selection) {
      const i = s.label.three;
      e ? (n.add(s.mesh), s.mesh.add(i)) : (s.mesh.removeFromParent(), i.removeFromParent());
    }
  }
  unselect() {
    this.preview.removeFromParent(), this._currentSelelection = null;
  }
  updateSelection(e, n, s) {
    if (!this.world)
      throw new Error("The face measurement needs a world to work!");
    this.world.scene.three.add(this.preview);
    const o = this.components.get(Ar).getFace(e, n, s);
    if (o === null)
      return;
    const l = this.regenerateHighlight(e, o.indices, s);
    let h = 0;
    for (const { distance: d } of o.edges)
      h += d;
    this._currentSelelection = { perimeter: h, area: l };
  }
  newLabel(e, n) {
    if (!e.boundingSphere)
      throw new Error("Error computing area geometry");
    if (!this.world)
      throw new Error("The face measurement needs a world to work!");
    const { center: s } = e.boundingSphere, i = Vn(), r = Math.trunc(n * 100) / 100;
    i.textContent = r.toString();
    const o = new ft(this.world, i);
    return o.three.position.copy(s), o;
  }
  regenerateHighlight(e, n, s) {
    const i = [], r = [];
    let o = 0, l = 0;
    const h = new Triangle(), d = this.components.get(Ar);
    for (const g of n) {
      const { p1: I, p2: y, p3: x } = d.getVerticesAndNormal(
        e,
        g,
        s
      );
      i.push(I.x, I.y, I.z), i.push(y.x, y.y, y.z), i.push(x.x, x.y, x.z), h.set(I, y, x), l += h.getArea(), r.push(o, o + 1, o + 2), o += 3;
    }
    const m = new Float32Array(i), f = new BufferAttribute(m, 3);
    return this.preview.geometry.setAttribute("position", f), this.preview.geometry.setIndex(r), l;
  }
};
T(kr, "uuid", "30279548-1309-44f6-aa97-ce26eed73522");
var Cc = kr;
var zr = class zr2 extends Re {
  constructor(e) {
    super(e);
    T(this, "preview");
    T(this, "tolerance", 0.3);
    T(this, "world");
    T(this, "onDisposed", new $());
    T(this, "_enabled", false);
    T(this, "_lineMaterial", new LineBasicMaterial({
      color: "#DC2626",
      linewidth: 2,
      depthTest: false,
      transparent: true
    }));
    T(this, "create", async () => {
      if (!this.preview || !this.enabled || !this.preview.visible)
        return;
      const e2 = this.components.get(Un);
      e2.world = this.world;
      const n = this.preview.startPoint.clone(), s = this.preview.endPoint.clone();
      e2.createOnPoints(n, s);
    });
    T(this, "onMouseMove", () => {
      if (!this.preview)
        return;
      if (!this.world)
        throw new Error("The edge measurement needs a world to work!");
      if (!this.enabled) {
        this.preview.visible = false;
        return;
      }
      const s = this.components.get(Dt).get(this.world).castRay();
      if (!s || !s.object) {
        this.preview.visible = false;
        return;
      }
      const { object: i, faceIndex: r, point: o } = s;
      if (r === void 0) {
        this.preview.visible = false;
        return;
      }
      i instanceof Mesh || i instanceof InstancedMesh ? this.updateSelection(i, o, r, s.instanceId) : this.preview.visible = false;
    });
    T(this, "onKeydown", (e2) => {
    });
    this.components.add(zr2.uuid, this);
  }
  set enabled(e) {
    if (this._enabled = e, this.setupEvents(e), e) {
      if (!this.world)
        throw new Error("The edge measurement needs a world to work!");
      if (!this.preview) {
        const n = document.createElement("div");
        n.className = "w-2 h-2 bg-red-600 rounded-full", this.preview = new ui(this.components, this.world, {
          start: new Vector3(),
          end: new Vector3(),
          lineMaterial: this._lineMaterial,
          endpointElement: n
        }), this.preview.visible = false;
      }
    } else
      this.cancelCreation();
  }
  get enabled() {
    return this._enabled;
  }
  dispose() {
    this.preview && this.preview.dispose(), this._lineMaterial.dispose(), this.setupEvents(false), this.onDisposed.trigger(), this.onDisposed.reset(), this.components = null;
  }
  // TODO: this could be better. Fusion this class with lengthmeasurement?
  delete() {
    if (!this.enabled)
      return;
    const e = this.components.get(Un), n = e.enabled;
    e.enabled = true, e.delete(), e.enabled = n;
  }
  deleteAll() {
    this.components.get(Un).deleteAll();
  }
  endCreation() {
  }
  cancelCreation() {
  }
  get() {
    const n = this.components.get(Un).list, s = [];
    for (const i of n) {
      const r = i.startPoint, o = i.endPoint, l = [r.x, r.y, r.z, o.x, o.y, o.z];
      s.push(l);
    }
    return s;
  }
  set(e) {
    const n = this.components.get(Un);
    n.world = this.world;
    for (const s of e) {
      const [i, r, o, l, h, d] = s, m = new Vector3(i, r, o), f = new Vector3(l, h, d);
      n.createOnPoints(m, f);
    }
  }
  setupEvents(e) {
    if (!this.world)
      throw new Error("The edge measurement needs a world to work!");
    if (this.world.isDisposing)
      return;
    if (!this.world.renderer)
      throw new Error("The world of the edge measurement needs a renderer!");
    const s = this.world.renderer.three.domElement.parentElement;
    e ? (s.addEventListener("mousemove", this.onMouseMove), window.addEventListener("keydown", this.onKeydown)) : (s.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("keydown", this.onKeydown));
  }
  updateSelection(e, n, s, i) {
    if (!this.preview || !e.geometry.index)
      return;
    const o = this.components.get(Ar).getFace(e, s, i);
    if (!o)
      return;
    const { edges: l } = o;
    let h = Number.MAX_VALUE, d = [];
    for (const g of l) {
      const [I, y] = g.points, x = Ar.distanceFromPointToLine(
        n,
        I,
        y,
        true
      );
      x < this.tolerance && x < h && (h = x, d = g.points);
    }
    if (!d.length) {
      this.preview.visible = false;
      return;
    }
    const [m, f] = d;
    this.preview.startPoint = m, this.preview.endPoint = f, this.preview.visible = true;
  }
};
T(zr, "uuid", "e7be5749-89df-4514-8d25-83aa38ce12d8");
var Tc = zr;
var Pp = class extends Zc {
  constructor(e, n, s) {
    super(e, n, s);
    T(this, "threshold", 50);
    T(this, "bboxThreshold", 200);
    T(this, "maxLostTime", 3e4);
    T(this, "maxHiddenTime", 5e3);
    T(this, "boxes", /* @__PURE__ */ new Map());
    T(this, "_geometry");
    T(this, "_material", new MeshBasicMaterial({
      transparent: true,
      side: 2,
      opacity: 1
    }));
    T(this, "onViewUpdated", new yn());
    T(this, "_modelIDIndex", /* @__PURE__ */ new Map());
    T(this, "_indexModelID", /* @__PURE__ */ new Map());
    T(this, "_nextModelID", 0);
    T(this, "_geometries", /* @__PURE__ */ new Map());
    T(this, "_geometriesGroups", /* @__PURE__ */ new Map());
    T(this, "_foundGeometries", /* @__PURE__ */ new Set());
    T(this, "_intervalID", null);
    T(this, "codes", /* @__PURE__ */ new Map());
    T(this, "handleWorkerMessage", async (e2) => {
      const n2 = e2.data.colors, s2 = {}, i2 = {}, r = {}, o = {}, l = performance.now();
      let h = false;
      const d = new Set(this._foundGeometries);
      for (const [m, f] of n2) {
        const g = this._geometries.get(m);
        if (!g)
          continue;
        const I = f > this.threshold, { exists: y } = g;
        if (!I && !y)
          continue;
        const x = this._indexModelID.get(g.modelIndex);
        d.delete(m), I && y ? (g.time = l, o[x] || (o[x] = /* @__PURE__ */ new Set()), o[x].add(g.geometryID), this._foundGeometries.add(m), h = true) : I && !y ? (s2[x] || (s2[x] = /* @__PURE__ */ new Map()), g.time = l, g.exists = true, s2[x].has(f) || s2[x].set(f, /* @__PURE__ */ new Set()), s2[x].get(f).add(g.geometryID), this._foundGeometries.add(m), h = true) : !I && y && (this.handleLostGeometries(l, m, g, i2, r), h = true);
      }
      h && await this.onViewUpdated.trigger({ toLoad: s2, toRemove: i2, toHide: r, toShow: o }), this._isWorkerBusy = false;
    });
    this.updateInterval = 500, this._geometry = new BoxGeometry(1, 1, 1), this._geometry.groups = [], this._geometry.deleteAttribute("uv");
    const i = this._geometry.attributes.position.array;
    for (let r = 0; r < i.length; r++)
      i[r] += 0.5;
    this._geometry.attributes.position.needsUpdate = true, this.worker.addEventListener("message", this.handleWorkerMessage), this.autoUpdate && (this._intervalID = window.setInterval(
      this.updateVisibility,
      this.updateInterval
    ));
  }
  dispose() {
    super.dispose(), this.onViewUpdated.reset(), this._intervalID !== null && (window.clearInterval(this._intervalID), this._intervalID = null);
    for (const [e, n] of this._geometriesGroups) {
      n.removeFromParent();
      const s = [...n.children];
      for (const i of s)
        i.removeFromParent();
    }
    this._geometriesGroups.clear();
    for (const [e, n] of this.boxes)
      n.dispose(true);
    this.boxes.clear();
    for (const [e, n] of this._geometries)
      n.fragment && (n.fragment.dispose(true), n.fragment = void 0);
    this._geometries.clear(), this._geometry.dispose(), this._material.dispose(), this._modelIDIndex.clear(), this._indexModelID.clear(), this.codes.clear();
  }
  add(e, n, s) {
    const i = this.createModelIndex(e), r = ColorManagement.enabled;
    ColorManagement.enabled = false;
    const o = /* @__PURE__ */ new Map(), l = new Matrix4(), h = new Ni(this._geometry, this._material, 10);
    this.boxes.set(i, h), this.scene.add(h.mesh);
    const d = new Group();
    this.scene.add(d), this._geometriesGroups.set(i, d);
    const m = /* @__PURE__ */ new Map();
    for (const g of n)
      for (const I of g.geometries) {
        const { geometryID: y, transformation: x, color: A } = I, F = new Color();
        F.setRGB(A[0], A[1], A[2], "srgb");
        const P = this.getInstanceID(g.id, y), b = s[y];
        if (!b) {
          console.log(`Geometry not found: ${y}`);
          continue;
        }
        const { boundingBox: O } = b;
        let k;
        o.has(y) ? k = o.get(y) : (k = this.getAvailableColor(), this.increaseColor(), o.set(y, k));
        const { r: Y, g: H, b: K, code: Z } = k, q = new Color();
        q.setRGB(Y / 255, H / 255, K / 255, "srgb"), this.codes.has(i) || this.codes.set(i, /* @__PURE__ */ new Map()), this.codes.get(i).set(y, Z);
        const se = new Matrix4(), ue = Object.values(O);
        if (se.fromArray(x), l.fromArray(ue), se.multiply(l), m.has(P)) {
          const me = m.get(P);
          if (me === void 0 || !me.colors)
            throw new Error("Malformed item!");
          me.colors.push(q), me.geometryColors.push(F), me.transforms.push(se);
        } else
          m.set(P, {
            id: P,
            colors: [q],
            geometryColors: [F],
            transforms: [se]
          });
        if (this._geometries.has(Z))
          this._geometries.get(Z).assetIDs.add(g.id);
        else {
          const me = /* @__PURE__ */ new Set([g.id]);
          this._geometries.set(Z, {
            modelIndex: i,
            geometryID: y,
            assetIDs: me,
            exists: false,
            hidden: false,
            time: 0
          });
        }
      }
    const f = Array.from(m.values());
    h.add(f), ColorManagement.enabled = r;
  }
  remove(e) {
    const n = this._modelIDIndex.get(e);
    if (n === void 0)
      throw new Error("Model doesn't exist!");
    const s = this._geometriesGroups.get(n);
    s.removeFromParent();
    const i = [...s.children];
    for (const l of i)
      l.removeFromParent();
    this._geometriesGroups.delete(n), this.boxes.get(n).dispose(false), this.boxes.delete(n);
    const o = this.codes.get(n);
    this.codes.delete(n);
    for (const [l, h] of o) {
      const d = this._geometries.get(h);
      d && d.fragment && (d.fragment.dispose(false), d.fragment = void 0), this._geometries.delete(h);
    }
    this._modelIDIndex.delete(e), this._indexModelID.delete(n), this._foundGeometries.clear();
  }
  addFragment(e, n, s) {
    const i = ColorManagement.enabled;
    ColorManagement.enabled = false;
    const r = this._modelIDIndex.get(e), l = this.codes.get(r).get(n), h = this._geometries.get(l);
    if (this.setGeometryVisibility(h, false, false), !h.fragment) {
      h.fragment = new Ni(
        s.mesh.geometry,
        this._material,
        s.capacity
      );
      const I = this._geometriesGroups.get(r);
      if (!I)
        throw new Error("Group not found!");
      I.add(h.fragment.mesh);
    }
    const [d, m, f] = l.split("-").map((I) => parseInt(I, 10)), g = [];
    for (const I of s.ids) {
      const y = s.get(I);
      if (!y.colors)
        throw new Error("Malformed fragments!");
      for (const x of y.colors)
        x.setRGB(d / 255, m / 255, f / 255, "srgb");
      g.push(y);
    }
    h.fragment.add(g), ColorManagement.enabled = i, this.needsUpdate = true;
  }
  removeFragment(e, n) {
    const s = this._modelIDIndex.get(e), r = this.codes.get(s).get(n), o = this._geometries.get(r);
    if (o.hidden || this.setGeometryVisibility(o, true, false), o.fragment) {
      const { fragment: l } = o;
      l.dispose(false), o.fragment = void 0;
    }
  }
  setModelTransformation(e, n) {
    const s = this._modelIDIndex.get(e);
    if (s === void 0)
      throw new Error("Model not found!");
    const i = this.boxes.get(s);
    i && (i.mesh.position.set(0, 0, 0), i.mesh.rotation.set(0, 0, 0), i.mesh.scale.set(1, 1, 1), i.mesh.applyMatrix4(n));
    const r = this._geometriesGroups.get(s);
    r && (r.position.set(0, 0, 0), r.rotation.set(0, 0, 0), r.scale.set(1, 1, 1), r.applyMatrix4(n));
  }
  setVisibility(e, n, s) {
    const i = this._modelIDIndex.get(n);
    if (i !== void 0)
      for (const [r, o] of s) {
        const l = this.codes.get(i);
        if (l === void 0)
          throw new Error("Map not found!");
        const h = l.get(r), d = this._geometries.get(h);
        if (d === void 0)
          throw new Error("Geometry not found!");
        d.hidden = !e, this.setGeometryVisibility(d, e, true, o);
      }
  }
  setGeometryVisibility(e, n, s, i) {
    const { modelIndex: r, geometryID: o, assetIDs: l } = e, h = this.boxes.get(r);
    if (h === void 0)
      throw new Error("Model not found!");
    const d = i || l;
    if (s && e.fragment)
      e.fragment.setVisibility(n, d);
    else {
      const m = /* @__PURE__ */ new Set();
      for (const f of d) {
        const g = this.getInstanceID(f, o);
        m.add(g);
      }
      h.setVisibility(n, m);
    }
  }
  handleLostGeometries(e, n, s, i, r) {
    const o = this._indexModelID.get(s.modelIndex), l = e - s.time;
    l > this.maxLostTime ? (i[o] || (i[o] = /* @__PURE__ */ new Set()), s.exists = false, i[o].add(s.geometryID), this._foundGeometries.delete(n)) : l > this.maxHiddenTime && (r[o] || (r[o] = /* @__PURE__ */ new Set()), r[o].add(s.geometryID));
  }
  createModelIndex(e) {
    if (this._modelIDIndex.has(e))
      throw new Error("Can't load the same model twice!");
    const n = this._nextModelID;
    return this._nextModelID++, this._modelIDIndex.set(e, n), this._indexModelID.set(n, e), n;
  }
  getInstanceID(e, n) {
    const i = 10 ** (Math.log(n) * Math.LOG10E + 1 | 0);
    return e + n / i;
  }
};
var Fh = { exports: {} };
(function(u, t) {
  (function(e, n) {
    u.exports = n();
  })(uc, function() {
    var e = function(a, c) {
      return (e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(p, E) {
        p.__proto__ = E;
      } || function(p, E) {
        for (var v in E)
          Object.prototype.hasOwnProperty.call(E, v) && (p[v] = E[v]);
      })(a, c);
    }, n = function() {
      return (n = Object.assign || function(a) {
        for (var c, p = 1, E = arguments.length; p < E; p++)
          for (var v in c = arguments[p])
            Object.prototype.hasOwnProperty.call(c, v) && (a[v] = c[v]);
        return a;
      }).apply(this, arguments);
    };
    function s(a, c, p) {
      for (var E, v = 0, C = c.length; v < C; v++)
        !E && v in c || ((E = E || Array.prototype.slice.call(c, 0, v))[v] = c[v]);
      return a.concat(E || Array.prototype.slice.call(c));
    }
    var i = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : uc, r = Object.keys, o = Array.isArray;
    function l(a, c) {
      return typeof c != "object" || r(c).forEach(function(p) {
        a[p] = c[p];
      }), a;
    }
    typeof Promise > "u" || i.Promise || (i.Promise = Promise);
    var h = Object.getPrototypeOf, d = {}.hasOwnProperty;
    function m(a, c) {
      return d.call(a, c);
    }
    function f(a, c) {
      typeof c == "function" && (c = c(h(a))), (typeof Reflect > "u" ? r : Reflect.ownKeys)(c).forEach(function(p) {
        I(a, p, c[p]);
      });
    }
    var g = Object.defineProperty;
    function I(a, c, p, E) {
      g(a, c, l(p && m(p, "get") && typeof p.get == "function" ? { get: p.get, set: p.set, configurable: true } : { value: p, configurable: true, writable: true }, E));
    }
    function y(a) {
      return { from: function(c) {
        return a.prototype = Object.create(c.prototype), I(a.prototype, "constructor", a), { extend: f.bind(null, a.prototype) };
      } };
    }
    var x = Object.getOwnPropertyDescriptor, A = [].slice;
    function F(a, c, p) {
      return A.call(a, c, p);
    }
    function P(a, c) {
      return c(a);
    }
    function b(a) {
      if (!a)
        throw new Error("Assertion Failed");
    }
    function O(a) {
      i.setImmediate ? setImmediate(a) : setTimeout(a, 0);
    }
    function k(a, c) {
      if (typeof c == "string" && m(a, c))
        return a[c];
      if (!c)
        return a;
      if (typeof c != "string") {
        for (var p = [], E = 0, v = c.length; E < v; ++E) {
          var C = k(a, c[E]);
          p.push(C);
        }
        return p;
      }
      var R = c.indexOf(".");
      if (R !== -1) {
        var M = a[c.substr(0, R)];
        return M == null ? void 0 : k(M, c.substr(R + 1));
      }
    }
    function Y(a, c, p) {
      if (a && c !== void 0 && !("isFrozen" in Object && Object.isFrozen(a)))
        if (typeof c != "string" && "length" in c) {
          b(typeof p != "string" && "length" in p);
          for (var E = 0, v = c.length; E < v; ++E)
            Y(a, c[E], p[E]);
        } else {
          var C, R, M = c.indexOf(".");
          M !== -1 ? (C = c.substr(0, M), (R = c.substr(M + 1)) === "" ? p === void 0 ? o(a) && !isNaN(parseInt(C)) ? a.splice(C, 1) : delete a[C] : a[C] = p : Y(M = !(M = a[C]) || !m(a, C) ? a[C] = {} : M, R, p)) : p === void 0 ? o(a) && !isNaN(parseInt(c)) ? a.splice(c, 1) : delete a[c] : a[c] = p;
        }
    }
    function H(a) {
      var c, p = {};
      for (c in a)
        m(a, c) && (p[c] = a[c]);
      return p;
    }
    var K = [].concat;
    function Z(a) {
      return K.apply([], a);
    }
    var Jt = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(Z([8, 16, 32, 64].map(function(a) {
      return ["Int", "Uint", "Float"].map(function(c) {
        return c + a + "Array";
      });
    }))).filter(function(a) {
      return i[a];
    }), q = new Set(Jt.map(function(a) {
      return i[a];
    })), ne = null;
    function se(a) {
      return ne = /* @__PURE__ */ new WeakMap(), a = function c(p) {
        if (!p || typeof p != "object")
          return p;
        var E = ne.get(p);
        if (E)
          return E;
        if (o(p)) {
          E = [], ne.set(p, E);
          for (var v = 0, C = p.length; v < C; ++v)
            E.push(c(p[v]));
        } else if (q.has(p.constructor))
          E = p;
        else {
          var R, M = h(p);
          for (R in E = M === Object.prototype ? {} : Object.create(M), ne.set(p, E), p)
            m(p, R) && (E[R] = c(p[R]));
        }
        return E;
      }(a), ne = null, a;
    }
    var ue = {}.toString;
    function me(a) {
      return ue.call(a).slice(8, -1);
    }
    var Ie = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", Ee = typeof Ie == "symbol" ? function(a) {
      var c;
      return a != null && (c = a[Ie]) && c.apply(a);
    } : function() {
      return null;
    };
    function de(a, c) {
      return c = a.indexOf(c), 0 <= c && a.splice(c, 1), 0 <= c;
    }
    var Le = {};
    function we(a) {
      var c, p, E, v;
      if (arguments.length === 1) {
        if (o(a))
          return a.slice();
        if (this === Le && typeof a == "string")
          return [a];
        if (v = Ee(a)) {
          for (p = []; !(E = v.next()).done; )
            p.push(E.value);
          return p;
        }
        if (a == null)
          return [a];
        if (typeof (c = a.length) != "number")
          return [a];
        for (p = new Array(c); c--; )
          p[c] = a[c];
        return p;
      }
      for (c = arguments.length, p = new Array(c); c--; )
        p[c] = arguments[c];
      return p;
    }
    var Ke = typeof Symbol < "u" ? function(a) {
      return a[Symbol.toStringTag] === "AsyncFunction";
    } : function() {
      return false;
    }, bs = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], It = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(bs), Nt = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
    function vt(a, c) {
      this.name = a, this.message = c;
    }
    function ys(a, c) {
      return a + ". Errors: " + Object.keys(c).map(function(p) {
        return c[p].toString();
      }).filter(function(p, E, v) {
        return v.indexOf(p) === E;
      }).join(`
`);
    }
    function Tn(a, c, p, E) {
      this.failures = c, this.failedKeys = E, this.successCount = p, this.message = ys(a, c);
    }
    function Zt(a, c) {
      this.name = "BulkError", this.failures = Object.keys(c).map(function(p) {
        return c[p];
      }), this.failuresByPos = c, this.message = ys(a, this.failures);
    }
    y(vt).from(Error).extend({ toString: function() {
      return this.name + ": " + this.message;
    } }), y(Tn).from(vt), y(Zt).from(vt);
    var Qt = It.reduce(function(a, c) {
      return a[c] = c + "Error", a;
    }, {}), je = vt, pe = It.reduce(function(a, c) {
      var p = c + "Error";
      function E(v, C) {
        this.name = p, v ? typeof v == "string" ? (this.message = "".concat(v).concat(C ? `
 ` + C : ""), this.inner = C || null) : typeof v == "object" && (this.message = "".concat(v.name, " ").concat(v.message), this.inner = v) : (this.message = Nt[c] || p, this.inner = null);
      }
      return y(E).from(je), a[c] = E, a;
    }, {});
    pe.Syntax = SyntaxError, pe.Type = TypeError, pe.Range = RangeError;
    var Ge = bs.reduce(function(a, c) {
      return a[c + "Error"] = pe[c], a;
    }, {}), St = It.reduce(function(a, c) {
      return ["Syntax", "Type", "Range"].indexOf(c) === -1 && (a[c + "Error"] = pe[c]), a;
    }, {});
    function Oe() {
    }
    function _t(a) {
      return a;
    }
    function qr(a, c) {
      return a == null || a === _t ? c : function(p) {
        return c(a(p));
      };
    }
    function At(a, c) {
      return function() {
        a.apply(this, arguments), c.apply(this, arguments);
      };
    }
    function ws(a, c) {
      return a === Oe ? c : function() {
        var p = a.apply(this, arguments);
        p !== void 0 && (arguments[0] = p);
        var E = this.onsuccess, v = this.onerror;
        this.onsuccess = null, this.onerror = null;
        var C = c.apply(this, arguments);
        return E && (this.onsuccess = this.onsuccess ? At(E, this.onsuccess) : E), v && (this.onerror = this.onerror ? At(v, this.onerror) : v), C !== void 0 ? C : p;
      };
    }
    function Cs(a, c) {
      return a === Oe ? c : function() {
        a.apply(this, arguments);
        var p = this.onsuccess, E = this.onerror;
        this.onsuccess = this.onerror = null, c.apply(this, arguments), p && (this.onsuccess = this.onsuccess ? At(p, this.onsuccess) : p), E && (this.onerror = this.onerror ? At(E, this.onerror) : E);
      };
    }
    function Ph(a, c) {
      return a === Oe ? c : function(p) {
        var E = a.apply(this, arguments);
        l(p, E);
        var v = this.onsuccess, C = this.onerror;
        return this.onsuccess = null, this.onerror = null, p = c.apply(this, arguments), v && (this.onsuccess = this.onsuccess ? At(v, this.onsuccess) : v), C && (this.onerror = this.onerror ? At(C, this.onerror) : C), E === void 0 ? p === void 0 ? void 0 : p : l(E, p);
      };
    }
    function Mh(a, c) {
      return a === Oe ? c : function() {
        return c.apply(this, arguments) !== false && a.apply(this, arguments);
      };
    }
    function Jr(a, c) {
      return a === Oe ? c : function() {
        var p = a.apply(this, arguments);
        if (p && typeof p.then == "function") {
          for (var E = this, v = arguments.length, C = new Array(v); v--; )
            C[v] = arguments[v];
          return p.then(function() {
            return c.apply(E, C);
          });
        }
        return c.apply(this, arguments);
      };
    }
    St.ModifyError = Tn, St.DexieError = vt, St.BulkError = Zt;
    var Ut = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
    function ka(a) {
      Ut = a;
    }
    var Ts = {}, za = 100, Jt = typeof Promise > "u" ? [] : function() {
      var a = Promise.resolve();
      if (typeof crypto > "u" || !crypto.subtle)
        return [a, h(a), a];
      var c = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
      return [c, h(c), a];
    }(), bs = Jt[0], It = Jt[1], Jt = Jt[2], It = It && It.then, xs = bs && bs.constructor, $r = !!Jt, Ss = function(a, c) {
      As.push([a, c]), pi && (queueMicrotask(Dh), pi = false);
    }, eo = true, pi = true, bn = [], mi = [], to = _t, on = { id: "global", global: true, ref: 0, unhandleds: [], onunhandled: Oe, pgp: false, env: {}, finalize: Oe }, ge = on, As = [], xn = 0, gi = [];
    function he(a) {
      if (typeof this != "object")
        throw new TypeError("Promises must be constructed via new");
      this._listeners = [], this._lib = false;
      var c = this._PSD = ge;
      if (typeof a != "function") {
        if (a !== Ts)
          throw new TypeError("Not a function");
        return this._state = arguments[1], this._value = arguments[2], void (this._state === false && so(this, this._value));
      }
      this._state = null, this._value = null, ++c.ref, function p(E, v) {
        try {
          v(function(C) {
            if (E._state === null) {
              if (C === E)
                throw new TypeError("A promise cannot be resolved with itself.");
              var R = E._lib && Gn();
              C && typeof C.then == "function" ? p(E, function(M, _) {
                C instanceof he ? C._then(M, _) : C.then(M, _);
              }) : (E._state = true, E._value = C, Ga(E)), R && Yn();
            }
          }, so.bind(null, E));
        } catch (C) {
          so(E, C);
        }
      }(this, a);
    }
    var no = { get: function() {
      var a = ge, c = yi;
      function p(E, v) {
        var C = this, R = !a.global && (a !== ge || c !== yi), M = R && !ln(), _ = new he(function(L, z) {
          io(C, new Va(Ha(E, a, R, M), Ha(v, a, R, M), L, z, a));
        });
        return this._consoleTask && (_._consoleTask = this._consoleTask), _;
      }
      return p.prototype = Ts, p;
    }, set: function(a) {
      I(this, "then", a && a.prototype === Ts ? no : { get: function() {
        return a;
      }, set: no.set });
    } };
    function Va(a, c, p, E, v) {
      this.onFulfilled = typeof a == "function" ? a : null, this.onRejected = typeof c == "function" ? c : null, this.resolve = p, this.reject = E, this.psd = v;
    }
    function so(a, c) {
      var p, E;
      mi.push(c), a._state === null && (p = a._lib && Gn(), c = to(c), a._state = false, a._value = c, E = a, bn.some(function(v) {
        return v._value === E._value;
      }) || bn.push(E), Ga(a), p && Yn());
    }
    function Ga(a) {
      var c = a._listeners;
      a._listeners = [];
      for (var p = 0, E = c.length; p < E; ++p)
        io(a, c[p]);
      var v = a._PSD;
      --v.ref || v.finalize(), xn === 0 && (++xn, Ss(function() {
        --xn == 0 && ro();
      }, []));
    }
    function io(a, c) {
      if (a._state !== null) {
        var p = a._state ? c.onFulfilled : c.onRejected;
        if (p === null)
          return (a._state ? c.resolve : c.reject)(a._value);
        ++c.psd.ref, ++xn, Ss(Oh, [p, a, c]);
      } else
        a._listeners.push(c);
    }
    function Oh(a, c, p) {
      try {
        var E, v = c._value;
        !c._state && mi.length && (mi = []), E = Ut && c._consoleTask ? c._consoleTask.run(function() {
          return a(v);
        }) : a(v), c._state || mi.indexOf(v) !== -1 || function(C) {
          for (var R = bn.length; R; )
            if (bn[--R]._value === C._value)
              return bn.splice(R, 1);
        }(c), p.resolve(E);
      } catch (C) {
        p.reject(C);
      } finally {
        --xn == 0 && ro(), --p.psd.ref || p.psd.finalize();
      }
    }
    function Dh() {
      Sn(on, function() {
        Gn() && Yn();
      });
    }
    function Gn() {
      var a = eo;
      return pi = eo = false, a;
    }
    function Yn() {
      var a, c, p;
      do
        for (; 0 < As.length; )
          for (a = As, As = [], p = a.length, c = 0; c < p; ++c) {
            var E = a[c];
            E[0].apply(null, E[1]);
          }
      while (0 < As.length);
      pi = eo = true;
    }
    function ro() {
      var a = bn;
      bn = [], a.forEach(function(E) {
        E._PSD.onunhandled.call(null, E._value, E);
      });
      for (var c = gi.slice(0), p = c.length; p; )
        c[--p]();
    }
    function Ei(a) {
      return new he(Ts, false, a);
    }
    function ze(a, c) {
      var p = ge;
      return function() {
        var E = Gn(), v = ge;
        try {
          return cn(p, true), a.apply(this, arguments);
        } catch (C) {
          c && c(C);
        } finally {
          cn(v, false), E && Yn();
        }
      };
    }
    f(he.prototype, { then: no, _then: function(a, c) {
      io(this, new Va(null, null, a, c, ge));
    }, catch: function(a) {
      if (arguments.length === 1)
        return this.then(null, a);
      var c = a, p = arguments[1];
      return typeof c == "function" ? this.then(null, function(E) {
        return (E instanceof c ? p : Ei)(E);
      }) : this.then(null, function(E) {
        return (E && E.name === c ? p : Ei)(E);
      });
    }, finally: function(a) {
      return this.then(function(c) {
        return he.resolve(a()).then(function() {
          return c;
        });
      }, function(c) {
        return he.resolve(a()).then(function() {
          return Ei(c);
        });
      });
    }, timeout: function(a, c) {
      var p = this;
      return a < 1 / 0 ? new he(function(E, v) {
        var C = setTimeout(function() {
          return v(new pe.Timeout(c));
        }, a);
        p.then(E, v).finally(clearTimeout.bind(null, C));
      }) : this;
    } }), typeof Symbol < "u" && Symbol.toStringTag && I(he.prototype, Symbol.toStringTag, "Dexie.Promise"), on.env = Ya(), f(he, { all: function() {
      var a = we.apply(null, arguments).map(wi);
      return new he(function(c, p) {
        a.length === 0 && c([]);
        var E = a.length;
        a.forEach(function(v, C) {
          return he.resolve(v).then(function(R) {
            a[C] = R, --E || c(a);
          }, p);
        });
      });
    }, resolve: function(a) {
      return a instanceof he ? a : a && typeof a.then == "function" ? new he(function(c, p) {
        a.then(c, p);
      }) : new he(Ts, true, a);
    }, reject: Ei, race: function() {
      var a = we.apply(null, arguments).map(wi);
      return new he(function(c, p) {
        a.map(function(E) {
          return he.resolve(E).then(c, p);
        });
      });
    }, PSD: { get: function() {
      return ge;
    }, set: function(a) {
      return ge = a;
    } }, totalEchoes: { get: function() {
      return yi;
    } }, newPSD: an, usePSD: Sn, scheduler: { get: function() {
      return Ss;
    }, set: function(a) {
      Ss = a;
    } }, rejectionMapper: { get: function() {
      return to;
    }, set: function(a) {
      to = a;
    } }, follow: function(a, c) {
      return new he(function(p, E) {
        return an(function(v, C) {
          var R = ge;
          R.unhandleds = [], R.onunhandled = C, R.finalize = At(function() {
            var M, _ = this;
            M = function() {
              _.unhandleds.length === 0 ? v() : C(_.unhandleds[0]);
            }, gi.push(function L() {
              M(), gi.splice(gi.indexOf(L), 1);
            }), ++xn, Ss(function() {
              --xn == 0 && ro();
            }, []);
          }, R.finalize), a();
        }, c, p, E);
      });
    } }), xs && (xs.allSettled && I(he, "allSettled", function() {
      var a = we.apply(null, arguments).map(wi);
      return new he(function(c) {
        a.length === 0 && c([]);
        var p = a.length, E = new Array(p);
        a.forEach(function(v, C) {
          return he.resolve(v).then(function(R) {
            return E[C] = { status: "fulfilled", value: R };
          }, function(R) {
            return E[C] = { status: "rejected", reason: R };
          }).then(function() {
            return --p || c(E);
          });
        });
      });
    }), xs.any && typeof AggregateError < "u" && I(he, "any", function() {
      var a = we.apply(null, arguments).map(wi);
      return new he(function(c, p) {
        a.length === 0 && p(new AggregateError([]));
        var E = a.length, v = new Array(E);
        a.forEach(function(C, R) {
          return he.resolve(C).then(function(M) {
            return c(M);
          }, function(M) {
            v[R] = M, --E || p(new AggregateError(v));
          });
        });
      });
    }));
    var qe = { awaits: 0, echoes: 0, id: 0 }, Lh = 0, vi = [], Ii = 0, yi = 0, Nh = 0;
    function an(a, c, p, E) {
      var v = ge, C = Object.create(v);
      return C.parent = v, C.ref = 0, C.global = false, C.id = ++Nh, on.env, C.env = $r ? { Promise: he, PromiseProp: { value: he, configurable: true, writable: true }, all: he.all, race: he.race, allSettled: he.allSettled, any: he.any, resolve: he.resolve, reject: he.reject } : {}, c && l(C, c), ++v.ref, C.finalize = function() {
        --this.parent.ref || this.parent.finalize();
      }, E = Sn(C, a, p, E), C.ref === 0 && C.finalize(), E;
    }
    function Hn() {
      return qe.id || (qe.id = ++Lh), ++qe.awaits, qe.echoes += za, qe.id;
    }
    function ln() {
      return !!qe.awaits && (--qe.awaits == 0 && (qe.id = 0), qe.echoes = qe.awaits * za, true);
    }
    function wi(a) {
      return qe.echoes && a && a.constructor === xs ? (Hn(), a.then(function(c) {
        return ln(), c;
      }, function(c) {
        return ln(), Xe(c);
      })) : a;
    }
    function _h() {
      var a = vi[vi.length - 1];
      vi.pop(), cn(a, false);
    }
    function cn(a, c) {
      var p, E = ge;
      (c ? !qe.echoes || Ii++ && a === ge : !Ii || --Ii && a === ge) || queueMicrotask(c ? (function(v) {
        ++yi, qe.echoes && --qe.echoes != 0 || (qe.echoes = qe.awaits = qe.id = 0), vi.push(ge), cn(v, true);
      }).bind(null, a) : _h), a !== ge && (ge = a, E === on && (on.env = Ya()), $r && (p = on.env.Promise, c = a.env, (E.global || a.global) && (Object.defineProperty(i, "Promise", c.PromiseProp), p.all = c.all, p.race = c.race, p.resolve = c.resolve, p.reject = c.reject, c.allSettled && (p.allSettled = c.allSettled), c.any && (p.any = c.any))));
    }
    function Ya() {
      var a = i.Promise;
      return $r ? { Promise: a, PromiseProp: Object.getOwnPropertyDescriptor(i, "Promise"), all: a.all, race: a.race, allSettled: a.allSettled, any: a.any, resolve: a.resolve, reject: a.reject } : {};
    }
    function Sn(a, c, p, E, v) {
      var C = ge;
      try {
        return cn(a, true), c(p, E, v);
      } finally {
        cn(C, false);
      }
    }
    function Ha(a, c, p, E) {
      return typeof a != "function" ? a : function() {
        var v = ge;
        p && Hn(), cn(c, true);
        try {
          return a.apply(this, arguments);
        } finally {
          cn(v, false), E && queueMicrotask(ln);
        }
      };
    }
    function oo(a) {
      Promise === xs && qe.echoes === 0 ? Ii === 0 ? a() : enqueueNativeMicroTask(a) : setTimeout(a, 0);
    }
    ("" + It).indexOf("[native code]") === -1 && (Hn = ln = Oe);
    var Xe = he.reject, An = "￿", qt = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Wa = "String expected.", Wn = [], Ci = "__dbnames", ao = "readonly", lo = "readwrite";
    function Rn(a, c) {
      return a ? c ? function() {
        return a.apply(this, arguments) && c.apply(this, arguments);
      } : a : c;
    }
    var Ka = { type: 3, lower: -1 / 0, lowerOpen: false, upper: [[]], upperOpen: false };
    function Ti(a) {
      return typeof a != "string" || /\./.test(a) ? function(c) {
        return c;
      } : function(c) {
        return c[a] === void 0 && a in c && delete (c = se(c))[a], c;
      };
    }
    function ja() {
      throw pe.Type();
    }
    function Me(a, c) {
      try {
        var p = Xa(a), E = Xa(c);
        if (p !== E)
          return p === "Array" ? 1 : E === "Array" ? -1 : p === "binary" ? 1 : E === "binary" ? -1 : p === "string" ? 1 : E === "string" ? -1 : p === "Date" ? 1 : E !== "Date" ? NaN : -1;
        switch (p) {
          case "number":
          case "Date":
          case "string":
            return c < a ? 1 : a < c ? -1 : 0;
          case "binary":
            return function(v, C) {
              for (var R = v.length, M = C.length, _ = R < M ? R : M, L = 0; L < _; ++L)
                if (v[L] !== C[L])
                  return v[L] < C[L] ? -1 : 1;
              return R === M ? 0 : R < M ? -1 : 1;
            }(Za(a), Za(c));
          case "Array":
            return function(v, C) {
              for (var R = v.length, M = C.length, _ = R < M ? R : M, L = 0; L < _; ++L) {
                var z = Me(v[L], C[L]);
                if (z !== 0)
                  return z;
              }
              return R === M ? 0 : R < M ? -1 : 1;
            }(a, c);
        }
      } catch {
      }
      return NaN;
    }
    function Xa(a) {
      var c = typeof a;
      return c != "object" ? c : ArrayBuffer.isView(a) ? "binary" : (a = me(a), a === "ArrayBuffer" ? "binary" : a);
    }
    function Za(a) {
      return a instanceof Uint8Array ? a : ArrayBuffer.isView(a) ? new Uint8Array(a.buffer, a.byteOffset, a.byteLength) : new Uint8Array(a);
    }
    var Qa = (Be.prototype._trans = function(a, c, p) {
      var E = this._tx || ge.trans, v = this.name, C = Ut && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(a === "readonly" ? "read" : "write", " ").concat(this.name));
      function R(L, z, D) {
        if (!D.schema[v])
          throw new pe.NotFound("Table " + v + " not part of transaction");
        return c(D.idbtrans, D);
      }
      var M = Gn();
      try {
        var _ = E && E.db._novip === this.db._novip ? E === ge.trans ? E._promise(a, R, p) : an(function() {
          return E._promise(a, R, p);
        }, { trans: E, transless: ge.transless || ge }) : function L(z, D, V, N) {
          if (z.idbdb && (z._state.openComplete || ge.letThrough || z._vip)) {
            var B = z._createTransaction(D, V, z._dbSchema);
            try {
              B.create(), z._state.PR1398_maxLoop = 3;
            } catch (G) {
              return G.name === Qt.InvalidState && z.isOpen() && 0 < --z._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), z.close({ disableAutoOpen: false }), z.open().then(function() {
                return L(z, D, V, N);
              })) : Xe(G);
            }
            return B._promise(D, function(G, U) {
              return an(function() {
                return ge.trans = B, N(G, U, B);
              });
            }).then(function(G) {
              if (D === "readwrite")
                try {
                  B.idbtrans.commit();
                } catch {
                }
              return D === "readonly" ? G : B._completion.then(function() {
                return G;
              });
            });
          }
          if (z._state.openComplete)
            return Xe(new pe.DatabaseClosed(z._state.dbOpenError));
          if (!z._state.isBeingOpened) {
            if (!z._state.autoOpen)
              return Xe(new pe.DatabaseClosed());
            z.open().catch(Oe);
          }
          return z._state.dbReadyPromise.then(function() {
            return L(z, D, V, N);
          });
        }(this.db, a, [this.name], R);
        return C && (_._consoleTask = C, _ = _.catch(function(L) {
          return console.trace(L), Xe(L);
        })), _;
      } finally {
        M && Yn();
      }
    }, Be.prototype.get = function(a, c) {
      var p = this;
      return a && a.constructor === Object ? this.where(a).first(c) : a == null ? Xe(new pe.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(E) {
        return p.core.get({ trans: E, key: a }).then(function(v) {
          return p.hook.reading.fire(v);
        });
      }).then(c);
    }, Be.prototype.where = function(a) {
      if (typeof a == "string")
        return new this.db.WhereClause(this, a);
      if (o(a))
        return new this.db.WhereClause(this, "[".concat(a.join("+"), "]"));
      var c = r(a);
      if (c.length === 1)
        return this.where(c[0]).equals(a[c[0]]);
      var p = this.schema.indexes.concat(this.schema.primKey).filter(function(_) {
        if (_.compound && c.every(function(z) {
          return 0 <= _.keyPath.indexOf(z);
        })) {
          for (var L = 0; L < c.length; ++L)
            if (c.indexOf(_.keyPath[L]) === -1)
              return false;
          return true;
        }
        return false;
      }).sort(function(_, L) {
        return _.keyPath.length - L.keyPath.length;
      })[0];
      if (p && this.db._maxKey !== An) {
        var R = p.keyPath.slice(0, c.length);
        return this.where(R).equals(R.map(function(L) {
          return a[L];
        }));
      }
      !p && Ut && console.warn("The query ".concat(JSON.stringify(a), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(c.join("+"), "]"));
      var E = this.schema.idxByName, v = this.db._deps.indexedDB;
      function C(_, L) {
        return v.cmp(_, L) === 0;
      }
      var M = c.reduce(function(V, L) {
        var z = V[0], D = V[1], V = E[L], N = a[L];
        return [z || V, z || !V ? Rn(D, V && V.multi ? function(B) {
          return B = k(B, L), o(B) && B.some(function(G) {
            return C(N, G);
          });
        } : function(B) {
          return C(N, k(B, L));
        }) : D];
      }, [null, null]), R = M[0], M = M[1];
      return R ? this.where(R.name).equals(a[R.keyPath]).filter(M) : p ? this.filter(M) : this.where(c).equals("");
    }, Be.prototype.filter = function(a) {
      return this.toCollection().and(a);
    }, Be.prototype.count = function(a) {
      return this.toCollection().count(a);
    }, Be.prototype.offset = function(a) {
      return this.toCollection().offset(a);
    }, Be.prototype.limit = function(a) {
      return this.toCollection().limit(a);
    }, Be.prototype.each = function(a) {
      return this.toCollection().each(a);
    }, Be.prototype.toArray = function(a) {
      return this.toCollection().toArray(a);
    }, Be.prototype.toCollection = function() {
      return new this.db.Collection(new this.db.WhereClause(this));
    }, Be.prototype.orderBy = function(a) {
      return new this.db.Collection(new this.db.WhereClause(this, o(a) ? "[".concat(a.join("+"), "]") : a));
    }, Be.prototype.reverse = function() {
      return this.toCollection().reverse();
    }, Be.prototype.mapToClass = function(a) {
      var c, p = this.db, E = this.name;
      function v() {
        return c !== null && c.apply(this, arguments) || this;
      }
      (this.schema.mappedClass = a).prototype instanceof ja && (function(_, L) {
        if (typeof L != "function" && L !== null)
          throw new TypeError("Class extends value " + String(L) + " is not a constructor or null");
        function z() {
          this.constructor = _;
        }
        e(_, L), _.prototype = L === null ? Object.create(L) : (z.prototype = L.prototype, new z());
      }(v, c = a), Object.defineProperty(v.prototype, "db", { get: function() {
        return p;
      }, enumerable: false, configurable: true }), v.prototype.table = function() {
        return E;
      }, a = v);
      for (var C = /* @__PURE__ */ new Set(), R = a.prototype; R; R = h(R))
        Object.getOwnPropertyNames(R).forEach(function(_) {
          return C.add(_);
        });
      function M(_) {
        if (!_)
          return _;
        var L, z = Object.create(a.prototype);
        for (L in _)
          if (!C.has(L))
            try {
              z[L] = _[L];
            } catch {
            }
        return z;
      }
      return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = M, this.hook("reading", M), a;
    }, Be.prototype.defineClass = function() {
      return this.mapToClass(function(a) {
        l(this, a);
      });
    }, Be.prototype.add = function(a, c) {
      var p = this, E = this.schema.primKey, v = E.auto, C = E.keyPath, R = a;
      return C && v && (R = Ti(C)(a)), this._trans("readwrite", function(M) {
        return p.core.mutate({ trans: M, type: "add", keys: c != null ? [c] : null, values: [R] });
      }).then(function(M) {
        return M.numFailures ? he.reject(M.failures[0]) : M.lastResult;
      }).then(function(M) {
        if (C)
          try {
            Y(a, C, M);
          } catch {
          }
        return M;
      });
    }, Be.prototype.update = function(a, c) {
      return typeof a != "object" || o(a) ? this.where(":id").equals(a).modify(c) : (a = k(a, this.schema.primKey.keyPath), a === void 0 ? Xe(new pe.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(a).modify(c));
    }, Be.prototype.put = function(a, c) {
      var p = this, E = this.schema.primKey, v = E.auto, C = E.keyPath, R = a;
      return C && v && (R = Ti(C)(a)), this._trans("readwrite", function(M) {
        return p.core.mutate({ trans: M, type: "put", values: [R], keys: c != null ? [c] : null });
      }).then(function(M) {
        return M.numFailures ? he.reject(M.failures[0]) : M.lastResult;
      }).then(function(M) {
        if (C)
          try {
            Y(a, C, M);
          } catch {
          }
        return M;
      });
    }, Be.prototype.delete = function(a) {
      var c = this;
      return this._trans("readwrite", function(p) {
        return c.core.mutate({ trans: p, type: "delete", keys: [a] });
      }).then(function(p) {
        return p.numFailures ? he.reject(p.failures[0]) : void 0;
      });
    }, Be.prototype.clear = function() {
      var a = this;
      return this._trans("readwrite", function(c) {
        return a.core.mutate({ trans: c, type: "deleteRange", range: Ka });
      }).then(function(c) {
        return c.numFailures ? he.reject(c.failures[0]) : void 0;
      });
    }, Be.prototype.bulkGet = function(a) {
      var c = this;
      return this._trans("readonly", function(p) {
        return c.core.getMany({ keys: a, trans: p }).then(function(E) {
          return E.map(function(v) {
            return c.hook.reading.fire(v);
          });
        });
      });
    }, Be.prototype.bulkAdd = function(a, c, p) {
      var E = this, v = Array.isArray(c) ? c : void 0, C = (p = p || (v ? void 0 : c)) ? p.allKeys : void 0;
      return this._trans("readwrite", function(R) {
        var L = E.schema.primKey, M = L.auto, L = L.keyPath;
        if (L && v)
          throw new pe.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
        if (v && v.length !== a.length)
          throw new pe.InvalidArgument("Arguments objects and keys must have the same length");
        var _ = a.length, L = L && M ? a.map(Ti(L)) : a;
        return E.core.mutate({ trans: R, type: "add", keys: v, values: L, wantResults: C }).then(function(B) {
          var D = B.numFailures, V = B.results, N = B.lastResult, B = B.failures;
          if (D === 0)
            return C ? V : N;
          throw new Zt("".concat(E.name, ".bulkAdd(): ").concat(D, " of ").concat(_, " operations failed"), B);
        });
      });
    }, Be.prototype.bulkPut = function(a, c, p) {
      var E = this, v = Array.isArray(c) ? c : void 0, C = (p = p || (v ? void 0 : c)) ? p.allKeys : void 0;
      return this._trans("readwrite", function(R) {
        var L = E.schema.primKey, M = L.auto, L = L.keyPath;
        if (L && v)
          throw new pe.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
        if (v && v.length !== a.length)
          throw new pe.InvalidArgument("Arguments objects and keys must have the same length");
        var _ = a.length, L = L && M ? a.map(Ti(L)) : a;
        return E.core.mutate({ trans: R, type: "put", keys: v, values: L, wantResults: C }).then(function(B) {
          var D = B.numFailures, V = B.results, N = B.lastResult, B = B.failures;
          if (D === 0)
            return C ? V : N;
          throw new Zt("".concat(E.name, ".bulkPut(): ").concat(D, " of ").concat(_, " operations failed"), B);
        });
      });
    }, Be.prototype.bulkUpdate = function(a) {
      var c = this, p = this.core, E = a.map(function(R) {
        return R.key;
      }), v = a.map(function(R) {
        return R.changes;
      }), C = [];
      return this._trans("readwrite", function(R) {
        return p.getMany({ trans: R, keys: E, cache: "clone" }).then(function(M) {
          var _ = [], L = [];
          a.forEach(function(D, V) {
            var N = D.key, B = D.changes, G = M[V];
            if (G) {
              for (var U = 0, W = Object.keys(B); U < W.length; U++) {
                var j = W[U], X = B[j];
                if (j === c.schema.primKey.keyPath) {
                  if (Me(X, N) !== 0)
                    throw new pe.Constraint("Cannot update primary key in bulkUpdate()");
                } else
                  Y(G, j, X);
              }
              C.push(V), _.push(N), L.push(G);
            }
          });
          var z = _.length;
          return p.mutate({ trans: R, type: "put", keys: _, values: L, updates: { keys: E, changeSpecs: v } }).then(function(D) {
            var V = D.numFailures, N = D.failures;
            if (V === 0)
              return z;
            for (var B = 0, G = Object.keys(N); B < G.length; B++) {
              var U, W = G[B], j = C[Number(W)];
              j != null && (U = N[W], delete N[W], N[j] = U);
            }
            throw new Zt("".concat(c.name, ".bulkUpdate(): ").concat(V, " of ").concat(z, " operations failed"), N);
          });
        });
      });
    }, Be.prototype.bulkDelete = function(a) {
      var c = this, p = a.length;
      return this._trans("readwrite", function(E) {
        return c.core.mutate({ trans: E, type: "delete", keys: a });
      }).then(function(R) {
        var v = R.numFailures, C = R.lastResult, R = R.failures;
        if (v === 0)
          return C;
        throw new Zt("".concat(c.name, ".bulkDelete(): ").concat(v, " of ").concat(p, " operations failed"), R);
      });
    }, Be);
    function Be() {
    }
    function Rs(a) {
      function c(R, M) {
        if (M) {
          for (var _ = arguments.length, L = new Array(_ - 1); --_; )
            L[_ - 1] = arguments[_];
          return p[R].subscribe.apply(null, L), a;
        }
        if (typeof R == "string")
          return p[R];
      }
      var p = {};
      c.addEventType = C;
      for (var E = 1, v = arguments.length; E < v; ++E)
        C(arguments[E]);
      return c;
      function C(R, M, _) {
        if (typeof R != "object") {
          var L;
          M = M || Mh;
          var z = { subscribers: [], fire: _ = _ || Oe, subscribe: function(D) {
            z.subscribers.indexOf(D) === -1 && (z.subscribers.push(D), z.fire = M(z.fire, D));
          }, unsubscribe: function(D) {
            z.subscribers = z.subscribers.filter(function(V) {
              return V !== D;
            }), z.fire = z.subscribers.reduce(M, _);
          } };
          return p[R] = c[R] = z;
        }
        r(L = R).forEach(function(D) {
          var V = L[D];
          if (o(V))
            C(D, L[D][0], L[D][1]);
          else {
            if (V !== "asap")
              throw new pe.InvalidArgument("Invalid event config");
            var N = C(D, _t, function() {
              for (var B = arguments.length, G = new Array(B); B--; )
                G[B] = arguments[B];
              N.subscribers.forEach(function(U) {
                O(function() {
                  U.apply(null, G);
                });
              });
            });
          }
        });
      }
    }
    function Fs(a, c) {
      return y(c).from({ prototype: a }), c;
    }
    function Kn(a, c) {
      return !(a.filter || a.algorithm || a.or) && (c ? a.justLimit : !a.replayFilter);
    }
    function co(a, c) {
      a.filter = Rn(a.filter, c);
    }
    function ho(a, c, p) {
      var E = a.replayFilter;
      a.replayFilter = E ? function() {
        return Rn(E(), c());
      } : c, a.justLimit = p && !E;
    }
    function bi(a, c) {
      if (a.isPrimKey)
        return c.primaryKey;
      var p = c.getIndexByKeyPath(a.index);
      if (!p)
        throw new pe.Schema("KeyPath " + a.index + " on object store " + c.name + " is not indexed");
      return p;
    }
    function qa(a, c, p) {
      var E = bi(a, c.schema);
      return c.openCursor({ trans: p, values: !a.keysOnly, reverse: a.dir === "prev", unique: !!a.unique, query: { index: E, range: a.range } });
    }
    function xi(a, c, p, E) {
      var v = a.replayFilter ? Rn(a.filter, a.replayFilter()) : a.filter;
      if (a.or) {
        var C = {}, R = function(M, _, L) {
          var z, D;
          v && !v(_, L, function(V) {
            return _.stop(V);
          }, function(V) {
            return _.fail(V);
          }) || ((D = "" + (z = _.primaryKey)) == "[object ArrayBuffer]" && (D = "" + new Uint8Array(z)), m(C, D) || (C[D] = true, c(M, _, L)));
        };
        return Promise.all([a.or._iterate(R, p), Ja(qa(a, E, p), a.algorithm, R, !a.keysOnly && a.valueMapper)]);
      }
      return Ja(qa(a, E, p), Rn(a.algorithm, v), c, !a.keysOnly && a.valueMapper);
    }
    function Ja(a, c, p, E) {
      var v = ze(E ? function(C, R, M) {
        return p(E(C), R, M);
      } : p);
      return a.then(function(C) {
        if (C)
          return C.start(function() {
            var R = function() {
              return C.continue();
            };
            c && !c(C, function(M) {
              return R = M;
            }, function(M) {
              C.stop(M), R = Oe;
            }, function(M) {
              C.fail(M), R = Oe;
            }) || v(C.value, C, function(M) {
              return R = M;
            }), R();
          });
      });
    }
    var Jt = Symbol(), Ps = ($a.prototype.execute = function(a) {
      if (this.add !== void 0) {
        var c = this.add;
        if (o(c))
          return s(s([], o(a) ? a : [], true), c).sort();
        if (typeof c == "number")
          return (Number(a) || 0) + c;
        if (typeof c == "bigint")
          try {
            return BigInt(a) + c;
          } catch {
            return BigInt(0) + c;
          }
        throw new TypeError("Invalid term ".concat(c));
      }
      if (this.remove !== void 0) {
        var p = this.remove;
        if (o(p))
          return o(a) ? a.filter(function(E) {
            return !p.includes(E);
          }).sort() : [];
        if (typeof p == "number")
          return Number(a) - p;
        if (typeof p == "bigint")
          try {
            return BigInt(a) - p;
          } catch {
            return BigInt(0) - p;
          }
        throw new TypeError("Invalid subtrahend ".concat(p));
      }
      return c = (c = this.replacePrefix) === null || c === void 0 ? void 0 : c[0], c && typeof a == "string" && a.startsWith(c) ? this.replacePrefix[1] + a.substring(c.length) : a;
    }, $a);
    function $a(a) {
      Object.assign(this, a);
    }
    var Uh = (Fe.prototype._read = function(a, c) {
      var p = this._ctx;
      return p.error ? p.table._trans(null, Xe.bind(null, p.error)) : p.table._trans("readonly", a).then(c);
    }, Fe.prototype._write = function(a) {
      var c = this._ctx;
      return c.error ? c.table._trans(null, Xe.bind(null, c.error)) : c.table._trans("readwrite", a, "locked");
    }, Fe.prototype._addAlgorithm = function(a) {
      var c = this._ctx;
      c.algorithm = Rn(c.algorithm, a);
    }, Fe.prototype._iterate = function(a, c) {
      return xi(this._ctx, a, c, this._ctx.table.core);
    }, Fe.prototype.clone = function(a) {
      var c = Object.create(this.constructor.prototype), p = Object.create(this._ctx);
      return a && l(p, a), c._ctx = p, c;
    }, Fe.prototype.raw = function() {
      return this._ctx.valueMapper = null, this;
    }, Fe.prototype.each = function(a) {
      var c = this._ctx;
      return this._read(function(p) {
        return xi(c, a, p, c.table.core);
      });
    }, Fe.prototype.count = function(a) {
      var c = this;
      return this._read(function(p) {
        var E = c._ctx, v = E.table.core;
        if (Kn(E, true))
          return v.count({ trans: p, query: { index: bi(E, v.schema), range: E.range } }).then(function(R) {
            return Math.min(R, E.limit);
          });
        var C = 0;
        return xi(E, function() {
          return ++C, false;
        }, p, v).then(function() {
          return C;
        });
      }).then(a);
    }, Fe.prototype.sortBy = function(a, c) {
      var p = a.split(".").reverse(), E = p[0], v = p.length - 1;
      function C(_, L) {
        return L ? C(_[p[L]], L - 1) : _[E];
      }
      var R = this._ctx.dir === "next" ? 1 : -1;
      function M(_, L) {
        return _ = C(_, v), L = C(L, v), _ < L ? -R : L < _ ? R : 0;
      }
      return this.toArray(function(_) {
        return _.sort(M);
      }).then(c);
    }, Fe.prototype.toArray = function(a) {
      var c = this;
      return this._read(function(p) {
        var E = c._ctx;
        if (E.dir === "next" && Kn(E, true) && 0 < E.limit) {
          var v = E.valueMapper, C = bi(E, E.table.core.schema);
          return E.table.core.query({ trans: p, limit: E.limit, values: true, query: { index: C, range: E.range } }).then(function(M) {
            return M = M.result, v ? M.map(v) : M;
          });
        }
        var R = [];
        return xi(E, function(M) {
          return R.push(M);
        }, p, E.table.core).then(function() {
          return R;
        });
      }, a);
    }, Fe.prototype.offset = function(a) {
      var c = this._ctx;
      return a <= 0 || (c.offset += a, Kn(c) ? ho(c, function() {
        var p = a;
        return function(E, v) {
          return p === 0 || (p === 1 ? --p : v(function() {
            E.advance(p), p = 0;
          }), false);
        };
      }) : ho(c, function() {
        var p = a;
        return function() {
          return --p < 0;
        };
      })), this;
    }, Fe.prototype.limit = function(a) {
      return this._ctx.limit = Math.min(this._ctx.limit, a), ho(this._ctx, function() {
        var c = a;
        return function(p, E, v) {
          return --c <= 0 && E(v), 0 <= c;
        };
      }, true), this;
    }, Fe.prototype.until = function(a, c) {
      return co(this._ctx, function(p, E, v) {
        return !a(p.value) || (E(v), c);
      }), this;
    }, Fe.prototype.first = function(a) {
      return this.limit(1).toArray(function(c) {
        return c[0];
      }).then(a);
    }, Fe.prototype.last = function(a) {
      return this.reverse().first(a);
    }, Fe.prototype.filter = function(a) {
      var c;
      return co(this._ctx, function(p) {
        return a(p.value);
      }), (c = this._ctx).isMatch = Rn(c.isMatch, a), this;
    }, Fe.prototype.and = function(a) {
      return this.filter(a);
    }, Fe.prototype.or = function(a) {
      return new this.db.WhereClause(this._ctx.table, a, this);
    }, Fe.prototype.reverse = function() {
      return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
    }, Fe.prototype.desc = function() {
      return this.reverse();
    }, Fe.prototype.eachKey = function(a) {
      var c = this._ctx;
      return c.keysOnly = !c.isMatch, this.each(function(p, E) {
        a(E.key, E);
      });
    }, Fe.prototype.eachUniqueKey = function(a) {
      return this._ctx.unique = "unique", this.eachKey(a);
    }, Fe.prototype.eachPrimaryKey = function(a) {
      var c = this._ctx;
      return c.keysOnly = !c.isMatch, this.each(function(p, E) {
        a(E.primaryKey, E);
      });
    }, Fe.prototype.keys = function(a) {
      var c = this._ctx;
      c.keysOnly = !c.isMatch;
      var p = [];
      return this.each(function(E, v) {
        p.push(v.key);
      }).then(function() {
        return p;
      }).then(a);
    }, Fe.prototype.primaryKeys = function(a) {
      var c = this._ctx;
      if (c.dir === "next" && Kn(c, true) && 0 < c.limit)
        return this._read(function(E) {
          var v = bi(c, c.table.core.schema);
          return c.table.core.query({ trans: E, values: false, limit: c.limit, query: { index: v, range: c.range } });
        }).then(function(E) {
          return E.result;
        }).then(a);
      c.keysOnly = !c.isMatch;
      var p = [];
      return this.each(function(E, v) {
        p.push(v.primaryKey);
      }).then(function() {
        return p;
      }).then(a);
    }, Fe.prototype.uniqueKeys = function(a) {
      return this._ctx.unique = "unique", this.keys(a);
    }, Fe.prototype.firstKey = function(a) {
      return this.limit(1).keys(function(c) {
        return c[0];
      }).then(a);
    }, Fe.prototype.lastKey = function(a) {
      return this.reverse().firstKey(a);
    }, Fe.prototype.distinct = function() {
      var a = this._ctx, a = a.index && a.table.schema.idxByName[a.index];
      if (!a || !a.multi)
        return this;
      var c = {};
      return co(this._ctx, function(v) {
        var E = v.primaryKey.toString(), v = m(c, E);
        return c[E] = true, !v;
      }), this;
    }, Fe.prototype.modify = function(a) {
      var c = this, p = this._ctx;
      return this._write(function(E) {
        var v, C, R;
        R = typeof a == "function" ? a : (v = r(a), C = v.length, function(U) {
          for (var W = false, j = 0; j < C; ++j) {
            var X = v[j], Q = a[X], ee = k(U, X);
            Q instanceof Ps ? (Y(U, X, Q.execute(ee)), W = true) : ee !== Q && (Y(U, X, Q), W = true);
          }
          return W;
        });
        function M(U, X) {
          var j = X.failures, X = X.numFailures;
          B += U - X;
          for (var Q = 0, ee = r(j); Q < ee.length; Q++) {
            var le = ee[Q];
            N.push(j[le]);
          }
        }
        var _ = p.table.core, L = _.schema.primaryKey, z = L.outbound, D = L.extractKey, V = c.db._options.modifyChunkSize || 200, N = [], B = 0, G = [];
        return c.clone().primaryKeys().then(function(U) {
          function W(X) {
            var Q = Math.min(V, U.length - X);
            return _.getMany({ trans: E, keys: U.slice(X, X + Q), cache: "immutable" }).then(function(ee) {
              for (var le = [], ie = [], oe = z ? [] : null, ce = [], re = 0; re < Q; ++re) {
                var Ce = ee[re], Te = { value: se(Ce), primKey: U[X + re] };
                R.call(Te, Te.value, Te) !== false && (Te.value == null ? ce.push(U[X + re]) : z || Me(D(Ce), D(Te.value)) === 0 ? (ie.push(Te.value), z && oe.push(U[X + re])) : (ce.push(U[X + re]), le.push(Te.value)));
              }
              return Promise.resolve(0 < le.length && _.mutate({ trans: E, type: "add", values: le }).then(function(Ae) {
                for (var xe in Ae.failures)
                  ce.splice(parseInt(xe), 1);
                M(le.length, Ae);
              })).then(function() {
                return (0 < ie.length || j && typeof a == "object") && _.mutate({ trans: E, type: "put", keys: oe, values: ie, criteria: j, changeSpec: typeof a != "function" && a, isAdditionalChunk: 0 < X }).then(function(Ae) {
                  return M(ie.length, Ae);
                });
              }).then(function() {
                return (0 < ce.length || j && a === uo) && _.mutate({ trans: E, type: "delete", keys: ce, criteria: j, isAdditionalChunk: 0 < X }).then(function(Ae) {
                  return M(ce.length, Ae);
                });
              }).then(function() {
                return U.length > X + Q && W(X + V);
              });
            });
          }
          var j = Kn(p) && p.limit === 1 / 0 && (typeof a != "function" || a === uo) && { index: p.index, range: p.range };
          return W(0).then(function() {
            if (0 < N.length)
              throw new Tn("Error modifying one or more objects", N, B, G);
            return U.length;
          });
        });
      });
    }, Fe.prototype.delete = function() {
      var a = this._ctx, c = a.range;
      return Kn(a) && (a.isPrimKey || c.type === 3) ? this._write(function(p) {
        var E = a.table.core.schema.primaryKey, v = c;
        return a.table.core.count({ trans: p, query: { index: E, range: v } }).then(function(C) {
          return a.table.core.mutate({ trans: p, type: "deleteRange", range: v }).then(function(R) {
            var M = R.failures;
            if (R.lastResult, R.results, R = R.numFailures, R)
              throw new Tn("Could not delete some values", Object.keys(M).map(function(_) {
                return M[_];
              }), C - R);
            return C - R;
          });
        });
      }) : this.modify(uo);
    }, Fe);
    function Fe() {
    }
    var uo = function(a, c) {
      return c.value = null;
    };
    function Bh(a, c) {
      return a < c ? -1 : a === c ? 0 : 1;
    }
    function kh(a, c) {
      return c < a ? -1 : a === c ? 0 : 1;
    }
    function mt(a, c, p) {
      return a = a instanceof tl ? new a.Collection(a) : a, a._ctx.error = new (p || TypeError)(c), a;
    }
    function jn(a) {
      return new a.Collection(a, function() {
        return el("");
      }).limit(0);
    }
    function Si(a, c, p, E) {
      var v, C, R, M, _, L, z, D = p.length;
      if (!p.every(function(B) {
        return typeof B == "string";
      }))
        return mt(a, Wa);
      function V(B) {
        v = B === "next" ? function(U) {
          return U.toUpperCase();
        } : function(U) {
          return U.toLowerCase();
        }, C = B === "next" ? function(U) {
          return U.toLowerCase();
        } : function(U) {
          return U.toUpperCase();
        }, R = B === "next" ? Bh : kh;
        var G = p.map(function(U) {
          return { lower: C(U), upper: v(U) };
        }).sort(function(U, W) {
          return R(U.lower, W.lower);
        });
        M = G.map(function(U) {
          return U.upper;
        }), _ = G.map(function(U) {
          return U.lower;
        }), z = (L = B) === "next" ? "" : E;
      }
      V("next"), a = new a.Collection(a, function() {
        return hn(M[0], _[D - 1] + E);
      }), a._ondirectionchange = function(B) {
        V(B);
      };
      var N = 0;
      return a._addAlgorithm(function(B, G, U) {
        var W = B.key;
        if (typeof W != "string")
          return false;
        var j = C(W);
        if (c(j, _, N))
          return true;
        for (var X = null, Q = N; Q < D; ++Q) {
          var ee = function(le, ie, oe, ce, re, Ce) {
            for (var Te = Math.min(le.length, ce.length), Ae = -1, xe = 0; xe < Te; ++xe) {
              var Rt = ie[xe];
              if (Rt !== ce[xe])
                return re(le[xe], oe[xe]) < 0 ? le.substr(0, xe) + oe[xe] + oe.substr(xe + 1) : re(le[xe], ce[xe]) < 0 ? le.substr(0, xe) + ce[xe] + oe.substr(xe + 1) : 0 <= Ae ? le.substr(0, Ae) + ie[Ae] + oe.substr(Ae + 1) : null;
              re(le[xe], Rt) < 0 && (Ae = xe);
            }
            return Te < ce.length && Ce === "next" ? le + oe.substr(le.length) : Te < le.length && Ce === "prev" ? le.substr(0, oe.length) : Ae < 0 ? null : le.substr(0, Ae) + ce[Ae] + oe.substr(Ae + 1);
          }(W, j, M[Q], _[Q], R, L);
          ee === null && X === null ? N = Q + 1 : (X === null || 0 < R(X, ee)) && (X = ee);
        }
        return G(X !== null ? function() {
          B.continue(X + z);
        } : U), false;
      }), a;
    }
    function hn(a, c, p, E) {
      return { type: 2, lower: a, upper: c, lowerOpen: p, upperOpen: E };
    }
    function el(a) {
      return { type: 1, lower: a, upper: a };
    }
    var tl = (Object.defineProperty(Je.prototype, "Collection", { get: function() {
      return this._ctx.table.db.Collection;
    }, enumerable: false, configurable: true }), Je.prototype.between = function(a, c, p, E) {
      p = p !== false, E = E === true;
      try {
        return 0 < this._cmp(a, c) || this._cmp(a, c) === 0 && (p || E) && (!p || !E) ? jn(this) : new this.Collection(this, function() {
          return hn(a, c, !p, !E);
        });
      } catch {
        return mt(this, qt);
      }
    }, Je.prototype.equals = function(a) {
      return a == null ? mt(this, qt) : new this.Collection(this, function() {
        return el(a);
      });
    }, Je.prototype.above = function(a) {
      return a == null ? mt(this, qt) : new this.Collection(this, function() {
        return hn(a, void 0, true);
      });
    }, Je.prototype.aboveOrEqual = function(a) {
      return a == null ? mt(this, qt) : new this.Collection(this, function() {
        return hn(a, void 0, false);
      });
    }, Je.prototype.below = function(a) {
      return a == null ? mt(this, qt) : new this.Collection(this, function() {
        return hn(void 0, a, false, true);
      });
    }, Je.prototype.belowOrEqual = function(a) {
      return a == null ? mt(this, qt) : new this.Collection(this, function() {
        return hn(void 0, a);
      });
    }, Je.prototype.startsWith = function(a) {
      return typeof a != "string" ? mt(this, Wa) : this.between(a, a + An, true, true);
    }, Je.prototype.startsWithIgnoreCase = function(a) {
      return a === "" ? this.startsWith(a) : Si(this, function(c, p) {
        return c.indexOf(p[0]) === 0;
      }, [a], An);
    }, Je.prototype.equalsIgnoreCase = function(a) {
      return Si(this, function(c, p) {
        return c === p[0];
      }, [a], "");
    }, Je.prototype.anyOfIgnoreCase = function() {
      var a = we.apply(Le, arguments);
      return a.length === 0 ? jn(this) : Si(this, function(c, p) {
        return p.indexOf(c) !== -1;
      }, a, "");
    }, Je.prototype.startsWithAnyOfIgnoreCase = function() {
      var a = we.apply(Le, arguments);
      return a.length === 0 ? jn(this) : Si(this, function(c, p) {
        return p.some(function(E) {
          return c.indexOf(E) === 0;
        });
      }, a, An);
    }, Je.prototype.anyOf = function() {
      var a = this, c = we.apply(Le, arguments), p = this._cmp;
      try {
        c.sort(p);
      } catch {
        return mt(this, qt);
      }
      if (c.length === 0)
        return jn(this);
      var E = new this.Collection(this, function() {
        return hn(c[0], c[c.length - 1]);
      });
      E._ondirectionchange = function(C) {
        p = C === "next" ? a._ascending : a._descending, c.sort(p);
      };
      var v = 0;
      return E._addAlgorithm(function(C, R, M) {
        for (var _ = C.key; 0 < p(_, c[v]); )
          if (++v === c.length)
            return R(M), false;
        return p(_, c[v]) === 0 || (R(function() {
          C.continue(c[v]);
        }), false);
      }), E;
    }, Je.prototype.notEqual = function(a) {
      return this.inAnyRange([[-1 / 0, a], [a, this.db._maxKey]], { includeLowers: false, includeUppers: false });
    }, Je.prototype.noneOf = function() {
      var a = we.apply(Le, arguments);
      if (a.length === 0)
        return new this.Collection(this);
      try {
        a.sort(this._ascending);
      } catch {
        return mt(this, qt);
      }
      var c = a.reduce(function(p, E) {
        return p ? p.concat([[p[p.length - 1][1], E]]) : [[-1 / 0, E]];
      }, null);
      return c.push([a[a.length - 1], this.db._maxKey]), this.inAnyRange(c, { includeLowers: false, includeUppers: false });
    }, Je.prototype.inAnyRange = function(W, c) {
      var p = this, E = this._cmp, v = this._ascending, C = this._descending, R = this._min, M = this._max;
      if (W.length === 0)
        return jn(this);
      if (!W.every(function(j) {
        return j[0] !== void 0 && j[1] !== void 0 && v(j[0], j[1]) <= 0;
      }))
        return mt(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", pe.InvalidArgument);
      var _ = !c || c.includeLowers !== false, L = c && c.includeUppers === true, z, D = v;
      function V(j, X) {
        return D(j[0], X[0]);
      }
      try {
        (z = W.reduce(function(j, X) {
          for (var Q = 0, ee = j.length; Q < ee; ++Q) {
            var le = j[Q];
            if (E(X[0], le[1]) < 0 && 0 < E(X[1], le[0])) {
              le[0] = R(le[0], X[0]), le[1] = M(le[1], X[1]);
              break;
            }
          }
          return Q === ee && j.push(X), j;
        }, [])).sort(V);
      } catch {
        return mt(this, qt);
      }
      var N = 0, B = L ? function(j) {
        return 0 < v(j, z[N][1]);
      } : function(j) {
        return 0 <= v(j, z[N][1]);
      }, G = _ ? function(j) {
        return 0 < C(j, z[N][0]);
      } : function(j) {
        return 0 <= C(j, z[N][0]);
      }, U = B, W = new this.Collection(this, function() {
        return hn(z[0][0], z[z.length - 1][1], !_, !L);
      });
      return W._ondirectionchange = function(j) {
        D = j === "next" ? (U = B, v) : (U = G, C), z.sort(V);
      }, W._addAlgorithm(function(j, X, Q) {
        for (var ee, le = j.key; U(le); )
          if (++N === z.length)
            return X(Q), false;
        return !B(ee = le) && !G(ee) || (p._cmp(le, z[N][1]) === 0 || p._cmp(le, z[N][0]) === 0 || X(function() {
          D === v ? j.continue(z[N][0]) : j.continue(z[N][1]);
        }), false);
      }), W;
    }, Je.prototype.startsWithAnyOf = function() {
      var a = we.apply(Le, arguments);
      return a.every(function(c) {
        return typeof c == "string";
      }) ? a.length === 0 ? jn(this) : this.inAnyRange(a.map(function(c) {
        return [c, c + An];
      })) : mt(this, "startsWithAnyOf() only works with strings");
    }, Je);
    function Je() {
    }
    function Bt(a) {
      return ze(function(c) {
        return Ms(c), a(c.target.error), false;
      });
    }
    function Ms(a) {
      a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault();
    }
    var Os = "storagemutated", fo = "x-storagemutated-1", un = Rs(null, Os), zh = (kt.prototype._lock = function() {
      return b(!ge.global), ++this._reculock, this._reculock !== 1 || ge.global || (ge.lockOwnerFor = this), this;
    }, kt.prototype._unlock = function() {
      if (b(!ge.global), --this._reculock == 0)
        for (ge.global || (ge.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var a = this._blockedFuncs.shift();
          try {
            Sn(a[1], a[0]);
          } catch {
          }
        }
      return this;
    }, kt.prototype._locked = function() {
      return this._reculock && ge.lockOwnerFor !== this;
    }, kt.prototype.create = function(a) {
      var c = this;
      if (!this.mode)
        return this;
      var p = this.db.idbdb, E = this.db._state.dbOpenError;
      if (b(!this.idbtrans), !a && !p)
        switch (E && E.name) {
          case "DatabaseClosedError":
            throw new pe.DatabaseClosed(E);
          case "MissingAPIError":
            throw new pe.MissingAPI(E.message, E);
          default:
            throw new pe.OpenFailed(E);
        }
      if (!this.active)
        throw new pe.TransactionInactive();
      return b(this._completion._state === null), (a = this.idbtrans = a || (this.db.core || p).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = ze(function(v) {
        Ms(v), c._reject(a.error);
      }), a.onabort = ze(function(v) {
        Ms(v), c.active && c._reject(new pe.Abort(a.error)), c.active = false, c.on("abort").fire(v);
      }), a.oncomplete = ze(function() {
        c.active = false, c._resolve(), "mutatedParts" in a && un.storagemutated.fire(a.mutatedParts);
      }), this;
    }, kt.prototype._promise = function(a, c, p) {
      var E = this;
      if (a === "readwrite" && this.mode !== "readwrite")
        return Xe(new pe.ReadOnly("Transaction is readonly"));
      if (!this.active)
        return Xe(new pe.TransactionInactive());
      if (this._locked())
        return new he(function(C, R) {
          E._blockedFuncs.push([function() {
            E._promise(a, c, p).then(C, R);
          }, ge]);
        });
      if (p)
        return an(function() {
          var C = new he(function(R, M) {
            E._lock();
            var _ = c(R, M, E);
            _ && _.then && _.then(R, M);
          });
          return C.finally(function() {
            return E._unlock();
          }), C._lib = true, C;
        });
      var v = new he(function(C, R) {
        var M = c(C, R, E);
        M && M.then && M.then(C, R);
      });
      return v._lib = true, v;
    }, kt.prototype._root = function() {
      return this.parent ? this.parent._root() : this;
    }, kt.prototype.waitFor = function(a) {
      var c, p = this._root(), E = he.resolve(a);
      p._waitingFor ? p._waitingFor = p._waitingFor.then(function() {
        return E;
      }) : (p._waitingFor = E, p._waitingQueue = [], c = p.idbtrans.objectStore(p.storeNames[0]), function C() {
        for (++p._spinCount; p._waitingQueue.length; )
          p._waitingQueue.shift()();
        p._waitingFor && (c.get(-1 / 0).onsuccess = C);
      }());
      var v = p._waitingFor;
      return new he(function(C, R) {
        E.then(function(M) {
          return p._waitingQueue.push(ze(C.bind(null, M)));
        }, function(M) {
          return p._waitingQueue.push(ze(R.bind(null, M)));
        }).finally(function() {
          p._waitingFor === v && (p._waitingFor = null);
        });
      });
    }, kt.prototype.abort = function() {
      this.active && (this.active = false, this.idbtrans && this.idbtrans.abort(), this._reject(new pe.Abort()));
    }, kt.prototype.table = function(a) {
      var c = this._memoizedTables || (this._memoizedTables = {});
      if (m(c, a))
        return c[a];
      var p = this.schema[a];
      if (!p)
        throw new pe.NotFound("Table " + a + " not part of transaction");
      return p = new this.db.Table(a, p, this), p.core = this.db.core.table(a), c[a] = p;
    }, kt);
    function kt() {
    }
    function po(a, c, p, E, v, C, R) {
      return { name: a, keyPath: c, unique: p, multi: E, auto: v, compound: C, src: (p && !R ? "&" : "") + (E ? "*" : "") + (v ? "++" : "") + nl(c) };
    }
    function nl(a) {
      return typeof a == "string" ? a : a ? "[" + [].join.call(a, "+") + "]" : "";
    }
    function mo(a, c, p) {
      return { name: a, primKey: c, indexes: p, mappedClass: null, idxByName: (E = function(v) {
        return [v.name, v];
      }, p.reduce(function(v, C, R) {
        return R = E(C, R), R && (v[R[0]] = R[1]), v;
      }, {})) };
      var E;
    }
    var Ds = function(a) {
      try {
        return a.only([[]]), Ds = function() {
          return [[]];
        }, [[]];
      } catch {
        return Ds = function() {
          return An;
        }, An;
      }
    };
    function go(a) {
      return a == null ? function() {
      } : typeof a == "string" ? (c = a).split(".").length === 1 ? function(p) {
        return p[c];
      } : function(p) {
        return k(p, c);
      } : function(p) {
        return k(p, a);
      };
      var c;
    }
    function sl(a) {
      return [].slice.call(a);
    }
    var Vh = 0;
    function Ls(a) {
      return a == null ? ":id" : typeof a == "string" ? a : "[".concat(a.join("+"), "]");
    }
    function Gh(a, c, _) {
      function E(U) {
        if (U.type === 3)
          return null;
        if (U.type === 4)
          throw new Error("Cannot convert never type to IDBKeyRange");
        var N = U.lower, B = U.upper, G = U.lowerOpen, U = U.upperOpen;
        return N === void 0 ? B === void 0 ? null : c.upperBound(B, !!U) : B === void 0 ? c.lowerBound(N, !!G) : c.bound(N, B, !!G, !!U);
      }
      function v(V) {
        var N, B = V.name;
        return { name: B, schema: V, mutate: function(G) {
          var U = G.trans, W = G.type, j = G.keys, X = G.values, Q = G.range;
          return new Promise(function(ee, le) {
            ee = ze(ee);
            var ie = U.objectStore(B), oe = ie.keyPath == null, ce = W === "put" || W === "add";
            if (!ce && W !== "delete" && W !== "deleteRange")
              throw new Error("Invalid operation type: " + W);
            var re, Ce = (j || X || { length: 1 }).length;
            if (j && X && j.length !== X.length)
              throw new Error("Given keys array must have same length as given values array.");
            if (Ce === 0)
              return ee({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
            function Te(lt) {
              ++Rt, Ms(lt);
            }
            var Ae = [], xe = [], Rt = 0;
            if (W === "deleteRange") {
              if (Q.type === 4)
                return ee({ numFailures: Rt, failures: xe, results: [], lastResult: void 0 });
              Q.type === 3 ? Ae.push(re = ie.clear()) : Ae.push(re = ie.delete(E(Q)));
            } else {
              var oe = ce ? oe ? [X, j] : [X, null] : [j, null], Se = oe[0], it = oe[1];
              if (ce)
                for (var rt = 0; rt < Ce; ++rt)
                  Ae.push(re = it && it[rt] !== void 0 ? ie[W](Se[rt], it[rt]) : ie[W](Se[rt])), re.onerror = Te;
              else
                for (rt = 0; rt < Ce; ++rt)
                  Ae.push(re = ie[W](Se[rt])), re.onerror = Te;
            }
            function ki2(lt) {
              lt = lt.target.result, Ae.forEach(function(Mn, No) {
                return Mn.error != null && (xe[No] = Mn.error);
              }), ee({ numFailures: Rt, failures: xe, results: W === "delete" ? j : Ae.map(function(Mn) {
                return Mn.result;
              }), lastResult: lt });
            }
            re.onerror = function(lt) {
              Te(lt), ki2(lt);
            }, re.onsuccess = ki2;
          });
        }, getMany: function(G) {
          var U = G.trans, W = G.keys;
          return new Promise(function(j, X) {
            j = ze(j);
            for (var Q, ee = U.objectStore(B), le = W.length, ie = new Array(le), oe = 0, ce = 0, re = function(Ae) {
              Ae = Ae.target, ie[Ae._pos] = Ae.result, ++ce === oe && j(ie);
            }, Ce = Bt(X), Te = 0; Te < le; ++Te)
              W[Te] != null && ((Q = ee.get(W[Te]))._pos = Te, Q.onsuccess = re, Q.onerror = Ce, ++oe);
            oe === 0 && j(ie);
          });
        }, get: function(G) {
          var U = G.trans, W = G.key;
          return new Promise(function(j, X) {
            j = ze(j);
            var Q = U.objectStore(B).get(W);
            Q.onsuccess = function(ee) {
              return j(ee.target.result);
            }, Q.onerror = Bt(X);
          });
        }, query: (N = L, function(G) {
          return new Promise(function(U, W) {
            U = ze(U);
            var j, X, Q, oe = G.trans, ee = G.values, le = G.limit, re = G.query, ie = le === 1 / 0 ? void 0 : le, ce = re.index, re = re.range, oe = oe.objectStore(B), ce = ce.isPrimaryKey ? oe : oe.index(ce.name), re = E(re);
            if (le === 0)
              return U({ result: [] });
            N ? ((ie = ee ? ce.getAll(re, ie) : ce.getAllKeys(re, ie)).onsuccess = function(Ce) {
              return U({ result: Ce.target.result });
            }, ie.onerror = Bt(W)) : (j = 0, X = !ee && "openKeyCursor" in ce ? ce.openKeyCursor(re) : ce.openCursor(re), Q = [], X.onsuccess = function(Ce) {
              var Te = X.result;
              return Te ? (Q.push(ee ? Te.value : Te.primaryKey), ++j === le ? U({ result: Q }) : void Te.continue()) : U({ result: Q });
            }, X.onerror = Bt(W));
          });
        }), openCursor: function(G) {
          var U = G.trans, W = G.values, j = G.query, X = G.reverse, Q = G.unique;
          return new Promise(function(ee, le) {
            ee = ze(ee);
            var ce = j.index, ie = j.range, oe = U.objectStore(B), oe = ce.isPrimaryKey ? oe : oe.index(ce.name), ce = X ? Q ? "prevunique" : "prev" : Q ? "nextunique" : "next", re = !W && "openKeyCursor" in oe ? oe.openKeyCursor(E(ie), ce) : oe.openCursor(E(ie), ce);
            re.onerror = Bt(le), re.onsuccess = ze(function(Ce) {
              var Te, Ae, xe, Rt, Se = re.result;
              Se ? (Se.___id = ++Vh, Se.done = false, Te = Se.continue.bind(Se), Ae = (Ae = Se.continuePrimaryKey) && Ae.bind(Se), xe = Se.advance.bind(Se), Rt = function() {
                throw new Error("Cursor not stopped");
              }, Se.trans = U, Se.stop = Se.continue = Se.continuePrimaryKey = Se.advance = function() {
                throw new Error("Cursor not started");
              }, Se.fail = ze(le), Se.next = function() {
                var it = this, rt = 1;
                return this.start(function() {
                  return rt-- ? it.continue() : it.stop();
                }).then(function() {
                  return it;
                });
              }, Se.start = function(it) {
                function rt() {
                  if (re.result)
                    try {
                      it();
                    } catch (lt) {
                      Se.fail(lt);
                    }
                  else
                    Se.done = true, Se.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, Se.stop();
                }
                var ki2 = new Promise(function(lt, Mn) {
                  lt = ze(lt), re.onerror = Bt(Mn), Se.fail = Mn, Se.stop = function(No) {
                    Se.stop = Se.continue = Se.continuePrimaryKey = Se.advance = Rt, lt(No);
                  };
                });
                return re.onsuccess = ze(function(lt) {
                  re.onsuccess = rt, rt();
                }), Se.continue = Te, Se.continuePrimaryKey = Ae, Se.advance = xe, rt(), ki2;
              }, ee(Se)) : ee(null);
            }, le);
          });
        }, count: function(G) {
          var U = G.query, W = G.trans, j = U.index, X = U.range;
          return new Promise(function(Q, ee) {
            var le = W.objectStore(B), ie = j.isPrimaryKey ? le : le.index(j.name), le = E(X), ie = le ? ie.count(le) : ie.count();
            ie.onsuccess = ze(function(oe) {
              return Q(oe.target.result);
            }), ie.onerror = Bt(ee);
          });
        } };
      }
      var C, R, M, z = (R = _, M = sl((C = a).objectStoreNames), { schema: { name: C.name, tables: M.map(function(V) {
        return R.objectStore(V);
      }).map(function(V) {
        var N = V.keyPath, U = V.autoIncrement, B = o(N), G = {}, U = { name: V.name, primaryKey: { name: null, isPrimaryKey: true, outbound: N == null, compound: B, keyPath: N, autoIncrement: U, unique: true, extractKey: go(N) }, indexes: sl(V.indexNames).map(function(W) {
          return V.index(W);
        }).map(function(Q) {
          var j = Q.name, X = Q.unique, ee = Q.multiEntry, Q = Q.keyPath, ee = { name: j, compound: o(Q), keyPath: Q, unique: X, multiEntry: ee, extractKey: go(Q) };
          return G[Ls(Q)] = ee;
        }), getIndexByKeyPath: function(W) {
          return G[Ls(W)];
        } };
        return G[":id"] = U.primaryKey, N != null && (G[Ls(N)] = U.primaryKey), U;
      }) }, hasGetAll: 0 < M.length && "getAll" in R.objectStore(M[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), _ = z.schema, L = z.hasGetAll, z = _.tables.map(v), D = {};
      return z.forEach(function(V) {
        return D[V.name] = V;
      }), { stack: "dbcore", transaction: a.transaction.bind(a), table: function(V) {
        if (!D[V])
          throw new Error("Table '".concat(V, "' not found"));
        return D[V];
      }, MIN_KEY: -1 / 0, MAX_KEY: Ds(c), schema: _ };
    }
    function Yh(a, c, p, E) {
      var v = p.IDBKeyRange;
      return p.indexedDB, { dbcore: (E = Gh(c, v, E), a.dbcore.reduce(function(C, R) {
        return R = R.create, n(n({}, C), R(C));
      }, E)) };
    }
    function Ai(a, E) {
      var p = E.db, E = Yh(a._middlewares, p, a._deps, E);
      a.core = E.dbcore, a.tables.forEach(function(v) {
        var C = v.name;
        a.core.schema.tables.some(function(R) {
          return R.name === C;
        }) && (v.core = a.core.table(C), a[C] instanceof a.Table && (a[C].core = v.core));
      });
    }
    function Ri(a, c, p, E) {
      p.forEach(function(v) {
        var C = E[v];
        c.forEach(function(R) {
          var M = function _(L, z) {
            return x(L, z) || (L = h(L)) && _(L, z);
          }(R, v);
          (!M || "value" in M && M.value === void 0) && (R === a.Transaction.prototype || R instanceof a.Transaction ? I(R, v, { get: function() {
            return this.table(v);
          }, set: function(_) {
            g(this, v, { value: _, writable: true, configurable: true, enumerable: true });
          } }) : R[v] = new a.Table(v, C));
        });
      });
    }
    function Eo(a, c) {
      c.forEach(function(p) {
        for (var E in p)
          p[E] instanceof a.Table && delete p[E];
      });
    }
    function Hh(a, c) {
      return a._cfg.version - c._cfg.version;
    }
    function Wh(a, c, p, E) {
      var v = a._dbSchema;
      p.objectStoreNames.contains("$meta") && !v.$meta && (v.$meta = mo("$meta", rl("")[0], []), a._storeNames.push("$meta"));
      var C = a._createTransaction("readwrite", a._storeNames, v);
      C.create(p), C._completion.catch(E);
      var R = C._reject.bind(C), M = ge.transless || ge;
      an(function() {
        return ge.trans = C, ge.transless = M, c !== 0 ? (Ai(a, p), L = c, ((_ = C).storeNames.includes("$meta") ? _.table("$meta").get("version").then(function(z) {
          return z ?? L;
        }) : he.resolve(L)).then(function(z) {
          return V = z, N = C, B = p, G = [], z = (D = a)._versions, U = D._dbSchema = Pi(0, D.idbdb, B), (z = z.filter(function(W) {
            return W._cfg.version >= V;
          })).length !== 0 ? (z.forEach(function(W) {
            G.push(function() {
              var j = U, X = W._cfg.dbschema;
              Mi(D, j, B), Mi(D, X, B), U = D._dbSchema = X;
              var Q = vo(j, X);
              Q.add.forEach(function(ce) {
                Io(B, ce[0], ce[1].primKey, ce[1].indexes);
              }), Q.change.forEach(function(ce) {
                if (ce.recreate)
                  throw new pe.Upgrade("Not yet support for changing primary key");
                var re = B.objectStore(ce.name);
                ce.add.forEach(function(Ce) {
                  return Fi(re, Ce);
                }), ce.change.forEach(function(Ce) {
                  re.deleteIndex(Ce.name), Fi(re, Ce);
                }), ce.del.forEach(function(Ce) {
                  return re.deleteIndex(Ce);
                });
              });
              var ee = W._cfg.contentUpgrade;
              if (ee && W._cfg.version > V) {
                Ai(D, B), N._memoizedTables = {};
                var le = H(X);
                Q.del.forEach(function(ce) {
                  le[ce] = j[ce];
                }), Eo(D, [D.Transaction.prototype]), Ri(D, [D.Transaction.prototype], r(le), le), N.schema = le;
                var ie, oe = Ke(ee);
                return oe && Hn(), Q = he.follow(function() {
                  var ce;
                  (ie = ee(N)) && oe && (ce = ln.bind(null, null), ie.then(ce, ce));
                }), ie && typeof ie.then == "function" ? he.resolve(ie) : Q.then(function() {
                  return ie;
                });
              }
            }), G.push(function(j) {
              var X, Q, ee = W._cfg.dbschema;
              X = ee, Q = j, [].slice.call(Q.db.objectStoreNames).forEach(function(le) {
                return X[le] == null && Q.db.deleteObjectStore(le);
              }), Eo(D, [D.Transaction.prototype]), Ri(D, [D.Transaction.prototype], D._storeNames, D._dbSchema), N.schema = D._dbSchema;
            }), G.push(function(j) {
              D.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(D.idbdb.version / 10) === W._cfg.version ? (D.idbdb.deleteObjectStore("$meta"), delete D._dbSchema.$meta, D._storeNames = D._storeNames.filter(function(X) {
                return X !== "$meta";
              })) : j.objectStore("$meta").put(W._cfg.version, "version"));
            });
          }), function W() {
            return G.length ? he.resolve(G.shift()(N.idbtrans)).then(W) : he.resolve();
          }().then(function() {
            il(U, B);
          })) : he.resolve();
          var D, V, N, B, G, U;
        }).catch(R)) : (r(v).forEach(function(z) {
          Io(p, z, v[z].primKey, v[z].indexes);
        }), Ai(a, p), void he.follow(function() {
          return a.on.populate.fire(C);
        }).catch(R));
        var _, L;
      });
    }
    function Kh(a, c) {
      il(a._dbSchema, c), c.db.version % 10 != 0 || c.objectStoreNames.contains("$meta") || c.db.createObjectStore("$meta").add(Math.ceil(c.db.version / 10 - 1), "version");
      var p = Pi(0, a.idbdb, c);
      Mi(a, a._dbSchema, c);
      for (var E = 0, v = vo(p, a._dbSchema).change; E < v.length; E++) {
        var C = function(R) {
          if (R.change.length || R.recreate)
            return console.warn("Unable to patch indexes of table ".concat(R.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
          var M = c.objectStore(R.name);
          R.add.forEach(function(_) {
            Ut && console.debug("Dexie upgrade patch: Creating missing index ".concat(R.name, ".").concat(_.src)), Fi(M, _);
          });
        }(v[E]);
        if (typeof C == "object")
          return C.value;
      }
    }
    function vo(a, c) {
      var p, E = { del: [], add: [], change: [] };
      for (p in a)
        c[p] || E.del.push(p);
      for (p in c) {
        var v = a[p], C = c[p];
        if (v) {
          var R = { name: p, def: C, recreate: false, del: [], add: [], change: [] };
          if ("" + (v.primKey.keyPath || "") != "" + (C.primKey.keyPath || "") || v.primKey.auto !== C.primKey.auto)
            R.recreate = true, E.change.push(R);
          else {
            var M = v.idxByName, _ = C.idxByName, L = void 0;
            for (L in M)
              _[L] || R.del.push(L);
            for (L in _) {
              var z = M[L], D = _[L];
              z ? z.src !== D.src && R.change.push(D) : R.add.push(D);
            }
            (0 < R.del.length || 0 < R.add.length || 0 < R.change.length) && E.change.push(R);
          }
        } else
          E.add.push([p, C]);
      }
      return E;
    }
    function Io(a, c, p, E) {
      var v = a.db.createObjectStore(c, p.keyPath ? { keyPath: p.keyPath, autoIncrement: p.auto } : { autoIncrement: p.auto });
      return E.forEach(function(C) {
        return Fi(v, C);
      }), v;
    }
    function il(a, c) {
      r(a).forEach(function(p) {
        c.db.objectStoreNames.contains(p) || (Ut && console.debug("Dexie: Creating missing table", p), Io(c, p, a[p].primKey, a[p].indexes));
      });
    }
    function Fi(a, c) {
      a.createIndex(c.name, c.keyPath, { unique: c.unique, multiEntry: c.multi });
    }
    function Pi(a, c, p) {
      var E = {};
      return F(c.objectStoreNames, 0).forEach(function(v) {
        for (var C = p.objectStore(v), R = po(nl(L = C.keyPath), L || "", true, false, !!C.autoIncrement, L && typeof L != "string", true), M = [], _ = 0; _ < C.indexNames.length; ++_) {
          var z = C.index(C.indexNames[_]), L = z.keyPath, z = po(z.name, L, !!z.unique, !!z.multiEntry, false, L && typeof L != "string", false);
          M.push(z);
        }
        E[v] = mo(v, R, M);
      }), E;
    }
    function Mi(a, c, p) {
      for (var E = p.db.objectStoreNames, v = 0; v < E.length; ++v) {
        var C = E[v], R = p.objectStore(C);
        a._hasGetAll = "getAll" in R;
        for (var M = 0; M < R.indexNames.length; ++M) {
          var _ = R.indexNames[M], L = R.index(_).keyPath, z = typeof L == "string" ? L : "[" + F(L).join("+") + "]";
          !c[C] || (L = c[C].idxByName[z]) && (L.name = _, delete c[C].idxByName[z], c[C].idxByName[_] = L);
        }
      }
      typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && i.WorkerGlobalScope && i instanceof i.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (a._hasGetAll = false);
    }
    function rl(a) {
      return a.split(",").map(function(c, p) {
        var E = (c = c.trim()).replace(/([&*]|\+\+)/g, ""), v = /^\[/.test(E) ? E.match(/^\[(.*)\]$/)[1].split("+") : E;
        return po(E, v || null, /\&/.test(c), /\*/.test(c), /\+\+/.test(c), o(v), p === 0);
      });
    }
    var jh = (Oi.prototype._parseStoresSpec = function(a, c) {
      r(a).forEach(function(p) {
        if (a[p] !== null) {
          var E = rl(a[p]), v = E.shift();
          if (v.unique = true, v.multi)
            throw new pe.Schema("Primary key cannot be multi-valued");
          E.forEach(function(C) {
            if (C.auto)
              throw new pe.Schema("Only primary key can be marked as autoIncrement (++)");
            if (!C.keyPath)
              throw new pe.Schema("Index must have a name and cannot be an empty string");
          }), c[p] = mo(p, v, E);
        }
      });
    }, Oi.prototype.stores = function(p) {
      var c = this.db;
      this._cfg.storesSource = this._cfg.storesSource ? l(this._cfg.storesSource, p) : p;
      var p = c._versions, E = {}, v = {};
      return p.forEach(function(C) {
        l(E, C._cfg.storesSource), v = C._cfg.dbschema = {}, C._parseStoresSpec(E, v);
      }), c._dbSchema = v, Eo(c, [c._allTables, c, c.Transaction.prototype]), Ri(c, [c._allTables, c, c.Transaction.prototype, this._cfg.tables], r(v), v), c._storeNames = r(v), this;
    }, Oi.prototype.upgrade = function(a) {
      return this._cfg.contentUpgrade = Jr(this._cfg.contentUpgrade || Oe, a), this;
    }, Oi);
    function Oi() {
    }
    function yo(a, c) {
      var p = a._dbNamesDB;
      return p || (p = a._dbNamesDB = new $t(Ci, { addons: [], indexedDB: a, IDBKeyRange: c })).version(1).stores({ dbnames: "name" }), p.table("dbnames");
    }
    function wo(a) {
      return a && typeof a.databases == "function";
    }
    function Co(a) {
      return an(function() {
        return ge.letThrough = true, a();
      });
    }
    function To(a) {
      return !("from" in a);
    }
    var st = function(a, c) {
      if (!this) {
        var p = new st();
        return a && "d" in a && l(p, a), p;
      }
      l(this, arguments.length ? { d: 1, from: a, to: 1 < arguments.length ? c : a } : { d: 0 });
    };
    function Ns(a, c, p) {
      var E = Me(c, p);
      if (!isNaN(E)) {
        if (0 < E)
          throw RangeError();
        if (To(a))
          return l(a, { from: c, to: p, d: 1 });
        var v = a.l, E = a.r;
        if (Me(p, a.from) < 0)
          return v ? Ns(v, c, p) : a.l = { from: c, to: p, d: 1, l: null, r: null }, ol(a);
        if (0 < Me(c, a.to))
          return E ? Ns(E, c, p) : a.r = { from: c, to: p, d: 1, l: null, r: null }, ol(a);
        Me(c, a.from) < 0 && (a.from = c, a.l = null, a.d = E ? E.d + 1 : 1), 0 < Me(p, a.to) && (a.to = p, a.r = null, a.d = a.l ? a.l.d + 1 : 1), p = !a.r, v && !a.l && _s(a, v), E && p && _s(a, E);
      }
    }
    function _s(a, c) {
      To(c) || function p(E, _) {
        var C = _.from, R = _.to, M = _.l, _ = _.r;
        Ns(E, C, R), M && p(E, M), _ && p(E, _);
      }(a, c);
    }
    function Di(a, c) {
      var p = bo(c), E = p.next();
      if (E.done)
        return false;
      for (var v = E.value, C = bo(a), R = C.next(v.from), M = R.value; !E.done && !R.done; ) {
        if (Me(M.from, v.to) <= 0 && 0 <= Me(M.to, v.from))
          return true;
        Me(v.from, M.from) < 0 ? v = (E = p.next(M.from)).value : M = (R = C.next(v.from)).value;
      }
      return false;
    }
    function bo(a) {
      var c = To(a) ? null : { s: 0, n: a };
      return { next: function(p) {
        for (var E = 0 < arguments.length; c; )
          switch (c.s) {
            case 0:
              if (c.s = 1, E)
                for (; c.n.l && Me(p, c.n.from) < 0; )
                  c = { up: c, n: c.n.l, s: 1 };
              else
                for (; c.n.l; )
                  c = { up: c, n: c.n.l, s: 1 };
            case 1:
              if (c.s = 2, !E || Me(p, c.n.to) <= 0)
                return { value: c.n, done: false };
            case 2:
              if (c.n.r) {
                c.s = 3, c = { up: c, n: c.n.r, s: 0 };
                continue;
              }
            case 3:
              c = c.up;
          }
        return { done: true };
      } };
    }
    function ol(a) {
      var c, p, E = (((c = a.r) === null || c === void 0 ? void 0 : c.d) || 0) - (((p = a.l) === null || p === void 0 ? void 0 : p.d) || 0), v = 1 < E ? "r" : E < -1 ? "l" : "";
      v && (c = v == "r" ? "l" : "r", p = n({}, a), E = a[v], a.from = E.from, a.to = E.to, a[v] = E[v], p[v] = E[c], (a[c] = p).d = al(p)), a.d = al(a);
    }
    function al(p) {
      var c = p.r, p = p.l;
      return (c ? p ? Math.max(c.d, p.d) : c.d : p ? p.d : 0) + 1;
    }
    function Li(a, c) {
      return r(c).forEach(function(p) {
        a[p] ? _s(a[p], c[p]) : a[p] = function E(v) {
          var C, R, M = {};
          for (C in v)
            m(v, C) && (R = v[C], M[C] = !R || typeof R != "object" || q.has(R.constructor) ? R : E(R));
          return M;
        }(c[p]);
      }), a;
    }
    function xo(a, c) {
      return a.all || c.all || Object.keys(a).some(function(p) {
        return c[p] && Di(c[p], a[p]);
      });
    }
    f(st.prototype, ((It = { add: function(a) {
      return _s(this, a), this;
    }, addKey: function(a) {
      return Ns(this, a, a), this;
    }, addKeys: function(a) {
      var c = this;
      return a.forEach(function(p) {
        return Ns(c, p, p);
      }), this;
    } })[Ie] = function() {
      return bo(this);
    }, It));
    var Fn = {}, So = {}, Ao = false;
    function Ni2(a) {
      Li(So, a), Ao || (Ao = true, setTimeout(function() {
        Ao = false, Ro(So, !(So = {}));
      }, 0));
    }
    function Ro(a, c) {
      c === void 0 && (c = false);
      var p = /* @__PURE__ */ new Set();
      if (a.all)
        for (var E = 0, v = Object.values(Fn); E < v.length; E++)
          ll(R = v[E], a, p, c);
      else
        for (var C in a) {
          var R, M = /^idb\:\/\/(.*)\/(.*)\//.exec(C);
          M && (C = M[1], M = M[2], (R = Fn["idb://".concat(C, "/").concat(M)]) && ll(R, a, p, c));
        }
      p.forEach(function(_) {
        return _();
      });
    }
    function ll(a, c, p, E) {
      for (var v = [], C = 0, R = Object.entries(a.queries.query); C < R.length; C++) {
        for (var M = R[C], _ = M[0], L = [], z = 0, D = M[1]; z < D.length; z++) {
          var V = D[z];
          xo(c, V.obsSet) ? V.subscribers.forEach(function(U) {
            return p.add(U);
          }) : E && L.push(V);
        }
        E && v.push([_, L]);
      }
      if (E)
        for (var N = 0, B = v; N < B.length; N++) {
          var G = B[N], _ = G[0], L = G[1];
          a.queries.query[_] = L;
        }
    }
    function Xh(a) {
      var c = a._state, p = a._deps.indexedDB;
      if (c.isBeingOpened || a.idbdb)
        return c.dbReadyPromise.then(function() {
          return c.dbOpenError ? Xe(c.dbOpenError) : a;
        });
      c.isBeingOpened = true, c.dbOpenError = null, c.openComplete = false;
      var E = c.openCanceller, v = Math.round(10 * a.verno), C = false;
      function R() {
        if (c.openCanceller !== E)
          throw new pe.DatabaseClosed("db.open() was cancelled");
      }
      function M() {
        return new he(function(V, N) {
          if (R(), !p)
            throw new pe.MissingAPI();
          var B = a.name, G = c.autoSchema || !v ? p.open(B) : p.open(B, v);
          if (!G)
            throw new pe.MissingAPI();
          G.onerror = Bt(N), G.onblocked = ze(a._fireOnBlocked), G.onupgradeneeded = ze(function(U) {
            var W;
            z = G.transaction, c.autoSchema && !a._options.allowEmptyDB ? (G.onerror = Ms, z.abort(), G.result.close(), (W = p.deleteDatabase(B)).onsuccess = W.onerror = ze(function() {
              N(new pe.NoSuchDatabase("Database ".concat(B, " doesnt exist")));
            })) : (z.onerror = Bt(N), U = U.oldVersion > Math.pow(2, 62) ? 0 : U.oldVersion, D = U < 1, a.idbdb = G.result, C && Kh(a, z), Wh(a, U / 10, z, N));
          }, N), G.onsuccess = ze(function() {
            z = null;
            var U, W, j, X, Q, ee = a.idbdb = G.result, le = F(ee.objectStoreNames);
            if (0 < le.length)
              try {
                var ie = ee.transaction((X = le).length === 1 ? X[0] : X, "readonly");
                if (c.autoSchema)
                  W = ee, j = ie, (U = a).verno = W.version / 10, j = U._dbSchema = Pi(0, W, j), U._storeNames = F(W.objectStoreNames, 0), Ri(U, [U._allTables], r(j), j);
                else if (Mi(a, a._dbSchema, ie), ((Q = vo(Pi(0, (Q = a).idbdb, ie), Q._dbSchema)).add.length || Q.change.some(function(oe) {
                  return oe.add.length || oe.change.length;
                })) && !C)
                  return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), ee.close(), v = ee.version + 1, C = true, V(M());
                Ai(a, ie);
              } catch {
              }
            Wn.push(a), ee.onversionchange = ze(function(oe) {
              c.vcFired = true, a.on("versionchange").fire(oe);
            }), ee.onclose = ze(function(oe) {
              a.on("close").fire(oe);
            }), D && (Q = a._deps, ie = B, ee = Q.indexedDB, Q = Q.IDBKeyRange, wo(ee) || ie === Ci || yo(ee, Q).put({ name: ie }).catch(Oe)), V();
          }, N);
        }).catch(function(V) {
          switch (V == null ? void 0 : V.name) {
            case "UnknownError":
              if (0 < c.PR1398_maxLoop)
                return c.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), M();
              break;
            case "VersionError":
              if (0 < v)
                return v = 0, M();
          }
          return he.reject(V);
        });
      }
      var _, L = c.dbReadyResolve, z = null, D = false;
      return he.race([E, (typeof navigator > "u" ? he.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(V) {
        function N() {
          return indexedDB.databases().finally(V);
        }
        _ = setInterval(N, 100), N();
      }).finally(function() {
        return clearInterval(_);
      }) : Promise.resolve()).then(M)]).then(function() {
        return R(), c.onReadyBeingFired = [], he.resolve(Co(function() {
          return a.on.ready.fire(a.vip);
        })).then(function V() {
          if (0 < c.onReadyBeingFired.length) {
            var N = c.onReadyBeingFired.reduce(Jr, Oe);
            return c.onReadyBeingFired = [], he.resolve(Co(function() {
              return N(a.vip);
            })).then(V);
          }
        });
      }).finally(function() {
        c.openCanceller === E && (c.onReadyBeingFired = null, c.isBeingOpened = false);
      }).catch(function(V) {
        c.dbOpenError = V;
        try {
          z && z.abort();
        } catch {
        }
        return E === c.openCanceller && a._close(), Xe(V);
      }).finally(function() {
        c.openComplete = true, L();
      }).then(function() {
        var V;
        return D && (V = {}, a.tables.forEach(function(N) {
          N.schema.indexes.forEach(function(B) {
            B.name && (V["idb://".concat(a.name, "/").concat(N.name, "/").concat(B.name)] = new st(-1 / 0, [[[]]]));
          }), V["idb://".concat(a.name, "/").concat(N.name, "/")] = V["idb://".concat(a.name, "/").concat(N.name, "/:dels")] = new st(-1 / 0, [[[]]]);
        }), un(Os).fire(V), Ro(V, true)), a;
      });
    }
    function Fo(a) {
      function c(C) {
        return a.next(C);
      }
      var p = v(c), E = v(function(C) {
        return a.throw(C);
      });
      function v(C) {
        return function(_) {
          var M = C(_), _ = M.value;
          return M.done ? _ : _ && typeof _.then == "function" ? _.then(p, E) : o(_) ? Promise.all(_).then(p, E) : p(_);
        };
      }
      return v(c)();
    }
    function _i(a, c, p) {
      for (var E = o(a) ? a.slice() : [a], v = 0; v < p; ++v)
        E.push(c);
      return E;
    }
    var Zh = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(a) {
      return n(n({}, a), { table: function(c) {
        var p = a.table(c), E = p.schema, v = {}, C = [];
        function R(D, V, N) {
          var B = Ls(D), G = v[B] = v[B] || [], U = D == null ? 0 : typeof D == "string" ? 1 : D.length, W = 0 < V, W = n(n({}, N), { name: W ? "".concat(B, "(virtual-from:").concat(N.name, ")") : N.name, lowLevelIndex: N, isVirtual: W, keyTail: V, keyLength: U, extractKey: go(D), unique: !W && N.unique });
          return G.push(W), W.isPrimaryKey || C.push(W), 1 < U && R(U === 2 ? D[0] : D.slice(0, U - 1), V + 1, N), G.sort(function(j, X) {
            return j.keyTail - X.keyTail;
          }), W;
        }
        c = R(E.primaryKey.keyPath, 0, E.primaryKey), v[":id"] = [c];
        for (var M = 0, _ = E.indexes; M < _.length; M++) {
          var L = _[M];
          R(L.keyPath, 0, L);
        }
        function z(D) {
          var V, N = D.query.index;
          return N.isVirtual ? n(n({}, D), { query: { index: N.lowLevelIndex, range: (V = D.query.range, N = N.keyTail, { type: V.type === 1 ? 2 : V.type, lower: _i(V.lower, V.lowerOpen ? a.MAX_KEY : a.MIN_KEY, N), lowerOpen: true, upper: _i(V.upper, V.upperOpen ? a.MIN_KEY : a.MAX_KEY, N), upperOpen: true }) } }) : D;
        }
        return n(n({}, p), { schema: n(n({}, E), { primaryKey: c, indexes: C, getIndexByKeyPath: function(D) {
          return (D = v[Ls(D)]) && D[0];
        } }), count: function(D) {
          return p.count(z(D));
        }, query: function(D) {
          return p.query(z(D));
        }, openCursor: function(D) {
          var V = D.query.index, N = V.keyTail, B = V.isVirtual, G = V.keyLength;
          return B ? p.openCursor(z(D)).then(function(W) {
            return W && U(W);
          }) : p.openCursor(D);
          function U(W) {
            return Object.create(W, { continue: { value: function(j) {
              j != null ? W.continue(_i(j, D.reverse ? a.MAX_KEY : a.MIN_KEY, N)) : D.unique ? W.continue(W.key.slice(0, G).concat(D.reverse ? a.MIN_KEY : a.MAX_KEY, N)) : W.continue();
            } }, continuePrimaryKey: { value: function(j, X) {
              W.continuePrimaryKey(_i(j, a.MAX_KEY, N), X);
            } }, primaryKey: { get: function() {
              return W.primaryKey;
            } }, key: { get: function() {
              var j = W.key;
              return G === 1 ? j[0] : j.slice(0, G);
            } }, value: { get: function() {
              return W.value;
            } } });
          }
        } });
      } });
    } };
    function Po(a, c, p, E) {
      return p = p || {}, E = E || "", r(a).forEach(function(v) {
        var C, R, M;
        m(c, v) ? (C = a[v], R = c[v], typeof C == "object" && typeof R == "object" && C && R ? (M = me(C)) !== me(R) ? p[E + v] = c[v] : M === "Object" ? Po(C, R, p, E + v + ".") : C !== R && (p[E + v] = c[v]) : C !== R && (p[E + v] = c[v])) : p[E + v] = void 0;
      }), r(c).forEach(function(v) {
        m(a, v) || (p[E + v] = c[v]);
      }), p;
    }
    function Mo(a, c) {
      return c.type === "delete" ? c.keys : c.keys || c.values.map(a.extractKey);
    }
    var Qh = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(a) {
      return n(n({}, a), { table: function(c) {
        var p = a.table(c), E = p.schema.primaryKey;
        return n(n({}, p), { mutate: function(v) {
          var C = ge.trans, R = C.table(c).hook, M = R.deleting, _ = R.creating, L = R.updating;
          switch (v.type) {
            case "add":
              if (_.fire === Oe)
                break;
              return C._promise("readwrite", function() {
                return z(v);
              }, true);
            case "put":
              if (_.fire === Oe && L.fire === Oe)
                break;
              return C._promise("readwrite", function() {
                return z(v);
              }, true);
            case "delete":
              if (M.fire === Oe)
                break;
              return C._promise("readwrite", function() {
                return z(v);
              }, true);
            case "deleteRange":
              if (M.fire === Oe)
                break;
              return C._promise("readwrite", function() {
                return function D(V, N, B) {
                  return p.query({ trans: V, values: false, query: { index: E, range: N }, limit: B }).then(function(G) {
                    var U = G.result;
                    return z({ type: "delete", keys: U, trans: V }).then(function(W) {
                      return 0 < W.numFailures ? Promise.reject(W.failures[0]) : U.length < B ? { failures: [], numFailures: 0, lastResult: void 0 } : D(V, n(n({}, N), { lower: U[U.length - 1], lowerOpen: true }), B);
                    });
                  });
                }(v.trans, v.range, 1e4);
              }, true);
          }
          return p.mutate(v);
          function z(D) {
            var V, N, B, G = ge.trans, U = D.keys || Mo(E, D);
            if (!U)
              throw new Error("Keys missing");
            return (D = D.type === "add" || D.type === "put" ? n(n({}, D), { keys: U }) : n({}, D)).type !== "delete" && (D.values = s([], D.values)), D.keys && (D.keys = s([], D.keys)), V = p, B = U, ((N = D).type === "add" ? Promise.resolve([]) : V.getMany({ trans: N.trans, keys: B, cache: "immutable" })).then(function(W) {
              var j = U.map(function(X, Q) {
                var ee, le, ie, oe = W[Q], ce = { onerror: null, onsuccess: null };
                return D.type === "delete" ? M.fire.call(ce, X, oe, G) : D.type === "add" || oe === void 0 ? (ee = _.fire.call(ce, X, D.values[Q], G), X == null && ee != null && (D.keys[Q] = X = ee, E.outbound || Y(D.values[Q], E.keyPath, X))) : (ee = Po(oe, D.values[Q]), (le = L.fire.call(ce, ee, X, oe, G)) && (ie = D.values[Q], Object.keys(le).forEach(function(re) {
                  m(ie, re) ? ie[re] = le[re] : Y(ie, re, le[re]);
                }))), ce;
              });
              return p.mutate(D).then(function(X) {
                for (var Q = X.failures, ee = X.results, le = X.numFailures, X = X.lastResult, ie = 0; ie < U.length; ++ie) {
                  var oe = (ee || U)[ie], ce = j[ie];
                  oe == null ? ce.onerror && ce.onerror(Q[ie]) : ce.onsuccess && ce.onsuccess(D.type === "put" && W[ie] ? D.values[ie] : oe);
                }
                return { failures: Q, results: ee, numFailures: le, lastResult: X };
              }).catch(function(X) {
                return j.forEach(function(Q) {
                  return Q.onerror && Q.onerror(X);
                }), Promise.reject(X);
              });
            });
          }
        } });
      } });
    } };
    function cl(a, c, p) {
      try {
        if (!c || c.keys.length < a.length)
          return null;
        for (var E = [], v = 0, C = 0; v < c.keys.length && C < a.length; ++v)
          Me(c.keys[v], a[C]) === 0 && (E.push(p ? se(c.values[v]) : c.values[v]), ++C);
        return E.length === a.length ? E : null;
      } catch {
        return null;
      }
    }
    var qh = { stack: "dbcore", level: -1, create: function(a) {
      return { table: function(c) {
        var p = a.table(c);
        return n(n({}, p), { getMany: function(E) {
          if (!E.cache)
            return p.getMany(E);
          var v = cl(E.keys, E.trans._cache, E.cache === "clone");
          return v ? he.resolve(v) : p.getMany(E).then(function(C) {
            return E.trans._cache = { keys: E.keys, values: E.cache === "clone" ? se(C) : C }, C;
          });
        }, mutate: function(E) {
          return E.type !== "add" && (E.trans._cache = null), p.mutate(E);
        } });
      } };
    } };
    function hl(a, c) {
      return a.trans.mode === "readonly" && !!a.subscr && !a.trans.explicit && a.trans.db._options.cache !== "disabled" && !c.schema.primaryKey.outbound;
    }
    function ul(a, c) {
      switch (a) {
        case "query":
          return c.values && !c.unique;
        case "get":
        case "getMany":
        case "count":
        case "openCursor":
          return false;
      }
    }
    var Jh = { stack: "dbcore", level: 0, name: "Observability", create: function(a) {
      var c = a.schema.name, p = new st(a.MIN_KEY, a.MAX_KEY);
      return n(n({}, a), { transaction: function(E, v, C) {
        if (ge.subscr && v !== "readonly")
          throw new pe.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(ge.querier));
        return a.transaction(E, v, C);
      }, table: function(E) {
        var v = a.table(E), C = v.schema, R = C.primaryKey, D = C.indexes, M = R.extractKey, _ = R.outbound, L = R.autoIncrement && D.filter(function(N) {
          return N.compound && N.keyPath.includes(R.keyPath);
        }), z = n(n({}, v), { mutate: function(N) {
          function B(re) {
            return re = "idb://".concat(c, "/").concat(E, "/").concat(re), X[re] || (X[re] = new st());
          }
          var G, U, W, j = N.trans, X = N.mutatedParts || (N.mutatedParts = {}), Q = B(""), ee = B(":dels"), le = N.type, ce = N.type === "deleteRange" ? [N.range] : N.type === "delete" ? [N.keys] : N.values.length < 50 ? [Mo(R, N).filter(function(re) {
            return re;
          }), N.values] : [], ie = ce[0], oe = ce[1], ce = N.trans._cache;
          return o(ie) ? (Q.addKeys(ie), (ce = le === "delete" || ie.length === oe.length ? cl(ie, ce) : null) || ee.addKeys(ie), (ce || oe) && (G = B, U = ce, W = oe, C.indexes.forEach(function(re) {
            var Ce = G(re.name || "");
            function Te(xe) {
              return xe != null ? re.extractKey(xe) : null;
            }
            function Ae(xe) {
              return re.multiEntry && o(xe) ? xe.forEach(function(Rt) {
                return Ce.addKey(Rt);
              }) : Ce.addKey(xe);
            }
            (U || W).forEach(function(xe, it) {
              var Se = U && Te(U[it]), it = W && Te(W[it]);
              Me(Se, it) !== 0 && (Se != null && Ae(Se), it != null && Ae(it));
            });
          }))) : ie ? (oe = { from: ie.lower, to: ie.upper }, ee.add(oe), Q.add(oe)) : (Q.add(p), ee.add(p), C.indexes.forEach(function(re) {
            return B(re.name).add(p);
          })), v.mutate(N).then(function(re) {
            return !ie || N.type !== "add" && N.type !== "put" || (Q.addKeys(re.results), L && L.forEach(function(Ce) {
              var Te = N.values.map(function(xe) {
                return Ce.extractKey(xe);
              }), Ae = Ce.keyPath.findIndex(function(xe) {
                return xe === R.keyPath;
              });
              re.results.forEach(function(xe) {
                return Te[Ae] = xe;
              }), B(Ce.name).addKeys(Te);
            })), j.mutatedParts = Li(j.mutatedParts || {}, X), re;
          });
        } }), D = function(B) {
          var G = B.query, B = G.index, G = G.range;
          return [B, new st((B = G.lower) !== null && B !== void 0 ? B : a.MIN_KEY, (G = G.upper) !== null && G !== void 0 ? G : a.MAX_KEY)];
        }, V = { get: function(N) {
          return [R, new st(N.key)];
        }, getMany: function(N) {
          return [R, new st().addKeys(N.keys)];
        }, count: D, query: D, openCursor: D };
        return r(V).forEach(function(N) {
          z[N] = function(B) {
            var G = ge.subscr, U = !!G, W = hl(ge, v) && ul(N, B) ? B.obsSet = {} : G;
            if (U) {
              var j = function(oe) {
                return oe = "idb://".concat(c, "/").concat(E, "/").concat(oe), W[oe] || (W[oe] = new st());
              }, X = j(""), Q = j(":dels"), G = V[N](B), U = G[0], G = G[1];
              if ((N === "query" && U.isPrimaryKey && !B.values ? Q : j(U.name || "")).add(G), !U.isPrimaryKey) {
                if (N !== "count") {
                  var ee = N === "query" && _ && B.values && v.query(n(n({}, B), { values: false }));
                  return v[N].apply(this, arguments).then(function(oe) {
                    if (N === "query") {
                      if (_ && B.values)
                        return ee.then(function(Te) {
                          return Te = Te.result, X.addKeys(Te), oe;
                        });
                      var ce = B.values ? oe.result.map(M) : oe.result;
                      (B.values ? X : Q).addKeys(ce);
                    } else if (N === "openCursor") {
                      var re = oe, Ce = B.values;
                      return re && Object.create(re, { key: { get: function() {
                        return Q.addKey(re.primaryKey), re.key;
                      } }, primaryKey: { get: function() {
                        var Te = re.primaryKey;
                        return Q.addKey(Te), Te;
                      } }, value: { get: function() {
                        return Ce && X.addKey(re.primaryKey), re.value;
                      } } });
                    }
                    return oe;
                  });
                }
                Q.add(p);
              }
            }
            return v[N].apply(this, arguments);
          };
        }), z;
      } });
    } };
    function dl(a, c, p) {
      if (p.numFailures === 0)
        return c;
      if (c.type === "deleteRange")
        return null;
      var E = c.keys ? c.keys.length : "values" in c && c.values ? c.values.length : 1;
      return p.numFailures === E ? null : (c = n({}, c), o(c.keys) && (c.keys = c.keys.filter(function(v, C) {
        return !(C in p.failures);
      })), "values" in c && o(c.values) && (c.values = c.values.filter(function(v, C) {
        return !(C in p.failures);
      })), c);
    }
    function Oo(a, c) {
      return p = a, ((E = c).lower === void 0 || (E.lowerOpen ? 0 < Me(p, E.lower) : 0 <= Me(p, E.lower))) && (a = a, (c = c).upper === void 0 || (c.upperOpen ? Me(a, c.upper) < 0 : Me(a, c.upper) <= 0));
      var p, E;
    }
    function fl(a, c, V, E, v, C) {
      if (!V || V.length === 0)
        return a;
      var R = c.query.index, M = R.multiEntry, _ = c.query.range, L = E.schema.primaryKey.extractKey, z = R.extractKey, D = (R.lowLevelIndex || R).extractKey, V = V.reduce(function(N, B) {
        var G = N, U = B.type === "add" || B.type === "put" ? B.values.filter(function(Q) {
          return Q = z(Q), M && o(Q) ? Q.some(function(ee) {
            return Oo(ee, _);
          }) : Oo(Q, _);
        }).map(function(Q) {
          return Q = se(Q), C && Object.freeze(Q), Q;
        }) : [];
        switch (B.type) {
          case "add":
            G = N.concat(c.values ? U : U.map(function(ee) {
              return L(ee);
            }));
            break;
          case "put":
            var W = new st().addKeys(B.values.map(function(ee) {
              return L(ee);
            })), G = N.filter(function(ee) {
              return ee = c.values ? L(ee) : ee, !Di(new st(ee), W);
            }).concat(c.values ? U : U.map(function(ee) {
              return L(ee);
            }));
            break;
          case "delete":
            var j = new st().addKeys(B.keys);
            G = N.filter(function(ee) {
              return ee = c.values ? L(ee) : ee, !Di(new st(ee), j);
            });
            break;
          case "deleteRange":
            var X = B.range;
            G = N.filter(function(ee) {
              return !Oo(L(ee), X);
            });
        }
        return G;
      }, a);
      return V === a ? a : (V.sort(function(N, B) {
        return Me(D(N), D(B)) || Me(L(N), L(B));
      }), c.limit && c.limit < 1 / 0 && (V.length > c.limit ? V.length = c.limit : a.length === c.limit && V.length < c.limit && (v.dirty = true)), C ? Object.freeze(V) : V);
    }
    function pl(a, c) {
      return Me(a.lower, c.lower) === 0 && Me(a.upper, c.upper) === 0 && !!a.lowerOpen == !!c.lowerOpen && !!a.upperOpen == !!c.upperOpen;
    }
    function $h(a, c) {
      return function(p, E, v, C) {
        if (p === void 0)
          return E !== void 0 ? -1 : 0;
        if (E === void 0)
          return 1;
        if ((E = Me(p, E)) === 0) {
          if (v && C)
            return 0;
          if (v)
            return 1;
          if (C)
            return -1;
        }
        return E;
      }(a.lower, c.lower, a.lowerOpen, c.lowerOpen) <= 0 && 0 <= function(p, E, v, C) {
        if (p === void 0)
          return E !== void 0 ? 1 : 0;
        if (E === void 0)
          return -1;
        if ((E = Me(p, E)) === 0) {
          if (v && C)
            return 0;
          if (v)
            return -1;
          if (C)
            return 1;
        }
        return E;
      }(a.upper, c.upper, a.upperOpen, c.upperOpen);
    }
    function eu(a, c, p, E) {
      a.subscribers.add(p), E.addEventListener("abort", function() {
        var v, C;
        a.subscribers.delete(p), a.subscribers.size === 0 && (v = a, C = c, setTimeout(function() {
          v.subscribers.size === 0 && de(C, v);
        }, 3e3));
      });
    }
    var tu = { stack: "dbcore", level: 0, name: "Cache", create: function(a) {
      var c = a.schema.name;
      return n(n({}, a), { transaction: function(p, E, v) {
        var C, R, M = a.transaction(p, E, v);
        return E === "readwrite" && (R = (C = new AbortController()).signal, v = function(_) {
          return function() {
            if (C.abort(), E === "readwrite") {
              for (var L = /* @__PURE__ */ new Set(), z = 0, D = p; z < D.length; z++) {
                var V = D[z], N = Fn["idb://".concat(c, "/").concat(V)];
                if (N) {
                  var B = a.table(V), G = N.optimisticOps.filter(function(Ce) {
                    return Ce.trans === M;
                  });
                  if (M._explicit && _ && M.mutatedParts)
                    for (var U = 0, W = Object.values(N.queries.query); U < W.length; U++)
                      for (var j = 0, X = (le = W[U]).slice(); j < X.length; j++)
                        xo((ie = X[j]).obsSet, M.mutatedParts) && (de(le, ie), ie.subscribers.forEach(function(Ce) {
                          return L.add(Ce);
                        }));
                  else if (0 < G.length) {
                    N.optimisticOps = N.optimisticOps.filter(function(Ce) {
                      return Ce.trans !== M;
                    });
                    for (var Q = 0, ee = Object.values(N.queries.query); Q < ee.length; Q++)
                      for (var le, ie, oe, ce = 0, re = (le = ee[Q]).slice(); ce < re.length; ce++)
                        (ie = re[ce]).res != null && M.mutatedParts && (_ && !ie.dirty ? (oe = Object.isFrozen(ie.res), oe = fl(ie.res, ie.req, G, B, ie, oe), ie.dirty ? (de(le, ie), ie.subscribers.forEach(function(Ce) {
                          return L.add(Ce);
                        })) : oe !== ie.res && (ie.res = oe, ie.promise = he.resolve({ result: oe }))) : (ie.dirty && de(le, ie), ie.subscribers.forEach(function(Ce) {
                          return L.add(Ce);
                        })));
                  }
                }
              }
              L.forEach(function(Ce) {
                return Ce();
              });
            }
          };
        }, M.addEventListener("abort", v(false), { signal: R }), M.addEventListener("error", v(false), { signal: R }), M.addEventListener("complete", v(true), { signal: R })), M;
      }, table: function(p) {
        var E = a.table(p), v = E.schema.primaryKey;
        return n(n({}, E), { mutate: function(C) {
          var R = ge.trans;
          if (v.outbound || R.db._options.cache === "disabled" || R.explicit)
            return E.mutate(C);
          var M = Fn["idb://".concat(c, "/").concat(p)];
          return M ? (R = E.mutate(C), C.type !== "add" && C.type !== "put" || !(50 <= C.values.length || Mo(v, C).some(function(_) {
            return _ == null;
          })) ? (M.optimisticOps.push(C), C.mutatedParts && Ni2(C.mutatedParts), R.then(function(_) {
            0 < _.numFailures && (de(M.optimisticOps, C), (_ = dl(0, C, _)) && M.optimisticOps.push(_), C.mutatedParts && Ni2(C.mutatedParts));
          }), R.catch(function() {
            de(M.optimisticOps, C), C.mutatedParts && Ni2(C.mutatedParts);
          })) : R.then(function(_) {
            var L = dl(0, n(n({}, C), { values: C.values.map(function(N, D) {
              var V, N = (V = v.keyPath) !== null && V !== void 0 && V.includes(".") ? se(N) : n({}, N);
              return Y(N, v.keyPath, _.results[D]), N;
            }) }), _);
            M.optimisticOps.push(L), queueMicrotask(function() {
              return C.mutatedParts && Ni2(C.mutatedParts);
            });
          }), R) : E.mutate(C);
        }, query: function(C) {
          if (!hl(ge, E) || !ul("query", C))
            return E.query(C);
          var R = ((L = ge.trans) === null || L === void 0 ? void 0 : L.db._options.cache) === "immutable", D = ge, M = D.requery, _ = D.signal, L = function(B, G, U, W) {
            var j = Fn["idb://".concat(B, "/").concat(G)];
            if (!j)
              return [];
            if (!(G = j.queries[U]))
              return [null, false, j, null];
            var X = G[(W.query ? W.query.index.name : null) || ""];
            if (!X)
              return [null, false, j, null];
            switch (U) {
              case "query":
                var Q = X.find(function(ee) {
                  return ee.req.limit === W.limit && ee.req.values === W.values && pl(ee.req.query.range, W.query.range);
                });
                return Q ? [Q, true, j, X] : [X.find(function(ee) {
                  return ("limit" in ee.req ? ee.req.limit : 1 / 0) >= W.limit && (!W.values || ee.req.values) && $h(ee.req.query.range, W.query.range);
                }), false, j, X];
              case "count":
                return Q = X.find(function(ee) {
                  return pl(ee.req.query.range, W.query.range);
                }), [Q, !!Q, j, X];
            }
          }(c, p, "query", C), z = L[0], D = L[1], V = L[2], N = L[3];
          return z && D ? z.obsSet = C.obsSet : (D = E.query(C).then(function(B) {
            var G = B.result;
            if (z && (z.res = G), R) {
              for (var U = 0, W = G.length; U < W; ++U)
                Object.freeze(G[U]);
              Object.freeze(G);
            } else
              B.result = se(G);
            return B;
          }).catch(function(B) {
            return N && z && de(N, z), Promise.reject(B);
          }), z = { obsSet: C.obsSet, promise: D, subscribers: /* @__PURE__ */ new Set(), type: "query", req: C, dirty: false }, N ? N.push(z) : (N = [z], (V = V || (Fn["idb://".concat(c, "/").concat(p)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[C.query.index.name || ""] = N)), eu(z, N, M, _), z.promise.then(function(B) {
            return { result: fl(B.result, C, V == null ? void 0 : V.optimisticOps, E, z, R) };
          });
        } });
      } });
    } };
    function Ui(a, c) {
      return new Proxy(a, { get: function(p, E, v) {
        return E === "db" ? c : Reflect.get(p, E, v);
      } });
    }
    var $t = (Ze.prototype.version = function(a) {
      if (isNaN(a) || a < 0.1)
        throw new pe.Type("Given version is not a positive number");
      if (a = Math.round(10 * a) / 10, this.idbdb || this._state.isBeingOpened)
        throw new pe.Schema("Cannot add version when database is open");
      this.verno = Math.max(this.verno, a);
      var c = this._versions, p = c.filter(function(E) {
        return E._cfg.version === a;
      })[0];
      return p || (p = new this.Version(a), c.push(p), c.sort(Hh), p.stores({}), this._state.autoSchema = false, p);
    }, Ze.prototype._whenReady = function(a) {
      var c = this;
      return this.idbdb && (this._state.openComplete || ge.letThrough || this._vip) ? a() : new he(function(p, E) {
        if (c._state.openComplete)
          return E(new pe.DatabaseClosed(c._state.dbOpenError));
        if (!c._state.isBeingOpened) {
          if (!c._state.autoOpen)
            return void E(new pe.DatabaseClosed());
          c.open().catch(Oe);
        }
        c._state.dbReadyPromise.then(p, E);
      }).then(a);
    }, Ze.prototype.use = function(a) {
      var c = a.stack, p = a.create, E = a.level, v = a.name;
      return v && this.unuse({ stack: c, name: v }), a = this._middlewares[c] || (this._middlewares[c] = []), a.push({ stack: c, create: p, level: E ?? 10, name: v }), a.sort(function(C, R) {
        return C.level - R.level;
      }), this;
    }, Ze.prototype.unuse = function(a) {
      var c = a.stack, p = a.name, E = a.create;
      return c && this._middlewares[c] && (this._middlewares[c] = this._middlewares[c].filter(function(v) {
        return E ? v.create !== E : !!p && v.name !== p;
      })), this;
    }, Ze.prototype.open = function() {
      var a = this;
      return Sn(on, function() {
        return Xh(a);
      });
    }, Ze.prototype._close = function() {
      var a = this._state, c = Wn.indexOf(this);
      if (0 <= c && Wn.splice(c, 1), this.idbdb) {
        try {
          this.idbdb.close();
        } catch {
        }
        this.idbdb = null;
      }
      a.isBeingOpened || (a.dbReadyPromise = new he(function(p) {
        a.dbReadyResolve = p;
      }), a.openCanceller = new he(function(p, E) {
        a.cancelOpen = E;
      }));
    }, Ze.prototype.close = function(p) {
      var c = (p === void 0 ? { disableAutoOpen: true } : p).disableAutoOpen, p = this._state;
      c ? (p.isBeingOpened && p.cancelOpen(new pe.DatabaseClosed()), this._close(), p.autoOpen = false, p.dbOpenError = new pe.DatabaseClosed()) : (this._close(), p.autoOpen = this._options.autoOpen || p.isBeingOpened, p.openComplete = false, p.dbOpenError = null);
    }, Ze.prototype.delete = function(a) {
      var c = this;
      a === void 0 && (a = { disableAutoOpen: true });
      var p = 0 < arguments.length && typeof arguments[0] != "object", E = this._state;
      return new he(function(v, C) {
        function R() {
          c.close(a);
          var M = c._deps.indexedDB.deleteDatabase(c.name);
          M.onsuccess = ze(function() {
            var _, L, z;
            _ = c._deps, L = c.name, z = _.indexedDB, _ = _.IDBKeyRange, wo(z) || L === Ci || yo(z, _).delete(L).catch(Oe), v();
          }), M.onerror = Bt(C), M.onblocked = c._fireOnBlocked;
        }
        if (p)
          throw new pe.InvalidArgument("Invalid closeOptions argument to db.delete()");
        E.isBeingOpened ? E.dbReadyPromise.then(R) : R();
      });
    }, Ze.prototype.backendDB = function() {
      return this.idbdb;
    }, Ze.prototype.isOpen = function() {
      return this.idbdb !== null;
    }, Ze.prototype.hasBeenClosed = function() {
      var a = this._state.dbOpenError;
      return a && a.name === "DatabaseClosed";
    }, Ze.prototype.hasFailed = function() {
      return this._state.dbOpenError !== null;
    }, Ze.prototype.dynamicallyOpened = function() {
      return this._state.autoSchema;
    }, Object.defineProperty(Ze.prototype, "tables", { get: function() {
      var a = this;
      return r(this._allTables).map(function(c) {
        return a._allTables[c];
      });
    }, enumerable: false, configurable: true }), Ze.prototype.transaction = function() {
      var a = (function(c, p, E) {
        var v = arguments.length;
        if (v < 2)
          throw new pe.InvalidArgument("Too few arguments");
        for (var C = new Array(v - 1); --v; )
          C[v - 1] = arguments[v];
        return E = C.pop(), [c, Z(C), E];
      }).apply(this, arguments);
      return this._transaction.apply(this, a);
    }, Ze.prototype._transaction = function(a, c, p) {
      var E = this, v = ge.trans;
      v && v.db === this && a.indexOf("!") === -1 || (v = null);
      var C, R, M = a.indexOf("?") !== -1;
      a = a.replace("!", "").replace("?", "");
      try {
        if (R = c.map(function(L) {
          if (L = L instanceof E.Table ? L.name : L, typeof L != "string")
            throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
          return L;
        }), a == "r" || a === ao)
          C = ao;
        else {
          if (a != "rw" && a != lo)
            throw new pe.InvalidArgument("Invalid transaction mode: " + a);
          C = lo;
        }
        if (v) {
          if (v.mode === ao && C === lo) {
            if (!M)
              throw new pe.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
            v = null;
          }
          v && R.forEach(function(L) {
            if (v && v.storeNames.indexOf(L) === -1) {
              if (!M)
                throw new pe.SubTransaction("Table " + L + " not included in parent transaction.");
              v = null;
            }
          }), M && v && !v.active && (v = null);
        }
      } catch (L) {
        return v ? v._promise(null, function(z, D) {
          D(L);
        }) : Xe(L);
      }
      var _ = (function L(z, D, V, N, B) {
        return he.resolve().then(function() {
          var G = ge.transless || ge, U = z._createTransaction(D, V, z._dbSchema, N);
          if (U.explicit = true, G = { trans: U, transless: G }, N)
            U.idbtrans = N.idbtrans;
          else
            try {
              U.create(), U.idbtrans._explicit = true, z._state.PR1398_maxLoop = 3;
            } catch (X) {
              return X.name === Qt.InvalidState && z.isOpen() && 0 < --z._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), z.close({ disableAutoOpen: false }), z.open().then(function() {
                return L(z, D, V, null, B);
              })) : Xe(X);
            }
          var W, j = Ke(B);
          return j && Hn(), G = he.follow(function() {
            var X;
            (W = B.call(U, U)) && (j ? (X = ln.bind(null, null), W.then(X, X)) : typeof W.next == "function" && typeof W.throw == "function" && (W = Fo(W)));
          }, G), (W && typeof W.then == "function" ? he.resolve(W).then(function(X) {
            return U.active ? X : Xe(new pe.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
          }) : G.then(function() {
            return W;
          })).then(function(X) {
            return N && U._resolve(), U._completion.then(function() {
              return X;
            });
          }).catch(function(X) {
            return U._reject(X), Xe(X);
          });
        });
      }).bind(null, this, C, R, v, p);
      return v ? v._promise(C, _, "lock") : ge.trans ? Sn(ge.transless, function() {
        return E._whenReady(_);
      }) : this._whenReady(_);
    }, Ze.prototype.table = function(a) {
      if (!m(this._allTables, a))
        throw new pe.InvalidTable("Table ".concat(a, " does not exist"));
      return this._allTables[a];
    }, Ze);
    function Ze(a, c) {
      var p = this;
      this._middlewares = {}, this.verno = 0;
      var E = Ze.dependencies;
      this._options = c = n({ addons: Ze.addons, autoOpen: true, indexedDB: E.indexedDB, IDBKeyRange: E.IDBKeyRange, cache: "cloned" }, c), this._deps = { indexedDB: c.indexedDB, IDBKeyRange: c.IDBKeyRange }, E = c.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
      var v, C, R, M, _, L = { dbOpenError: null, isBeingOpened: false, onReadyBeingFired: null, openComplete: false, dbReadyResolve: Oe, dbReadyPromise: null, cancelOpen: Oe, openCanceller: null, autoSchema: true, PR1398_maxLoop: 3, autoOpen: c.autoOpen };
      L.dbReadyPromise = new he(function(D) {
        L.dbReadyResolve = D;
      }), L.openCanceller = new he(function(D, V) {
        L.cancelOpen = V;
      }), this._state = L, this.name = a, this.on = Rs(this, "populate", "blocked", "versionchange", "close", { ready: [Jr, Oe] }), this.on.ready.subscribe = P(this.on.ready.subscribe, function(D) {
        return function(V, N) {
          Ze.vip(function() {
            var B, G = p._state;
            G.openComplete ? (G.dbOpenError || he.resolve().then(V), N && D(V)) : G.onReadyBeingFired ? (G.onReadyBeingFired.push(V), N && D(V)) : (D(V), B = p, N || D(function U() {
              B.on.ready.unsubscribe(V), B.on.ready.unsubscribe(U);
            }));
          });
        };
      }), this.Collection = (v = this, Fs(Uh.prototype, function(W, U) {
        this.db = v;
        var N = Ka, B = null;
        if (U)
          try {
            N = U();
          } catch (j) {
            B = j;
          }
        var G = W._ctx, U = G.table, W = U.hook.reading.fire;
        this._ctx = { table: U, index: G.index, isPrimKey: !G.index || U.schema.primKey.keyPath && G.index === U.schema.primKey.name, range: N, keysOnly: false, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: true, isMatch: null, offset: 0, limit: 1 / 0, error: B, or: G.or, valueMapper: W !== _t ? W : null };
      })), this.Table = (C = this, Fs(Qa.prototype, function(D, V, N) {
        this.db = C, this._tx = N, this.name = D, this.schema = V, this.hook = C._allTables[D] ? C._allTables[D].hook : Rs(null, { creating: [ws, Oe], reading: [qr, _t], updating: [Ph, Oe], deleting: [Cs, Oe] });
      })), this.Transaction = (R = this, Fs(zh.prototype, function(D, V, N, B, G) {
        var U = this;
        this.db = R, this.mode = D, this.storeNames = V, this.schema = N, this.chromeTransactionDurability = B, this.idbtrans = null, this.on = Rs(this, "complete", "error", "abort"), this.parent = G || null, this.active = true, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new he(function(W, j) {
          U._resolve = W, U._reject = j;
        }), this._completion.then(function() {
          U.active = false, U.on.complete.fire();
        }, function(W) {
          var j = U.active;
          return U.active = false, U.on.error.fire(W), U.parent ? U.parent._reject(W) : j && U.idbtrans && U.idbtrans.abort(), Xe(W);
        });
      })), this.Version = (M = this, Fs(jh.prototype, function(D) {
        this.db = M, this._cfg = { version: D, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
      })), this.WhereClause = (_ = this, Fs(tl.prototype, function(D, V, N) {
        if (this.db = _, this._ctx = { table: D, index: V === ":id" ? null : V, or: N }, this._cmp = this._ascending = Me, this._descending = function(B, G) {
          return Me(G, B);
        }, this._max = function(B, G) {
          return 0 < Me(B, G) ? B : G;
        }, this._min = function(B, G) {
          return Me(B, G) < 0 ? B : G;
        }, this._IDBKeyRange = _._deps.IDBKeyRange, !this._IDBKeyRange)
          throw new pe.MissingAPI();
      })), this.on("versionchange", function(D) {
        0 < D.newVersion ? console.warn("Another connection wants to upgrade database '".concat(p.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(p.name, "'. Closing db now to resume the delete request.")), p.close({ disableAutoOpen: false });
      }), this.on("blocked", function(D) {
        !D.newVersion || D.newVersion < D.oldVersion ? console.warn("Dexie.delete('".concat(p.name, "') was blocked")) : console.warn("Upgrade '".concat(p.name, "' blocked by other connection holding version ").concat(D.oldVersion / 10));
      }), this._maxKey = Ds(c.IDBKeyRange), this._createTransaction = function(D, V, N, B) {
        return new p.Transaction(D, V, N, p._options.chromeTransactionDurability, B);
      }, this._fireOnBlocked = function(D) {
        p.on("blocked").fire(D), Wn.filter(function(V) {
          return V.name === p.name && V !== p && !V._state.vcFired;
        }).map(function(V) {
          return V.on("versionchange").fire(D);
        });
      }, this.use(qh), this.use(tu), this.use(Jh), this.use(Zh), this.use(Qh);
      var z = new Proxy(this, { get: function(D, V, N) {
        if (V === "_vip")
          return true;
        if (V === "table")
          return function(G) {
            return Ui(p.table(G), z);
          };
        var B = Reflect.get(D, V, N);
        return B instanceof Qa ? Ui(B, z) : V === "tables" ? B.map(function(G) {
          return Ui(G, z);
        }) : V === "_createTransaction" ? function() {
          return Ui(B.apply(this, arguments), z);
        } : B;
      } });
      this.vip = z, E.forEach(function(D) {
        return D(p);
      });
    }
    var Bi, It = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", nu = (Do.prototype.subscribe = function(a, c, p) {
      return this._subscribe(a && typeof a != "function" ? a : { next: a, error: c, complete: p });
    }, Do.prototype[It] = function() {
      return this;
    }, Do);
    function Do(a) {
      this._subscribe = a;
    }
    try {
      Bi = { indexedDB: i.indexedDB || i.mozIndexedDB || i.webkitIndexedDB || i.msIndexedDB, IDBKeyRange: i.IDBKeyRange || i.webkitIDBKeyRange };
    } catch {
      Bi = { indexedDB: null, IDBKeyRange: null };
    }
    function ml(a) {
      var c, p = false, E = new nu(function(v) {
        var C = Ke(a), R, M = false, _ = {}, L = {}, z = { get closed() {
          return M;
        }, unsubscribe: function() {
          M || (M = true, R && R.abort(), D && un.storagemutated.unsubscribe(N));
        } };
        v.start && v.start(z);
        var D = false, V = function() {
          return oo(B);
        }, N = function(G) {
          Li(_, G), xo(L, _) && V();
        }, B = function() {
          var G, U, W;
          !M && Bi.indexedDB && (_ = {}, G = {}, R && R.abort(), R = new AbortController(), W = function(j) {
            var X = Gn();
            try {
              C && Hn();
              var Q = an(a, j);
              return Q = C ? Q.finally(ln) : Q;
            } finally {
              X && Yn();
            }
          }(U = { subscr: G, signal: R.signal, requery: V, querier: a, trans: null }), Promise.resolve(W).then(function(j) {
            p = true, c = j, M || U.signal.aborted || (_ = {}, function(X) {
              for (var Q in X)
                if (m(X, Q))
                  return;
              return 1;
            }(L = G) || D || (un(Os, N), D = true), oo(function() {
              return !M && v.next && v.next(j);
            }));
          }, function(j) {
            p = false, ["DatabaseClosedError", "AbortError"].includes(j == null ? void 0 : j.name) || M || oo(function() {
              M || v.error && v.error(j);
            });
          }));
        };
        return setTimeout(V, 0), z;
      });
      return E.hasValue = function() {
        return p;
      }, E.getValue = function() {
        return c;
      }, E;
    }
    var Pn = $t;
    function Lo(a) {
      var c = dn;
      try {
        dn = true, un.storagemutated.fire(a), Ro(a, true);
      } finally {
        dn = c;
      }
    }
    f(Pn, n(n({}, St), { delete: function(a) {
      return new Pn(a, { addons: [] }).delete();
    }, exists: function(a) {
      return new Pn(a, { addons: [] }).open().then(function(c) {
        return c.close(), true;
      }).catch("NoSuchDatabaseError", function() {
        return false;
      });
    }, getDatabaseNames: function(a) {
      try {
        return c = Pn.dependencies, p = c.indexedDB, c = c.IDBKeyRange, (wo(p) ? Promise.resolve(p.databases()).then(function(E) {
          return E.map(function(v) {
            return v.name;
          }).filter(function(v) {
            return v !== Ci;
          });
        }) : yo(p, c).toCollection().primaryKeys()).then(a);
      } catch {
        return Xe(new pe.MissingAPI());
      }
      var c, p;
    }, defineClass: function() {
      return function(a) {
        l(this, a);
      };
    }, ignoreTransaction: function(a) {
      return ge.trans ? Sn(ge.transless, a) : a();
    }, vip: Co, async: function(a) {
      return function() {
        try {
          var c = Fo(a.apply(this, arguments));
          return c && typeof c.then == "function" ? c : he.resolve(c);
        } catch (p) {
          return Xe(p);
        }
      };
    }, spawn: function(a, c, p) {
      try {
        var E = Fo(a.apply(p, c || []));
        return E && typeof E.then == "function" ? E : he.resolve(E);
      } catch (v) {
        return Xe(v);
      }
    }, currentTransaction: { get: function() {
      return ge.trans || null;
    } }, waitFor: function(a, c) {
      return c = he.resolve(typeof a == "function" ? Pn.ignoreTransaction(a) : a).timeout(c || 6e4), ge.trans ? ge.trans.waitFor(c) : c;
    }, Promise: he, debug: { get: function() {
      return Ut;
    }, set: function(a) {
      ka(a);
    } }, derive: y, extend: l, props: f, override: P, Events: Rs, on: un, liveQuery: ml, extendObservabilitySet: Li, getByKeyPath: k, setByKeyPath: Y, delByKeyPath: function(a, c) {
      typeof c == "string" ? Y(a, c, void 0) : "length" in c && [].map.call(c, function(p) {
        Y(a, p, void 0);
      });
    }, shallowClone: H, deepClone: se, getObjectDiff: Po, cmp: Me, asap: O, minKey: -1 / 0, addons: [], connections: Wn, errnames: Qt, dependencies: Bi, cache: Fn, semVer: "4.0.7", version: "4.0.7".split(".").map(function(a) {
      return parseInt(a);
    }).reduce(function(a, c, p) {
      return a + c / Math.pow(10, 2 * p);
    }) })), Pn.maxKey = Ds(Pn.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (un(Os, function(a) {
      dn || (a = new CustomEvent(fo, { detail: a }), dn = true, dispatchEvent(a), dn = false);
    }), addEventListener(fo, function(a) {
      a = a.detail, dn || Lo(a);
    }));
    var Xn, dn = false, gl = function() {
    };
    return typeof BroadcastChannel < "u" && ((gl = function() {
      (Xn = new BroadcastChannel(fo)).onmessage = function(a) {
        return a.data && Lo(a.data);
      };
    })(), typeof Xn.unref == "function" && Xn.unref(), un(Os, function(a) {
      dn || Xn.postMessage(a);
    })), typeof addEventListener < "u" && (addEventListener("pagehide", function(a) {
      if (!$t.disableBfCache && a.persisted) {
        Ut && console.debug("Dexie: handling persisted pagehide"), Xn != null && Xn.close();
        for (var c = 0, p = Wn; c < p.length; c++)
          p[c].close({ disableAutoOpen: false });
      }
    }), addEventListener("pageshow", function(a) {
      !$t.disableBfCache && a.persisted && (Ut && console.debug("Dexie: handling persisted pageshow"), gl(), Lo({ all: new st(-1 / 0, [[]]) }));
    })), he.rejectionMapper = function(a, c) {
      return !a || a instanceof vt || a instanceof TypeError || a instanceof SyntaxError || !a.name || !Ge[a.name] ? a : (c = new Ge[a.name](c || a.message, a), "stack" in a && I(c, "stack", { get: function() {
        return this.inner.stack;
      } }), c);
    }, ka(Ut), n($t, Object.freeze({ __proto__: null, Dexie: $t, liveQuery: ml, Entity: ja, cmp: Me, PropModSymbol: Jt, PropModification: Ps, replacePrefix: function(a, c) {
      return new Ps({ replacePrefix: [a, c] });
    }, add: function(a) {
      return new Ps({ add: a });
    }, remove: function(a) {
      return new Ps({ remove: a });
    }, default: $t, RangeSet: st, mergeRanges: _s, rangesOverlap: Di }), { default: $t }), $t;
  });
})(Fh);
var Mp = Fh.exports;
var Sa = yh(Mp);
var bc = Symbol.for("Dexie");
var Aa = globalThis[bc] || (globalThis[bc] = Sa);
if (Sa.semVer !== Aa.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${Sa.semVer} and ${Aa.semVer}`);
var Op = class extends Aa {
  // number = type of the primkey
  constructor() {
    super("MyAppDatabase");
    T(this, "files");
    this.version(1).stores({
      files: "id, file"
    });
  }
};
var ii = class ii2 extends Re {
  constructor(e) {
    super(e);
    T(this, "enabled", true);
    T(this, "onFragmentsDeleted", new $());
    T(this, "onFragmentsLoaded", new $());
    T(this, "onDisposed", new $());
    T(this, "models", {});
    T(this, "serializer", new Xi());
    T(this, "maxRamTime", 5e3);
    T(this, "useCache", true);
    T(this, "_culler", null);
    T(this, "_world", null);
    T(this, "_ramCache", /* @__PURE__ */ new Map());
    T(this, "_fileCache", new Op());
    T(this, "_url", null);
    T(this, "_isDisposing", false);
    T(this, "_geometryInstances", {});
    T(this, "_loadedFragments", {});
    T(this, "fragIDData", /* @__PURE__ */ new Map());
    T(this, "_baseMaterial", new MeshLambertMaterial());
    T(this, "_baseMaterialT", new MeshLambertMaterial({
      transparent: true,
      opacity: 0.5
    }));
    this.components.add(ii2.uuid, this);
  }
  get url() {
    if (!this._url)
      throw new Error("url must be set before using the streaming service!");
    return this._url;
  }
  set url(e) {
    this._url = e;
  }
  get world() {
    if (!this._world)
      throw new Error("You must set a world before using the streamer!");
    return this._world;
  }
  set world(e) {
    var n;
    this._world = e, (n = this._culler) == null || n.dispose(), this._culler = new Pp(this.components, e), this._culler.onViewUpdated.add(
      async ({ toLoad: s, toRemove: i, toShow: r, toHide: o }) => {
        await this.loadFoundGeometries(s), await this.unloadLostGeometries(i), this.setMeshVisibility(r, true), this.setMeshVisibility(o, false);
      }
    );
  }
  get culler() {
    if (!this._culler)
      throw new Error("You must set a world before using the streamer!");
    return this._culler;
  }
  dispose() {
    var e;
    this._isDisposing = true, this.onFragmentsLoaded.reset(), this.onFragmentsDeleted.reset(), this._ramCache.clear(), this.models = {}, this._geometryInstances = {}, this._loadedFragments = {}, this.fragIDData.clear(), this._baseMaterial.dispose(), this._baseMaterialT.dispose(), (e = this._culler) == null || e.dispose(), this.onDisposed.trigger(ii2.uuid), this.onDisposed.reset(), this._isDisposing = false;
  }
  async load(e, n, s) {
    const { assets: i, geometries: r, globalDataFileId: o } = e, l = this.url + o, d = await (await fetch(l)).arrayBuffer(), m = new Uint8Array(d), g = this.components.get(We).load(m, { coordinate: n });
    this.world.scene.three.add(g);
    const { opaque: I, transparent: y } = g.geometryIDs;
    for (const [A, F] of I) {
      const P = g.keyFragments.get(F);
      if (P === void 0)
        throw new Error("Malformed fragments group!");
      this.fragIDData.set(P, [g, A, /* @__PURE__ */ new Set()]);
    }
    for (const [A, F] of y) {
      const P = g.keyFragments.get(F);
      if (P === void 0)
        throw new Error("Malformed fragments group!");
      this.fragIDData.set(P, [g, Math.abs(A), /* @__PURE__ */ new Set()]);
    }
    this.culler.add(g.uuid, i, r), this.models[g.uuid] = { assets: i, geometries: r };
    const x = /* @__PURE__ */ new Map();
    for (const A of i) {
      const F = A.id;
      for (const { transformation: P, geometryID: b, color: O } of A.geometries) {
        x.has(b) || x.set(b, []);
        const k = x.get(b);
        if (!k)
          throw new Error("Malformed instances");
        k.push({ id: F, transformation: P, color: O });
      }
    }
    if (this._geometryInstances[g.uuid] = x, s) {
      const A = /* @__PURE__ */ new Map(), F = /* @__PURE__ */ new Map();
      for (const H in s.ids) {
        const K = s.ids[H], Z = parseInt(H, 10);
        A.set(Z, K);
      }
      for (const H in s.types) {
        const K = s.types[H], Z = parseInt(H, 10);
        F.set(Z, K);
      }
      const P = o.replace(
        "-global",
        "-properties"
      );
      g.streamSettings = {
        baseUrl: this.url,
        baseFileName: P,
        ids: A,
        types: F
      };
      const { indexesFile: b } = s, k = await (await fetch(this.url + b)).text(), Y = this.components.get(Xr);
      Y.setRelationMap(g, Y.getRelationsMapFromJSON(k));
    }
    return this.culler.needsUpdate = true, g;
  }
  remove(e) {
    this._isDisposing = true;
    const s = this.components.get(We).groups.get(e);
    if (s === void 0) {
      console.log("Group to delete not found.");
      return;
    }
    delete this.models[e], delete this._geometryInstances[e], delete this._loadedFragments[e];
    const i = s.keyFragments.values();
    for (const r of i)
      this.fragIDData.delete(r);
    this.culler.remove(e), this._isDisposing = false;
  }
  setVisibility(e, n) {
    const s = /* @__PURE__ */ new Map();
    for (const i in n) {
      const r = this.fragIDData.get(i);
      if (r === void 0)
        throw new Error("Geometry not found!");
      const [o, l, h] = r, d = o.uuid;
      s.has(d) || s.set(d, /* @__PURE__ */ new Map());
      const m = s.get(d), f = n[i];
      for (const I of f)
        e ? h.delete(I) : h.add(I);
      m.get(l) || m.set(l, /* @__PURE__ */ new Set());
      const g = m.get(l);
      for (const I of f)
        g.add(I);
    }
    for (const [i, r] of s) {
      this.culler.setVisibility(e, i, r);
      for (const [o] of r) {
        const l = this._loadedFragments[i];
        if (!l)
          continue;
        const h = l[o];
        if (h)
          for (const d of h) {
            const m = n[d.id];
            m && d.setVisibility(e, m);
          }
      }
    }
    this.culler.needsUpdate = true;
  }
  async clearCache() {
    await this._fileCache.delete();
  }
  get() {
  }
  update() {
  }
  async loadFoundGeometries(e) {
    for (const n in e) {
      if (this._isDisposing)
        return;
      const i = this.components.get(We).groups.get(n);
      if (!i)
        return;
      const { geometries: r } = this.models[n], o = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Set();
      for (const [f, g] of e[n])
        for (const I of g) {
          l.add(I);
          const y = r[I];
          if (!y)
            throw new Error("Geometry not found");
          if (y.geometryFile) {
            const x = y.geometryFile, A = o.get(x) || 0;
            o.set(x, A + f);
          }
        }
      const h = Array.from(o).sort((f, g) => g[1] - f[1]);
      for (const [f] of h) {
        const g = this.url + f;
        if (!this._ramCache.has(g)) {
          let x = new Uint8Array();
          if (this.useCache) {
            const F = await this._fileCache.files.get(g);
            if (F)
              x = F.file;
            else {
              const b = await (await fetch(g)).arrayBuffer();
              x = new Uint8Array(b), this._fileCache.files.add({ file: x, id: g });
            }
          } else {
            const P = await (await fetch(g)).arrayBuffer();
            x = new Uint8Array(P);
          }
          const A = this.serializer.import(x);
          this._ramCache.set(g, { data: A, time: performance.now() });
        }
        const I = this._ramCache.get(g);
        if (!I)
          continue;
        I.time = performance.now();
        const y = [];
        if (I)
          for (const [x, { position: A, index: F, normal: P }] of I.data) {
            if (this._isDisposing)
              return;
            if (!l.has(x) || !this._geometryInstances[n] || !this._geometryInstances[n].has(x))
              continue;
            const O = this._geometryInstances[n].get(x);
            if (!O)
              throw new Error("Instances not found!");
            const k = new BufferGeometry(), Y = new BufferAttribute(A, 3), H = new BufferAttribute(P, 3);
            k.setAttribute("position", Y), k.setAttribute("normal", H), k.setIndex(Array.from(F));
            const K = [], Z = [];
            for (const q of O)
              q.color[3] === 1 ? Z.push(q) : K.push(q);
            this.newFragment(i, x, k, K, true, y), this.newFragment(i, x, k, Z, false, y);
          }
        y.length && !this._isDisposing && this.onFragmentsLoaded.trigger(y);
      }
      const d = /* @__PURE__ */ new Set(), m = performance.now();
      for (const [f, { time: g }] of this._ramCache)
        m - g > this.maxRamTime && d.add(f);
      for (const f of d)
        this._ramCache.delete(f);
    }
  }
  async unloadLostGeometries(e) {
    if (this._isDisposing)
      return;
    const n = [], s = this.components.get(We);
    for (const i in e) {
      const r = s.groups.get(i);
      if (!r)
        throw new Error("Fragment group not found!");
      if (!this._loadedFragments[i])
        continue;
      const o = this._loadedFragments[i], l = e[i];
      for (const h of l) {
        if (this.culler.removeFragment(r.uuid, h), !o[h])
          continue;
        const d = o[h];
        for (const m of d)
          r.items.splice(r.items.indexOf(m), 1), n.push(m);
        delete o[h];
      }
    }
    n.length && this.onFragmentsDeleted.trigger(n);
    for (const i of n)
      s.list.delete(i.id), this.world.meshes.delete(i.mesh), i.mesh.material = [], i.dispose(true);
  }
  setMeshVisibility(e, n) {
    for (const s in e)
      for (const i of e[s]) {
        const r = this._loadedFragments[s];
        if (!r)
          continue;
        const o = r[i];
        if (o)
          for (const l of o)
            l.mesh.visible = n;
      }
  }
  newFragment(e, n, s, i, r, o) {
    if (i.length === 0 || this._isDisposing)
      return;
    const l = e.geometryIDs, h = r ? l.transparent : l.opaque, m = n * (r ? -1 : 1), f = h.get(m);
    if (f === void 0)
      return;
    const g = e.keyFragments.get(f);
    if (g === void 0)
      return;
    const I = this.components.get(We);
    if (I.list.has(g))
      return;
    const x = r ? this._baseMaterialT : this._baseMaterial, A = new Ni(s, x, i.length);
    A.id = g, A.mesh.uuid = g, A.group = e, e.add(A.mesh), e.items.push(A), I.list.set(A.id, A), this.world.meshes.add(A.mesh), this._loadedFragments[e.uuid] || (this._loadedFragments[e.uuid] = {});
    const F = this._loadedFragments[e.uuid];
    F[n] || (F[n] = []), F[n].push(A);
    const P = /* @__PURE__ */ new Map();
    for (let Y = 0; Y < i.length; Y++) {
      const H = new Matrix4(), K = new Color(), { id: Z, transformation: q, color: ne } = i[Y];
      H.fromArray(q);
      const [se, ue, me] = ne;
      if (K.setRGB(se, ue, me, "srgb"), P.has(Z)) {
        const Ie = P.get(Z);
        if (!Ie)
          continue;
        Ie.transforms.push(H), Ie.colors && Ie.colors.push(K);
      } else
        P.set(Z, { id: Z, colors: [K], transforms: [H] });
    }
    const b = Array.from(P.values());
    A.add(b);
    const O = this.fragIDData.get(A.id);
    if (!O)
      throw new Error("Fragment data not found!");
    const k = O[2];
    k.size && A.setVisibility(false, k), this.culler.addFragment(e.uuid, n, A), o.push(A);
  }
};
T(ii, "uuid", "22437e8d-9dbc-4b99-a04f-d2da280d50c8");
var xc = ii;
var ri = class ri2 extends Re {
  constructor(e) {
    super(e);
    T(this, "onDisposed", new $());
    T(this, "onBeforeUpdate", new $());
    T(this, "onAfterUpdate", new $());
    T(this, "onSetup", new $());
    T(this, "isSetup", false);
    T(this, "enabled", true);
    T(this, "events", {});
    T(this, "multiple", "ctrlKey");
    T(this, "zoomFactor", 1.5);
    T(this, "zoomToSelection", false);
    T(this, "backupColor", null);
    T(this, "selection", {});
    T(this, "config", {
      selectName: "select",
      hoverName: "hover",
      selectionColor: new Color("#BCF124"),
      hoverColor: new Color("#6528D7"),
      autoHighlightOnClick: true,
      world: null
    });
    T(this, "colors", /* @__PURE__ */ new Map());
    T(this, "_mouseState", {
      down: false,
      moved: false
    });
    T(this, "_colorsBeforeSelect", {});
    T(this, "saveHighlightersBeforeSelect", (e2) => {
      var s;
      const n = this.components.get(We);
      for (const i in e2) {
        const r = n.list.get(i);
        if (!r)
          continue;
        const o = (s = r.group) == null ? void 0 : s.uuid;
        if (o)
          for (const l in this.selection) {
            if (l === this.config.selectName || l === this.config.hoverName)
              continue;
            const h = this.selection[l][i];
            if (h) {
              l in this._colorsBeforeSelect || (this._colorsBeforeSelect[l] = {}), o in this._colorsBeforeSelect[l] || (this._colorsBeforeSelect[l] = { [o]: /* @__PURE__ */ new Set() });
              for (const d of h)
                this._colorsBeforeSelect[l][o].add(d);
            }
          }
      }
    });
    T(this, "restoreHighlightersAfterDeselect", () => {
      const e2 = this.components.get(We);
      for (const n in this._colorsBeforeSelect) {
        let s = {};
        const i = this._colorsBeforeSelect[n];
        for (const r in i) {
          const o = e2.groups.get(r);
          if (!o)
            continue;
          const l = o.getFragmentMap(i[r]);
          s = { ...s, ...l };
        }
        this.highlightByID(n, s, false, false);
      }
      this._colorsBeforeSelect = {};
    });
    T(this, "clearHover", () => {
      this.selection[this.config.hoverName] = {};
    });
    T(this, "onMouseDown", () => {
      this.enabled && (this._mouseState.down = true);
    });
    T(this, "onMouseUp", async (e2) => {
      const n = this.config.world;
      if (!n)
        throw new Error("No world found!");
      if (!n.renderer)
        throw new Error("This world doesn't have a renderer!");
      if (this.enabled && e2.target === n.renderer.three.domElement) {
        if (this._mouseState.down = false, this._mouseState.moved || e2.button !== 0) {
          this._mouseState.moved = false;
          return;
        }
        if (this._mouseState.moved = false, this.config.autoHighlightOnClick) {
          const s = this.multiple === "none" ? true : !e2[this.multiple];
          await this.highlight(this.config.selectName, s, this.zoomToSelection);
        }
      }
    });
    T(this, "onMouseMove", async () => {
      if (!this.enabled)
        return;
      if (this._mouseState.moved) {
        this.clear(this.config.hoverName);
        return;
      }
      this._mouseState.moved = this._mouseState.down;
      const e2 = {};
      for (const n in this.selection) {
        if (n === this.config.hoverName)
          continue;
        const s = this.selection[n];
        for (const i in s) {
          i in e2 || (e2[i] = /* @__PURE__ */ new Set());
          const r = s[i];
          for (const o of r)
            e2[i].add(o);
        }
      }
      await this.highlight(this.config.hoverName, true, false, e2);
    });
    this.components.add(ri2.uuid, this);
  }
  async dispose() {
    this.setupEvents(false), this.onBeforeUpdate.reset(), this.onAfterUpdate.reset(), this.selection = {};
    for (const e in this.events)
      this.events[e].onClear.reset(), this.events[e].onHighlight.reset();
    this.onSetup.reset(), this.events = {}, this.onDisposed.trigger(ri2.uuid), this.onDisposed.reset();
  }
  add(e, n) {
    if (this.selection[e] || this.colors.has(e))
      throw new Error("A selection with that name already exists!");
    this.colors.set(e, n), this.selection[e] = {}, this.events[e] = {
      onHighlight: new $(),
      onClear: new $()
    };
  }
  async highlight(e, n = true, s = this.zoomToSelection, i = {}) {
    if (!this.enabled)
      return null;
    if (!this.config.world)
      throw new Error("No world found in config!");
    const r = this.config.world;
    if (!this.selection[e])
      throw new Error(`Selection ${e} does not exist.`);
    const l = this.components.get(We).meshes, m = this.components.get(Dt).get(r).castRay(l);
    if (!m || !m.face)
      return this.clear(e), null;
    const f = m.object, g = f.geometry, I = m.instanceId;
    if (!g || I === void 0)
      return null;
    const y = f.fragment.getItemID(I);
    if (y === null)
      throw new Error("Item ID not found!");
    const x = f.fragment.group;
    if (!x)
      throw new Error("Fragment must belong to a FragmentsGroup!");
    const A = x.getFragmentMap([y]);
    return await this.highlightByID(
      e,
      A,
      n,
      s,
      i
    ), { id: y, fragments: A };
  }
  async highlightByID(e, n, s = true, i = this.zoomToSelection, r = {}) {
    if (!this.enabled)
      return;
    s && this.clear(e);
    const o = this.components.get(We), l = this.colors.get(e);
    if (!l)
      throw new Error("Color for selection not found!");
    const h = {};
    for (const d in n) {
      const m = n[d], f = r[d];
      for (const g of m)
        (!f || !f.has(g)) && (h[d] || (h[d] = /* @__PURE__ */ new Set()), h[d].add(g));
    }
    for (const d in h) {
      const m = o.list.get(d);
      if (!m)
        continue;
      this.selection[e][d] || (this.selection[e][d] = /* @__PURE__ */ new Set());
      const f = n[d];
      for (const g of f)
        this.selection[e][d].add(g), m.setColor(l, [g]);
    }
    this.events[e].onHighlight.trigger(this.selection[e]), i && await this.zoomSelection(e);
  }
  /**
   * Clears any selection previously made by calling {@link highlight}.
   */
  clear(e) {
    const n = e ? [e] : Object.keys(this.selection);
    for (const s of n) {
      const i = this.components.get(We), r = this.selection[s];
      for (const o in this.selection[s]) {
        const l = i.list.get(o);
        if (!l)
          continue;
        const h = r[o];
        h && (this.backupColor ? l.setColor(this.backupColor) : l.resetColor(h));
      }
      this.events[s].onClear.trigger(null), this.selection[s] = {};
    }
  }
  setup(e) {
    this.config = { ...this.config, ...e }, this.add(this.config.selectName, this.config.selectionColor), this.add(this.config.hoverName, this.config.hoverColor), this.setupEvents(true), this.enabled = true, this.isSetup = true, this.onSetup.trigger(this);
  }
  async zoomSelection(e) {
    if (!this.config.world)
      throw new Error("No world found in config!");
    const n = this.config.world;
    if (!n.camera.hasCameraControls())
      return;
    const s = this.components.get($c), i = this.components.get(We);
    s.reset();
    const r = this.selection[e];
    if (!Object.keys(r).length)
      return;
    for (const A in r) {
      const F = i.list.get(A);
      if (!F)
        continue;
      const P = r[A];
      s.addMesh(F.mesh, P);
    }
    const o = s.getSphere(), l = 1 / 0, h = -1 / 0, { x: d, y: m, z: f } = o.center, g = o.radius === l || d === l || m === l || f === l, I = o.radius === h || d === h || m === h || f === h, y = o.radius === 0;
    if (g || I || y)
      return;
    o.radius *= this.zoomFactor, await n.camera.controls.fitToSphere(o, true);
  }
  setupEvents(e) {
    if (!this.config.world)
      throw new Error("No world found while setting up events!");
    if (this.config.world.isDisposing)
      return;
    if (!this.config.world.renderer)
      throw new Error("The given world doesn't have a renderer!");
    const n = this.config.world.renderer.three.domElement, s = this.events[this.config.selectName].onHighlight;
    s.remove(this.clearHover), s.remove(this.saveHighlightersBeforeSelect);
    const i = this.events[this.config.selectName].onClear;
    i.remove(this.restoreHighlightersAfterDeselect), n.removeEventListener("mousedown", this.onMouseDown), n.removeEventListener("mouseup", this.onMouseUp), n.removeEventListener("mousemove", this.onMouseMove), e && (s.add(this.clearHover), s.add(this.saveHighlightersBeforeSelect), i.add(this.restoreHighlightersAfterDeselect), n.addEventListener("mousedown", this.onMouseDown), n.addEventListener("mouseup", this.onMouseUp), n.addEventListener("mousemove", this.onMouseMove));
  }
};
T(ri, "uuid", "cb8a76f2-654a-4b50-80c6-66fd83cafd77");
var Sc = ri;
var Vr = class Vr2 extends Re {
  constructor(e) {
    super(e);
    T(this, "onDisposed", new $());
    T(this, "onNavigated", new $());
    T(this, "onExited", new $());
    T(this, "enabled", false);
    T(this, "currentPlan", null);
    T(this, "defaultSectionOffset", 1.5);
    T(this, "defaultCameraOffset", 30);
    T(this, "list", []);
    T(this, "world");
    T(this, "_floorPlanViewCached", false);
    T(this, "_previousCamera", new Vector3());
    T(this, "_previousTarget", new Vector3());
    T(this, "_previousProjection", "Perspective");
    this.components.add(Vr2.uuid, this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.onExited.reset(), this.onNavigated.reset(), this.list = [], this.onDisposed.trigger(), this.onDisposed.reset();
  }
  // TODO: Compute georreference matrix when generating fragmentsgroup
  // so that we can correctly add floors in georreferenced models
  // where the IfcSite / IfcBuilding have location information
  async generate(e) {
    if (!e.hasProperties)
      throw new Error("Properties are needed to compute plan views!");
    const n = await e.getAllPropertiesOfType(
      IFCBUILDINGSTOREY
    );
    if (!n)
      throw new Error("Floorplans not found!");
    const s = e.coordinationMatrix.elements[13], i = await wn.getUnits(e);
    for (const r of Object.values(n)) {
      const o = { value: 0 };
      this.getAbsoluteFloorHeight(r.ObjectPlacement, o);
      const l = o.value * i + s;
      this.create({
        name: r.Name.value,
        id: r.GlobalId.value,
        normal: new Vector3(0, -1, 0),
        point: new Vector3(0, l, 0),
        ortho: true,
        offset: this.defaultSectionOffset
      });
    }
  }
  /**
   * Creates a new floor plan in the navigator.
   *
   * @param config - Necessary data to initialize the floor plan.
   */
  create(e) {
    if (!this.world)
      throw new Error(
        "You must set a world before creating the clipping planes!"
      );
    if (this.list.find((r) => r.id === e.id)) {
      console.warn(`There's already a plan with the id: ${e.id}`);
      return;
    }
    const s = this.createClippingPlane(e), i = { ...e, plane: s };
    this.list.push(i);
  }
  /**
   * Make the navigator go to the specified floor plan.
   *
   * @param id - Floor plan to go to.
   * @param animate - Whether to animate the camera transition.
   */
  async goTo(e, n = false) {
    var s;
    ((s = this.currentPlan) == null ? void 0 : s.id) !== e && (this.onNavigated.trigger({ id: e }), this.storeCameraPosition(), await this.hidePreviousClippingPlane(), this.updateCurrentPlan(e), await this.activateCurrentPlan(), this.enabled || (await this.moveCameraTo2DPlanPosition(n), this.enabled = true));
  }
  /**
   * Deactivate navigator and go back to the previous view.
   *
   * @param animate - Whether to animate the camera transition.
   */
  async exitPlanView(e = false) {
    if (!this.enabled || !this.world)
      return;
    this.enabled = false, this.onExited.trigger(), this.cacheFloorplanView();
    const n = this.world.camera;
    n.set("Orbit"), await n.projection.set(this._previousProjection), this.currentPlan && this.currentPlan.plane && (this.currentPlan.plane.enabled = false, this.currentPlan.plane.edges.enabled = false, this.currentPlan.plane.edges.visible = false), this.currentPlan = null, await n.controls.setLookAt(
      this._previousCamera.x,
      this._previousCamera.y,
      this._previousCamera.z,
      this._previousTarget.x,
      this._previousTarget.y,
      this._previousTarget.z,
      e
    );
  }
  storeCameraPosition() {
    this.enabled ? this.cacheFloorplanView() : this.store3dCameraPosition();
  }
  createClippingPlane(e) {
    if (!this.world)
      throw new Error("World is needed to create clipping planes!");
    const { normal: n, point: s } = e, i = s.clone();
    e.offset && (i.y += e.offset);
    const r = this.components.get(Sr), o = r.Type;
    r.Type = hi;
    const l = r.createFromNormalAndCoplanarPoint(
      this.world,
      n,
      i
    );
    return l.edges.update(), l.visible = false, l.enabled = false, l.edges.enabled = false, l.edges.visible = false, r.Type = o, l;
  }
  cacheFloorplanView() {
    if (!this.world)
      throw new Error("World is needed to create clipping planes!");
    this._floorPlanViewCached = true, this.world.camera.controls.saveState();
  }
  async moveCameraTo2DPlanPosition(e) {
    if (!this.world)
      throw new Error("World is needed to create clipping planes!");
    const n = this.world.camera;
    this._floorPlanViewCached ? await n.controls.reset(e) : await n.controls.setLookAt(0, 100, 0, 0, 0, 0, e);
  }
  async activateCurrentPlan() {
    if (!this.world)
      throw new Error("World is needed to create clipping planes!");
    if (!this.currentPlan)
      throw new Error("Current plan is not defined.");
    const e = this.world.camera;
    this.currentPlan.plane && (this.currentPlan.plane.enabled = true, this.currentPlan.plane.edges.fillNeedsUpdate = true, this.currentPlan.plane.edges.visible = true), e.set("Plan");
    const n = this.currentPlan.ortho ? "Orthographic" : "Perspective";
    await e.projection.set(n);
  }
  store3dCameraPosition() {
    if (!this.world)
      throw new Error("World is needed to create clipping planes!");
    const e = this.world.camera;
    e.three.getWorldPosition(this._previousCamera), e.controls.getTarget(this._previousTarget), this._previousProjection = e.projection.current;
  }
  updateCurrentPlan(e) {
    const n = this.list.find((s) => s.id === e);
    if (!n)
      throw new Error("The specified plan is undefined!");
    this.currentPlan = n;
  }
  async hidePreviousClippingPlane() {
    if (this.currentPlan) {
      const e = this.currentPlan.plane;
      e && (e.enabled = false), this.currentPlan.plane instanceof hi && (this.currentPlan.plane.edges.visible = false);
    }
  }
  getAbsoluteFloorHeight(e, n) {
    const s = e.RelativePlacement.Location.Coordinates;
    n.value += s[2].value, e.PlacementRelTo && this.getAbsoluteFloorHeight(e.PlacementRelTo, n);
  }
};
T(Vr, "uuid", "a80874aa-1c93-43a4-80f2-df346da086b1");
var Ac = Vr;

export {
  ft,
  Bf,
  nn,
  xa,
  hi,
  ms,
  pc,
  Rh,
  mc,
  gc,
  Ec,
  vc,
  ui,
  Ba,
  Ic,
  yc,
  Un,
  wc,
  Cc,
  Tc,
  xc,
  Sc,
  Ac
};
/*! Bundled license information:

@thatopen/components-front/dist/index.js:
  (*!
   * camera-controls
   * https://github.com/yomotsu/camera-controls
   * (c) 2017 @yomotsu
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=chunk-OSICQSK3.js.map
